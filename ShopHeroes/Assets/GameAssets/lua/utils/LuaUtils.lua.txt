--LuaUtils
--[[


function fast_assert(condition, ...)
local args = { ... }
if not condition then
if #args > 0 then
assert(condition, ...)
else
assert(condition)
end
end
end
]] --

--[[
print_dump是一个用于调试输出数据的函数，能够打印出nil,boolean,number,string,table类型的数据，以及table类型值的元表
参数data表示要输出的数据
参数showMetatable表示是否要输出元表
参数lastCount用于格式控制，用户请勿使用该变量
]]
function print_dump(data, showMetatable, lastCount)
	local pfunc = print --//io.write;
	if type(data) ~= "table" then
		--Value
		if type(data) == "string" then
			pfunc('"', data, '"')
		else
			pfunc(tostring(data))
		end
	else
		--Format
		local count = lastCount or 0
		count = count + 1
		pfunc("{\n")
		--Metatable
		if showMetatable then
			for i = 1, count do
				pfunc("\t")
			end
			local mt = getmetatable(data)
			pfunc('"__metatable" = ')
			print_dump(mt, showMetatable, count) -- 如果不想看到元表的元表，可将showMetatable处填nil
			pfunc(",\n") --如果不想在元表后加逗号，可以删除这里的逗号
		end
		--Key
		for key, value in pairs(data) do
			for i = 1, count do
				pfunc("\t")
			end
			if type(key) == "string" then
				pfunc('"', key, '" = ')
			elseif type(key) == "number" then
				pfunc("[", key, "] = ")
			else
				pfunc(tostring(key))
			end
			print_dump(value, showMetatable, count) -- 如果不想看到子table的元表，可将showMetatable处填nil
			pfunc(",\n") --如果不想在table的每一个item后加逗号，可以删除这里的逗号
		end
		--Format
		for i = 1, lastCount or 0 do
			pfunc("\t")
		end
		pfunc("}")
	end
	--Format
	if not lastCount then
		pfunc("\n")
	end
end

function dump_value_(v)
	if type(v) == "string" then
		v = '"' .. v .. '"'
	end
	return tostring(v)
end

function split(input, delimiter)
	input = tostring(input)
	delimiter = tostring(delimiter)
	if (delimiter == "") then
		return false
	end
	local pos, arr = 0, {}
	for st, sp in function()
			return string.find(input, delimiter, pos, true)
		end do
		table.insert(arr, string.sub(input, pos, st - 1))
		pos = sp + 1
	end
	table.insert(arr, string.sub(input, pos))
	return arr
end

function trim(input)
	return (string.gsub(input, "^%s*(.-)%s*$", "%1"))
end

--[[
打印table的工具函数
@params value 需要打印的内容
@params desciption 描述
@params nesting 打印内容的嵌套级数，默认3级
]]
function dump(value, desciption, nesting)
	if type(nesting) ~= "number" then
		nesting = 3
	end

	local lookupTable = {}
	local result = {}

	local traceback = split(debug.traceback("", 2), "\n")
	-- print("dump from: " .. trim(traceback[3]))

	local function dump_(value, desciption, indent, nest, keylen)
		desciption = desciption or "<var>"
		local spc = ""
		if type(keylen) == "number" then
			spc = string.rep(" ", keylen - string.len(dump_value_(desciption)))
		end
		if type(value) ~= "table" then
			result[#result + 1] = string.format("%s%s%s = %s", indent, dump_value_(desciption), spc, dump_value_(value))
		elseif lookupTable[tostring(value)] then
			result[#result + 1] = string.format("%s%s%s = *REF*", indent, dump_value_(desciption), spc)
		else
			lookupTable[tostring(value)] = true
			if nest > nesting then
				result[#result + 1] = string.format("%s%s = *MAX NESTING*", indent, dump_value_(desciption))
			else
				result[#result + 1] = string.format("%s%s = {", indent, dump_value_(desciption))
				local indent2 = indent .. "    "
				local keys = {}
				local keylen = 0
				local values = {}
				for k, v in pairs(value) do
					keys[#keys + 1] = k
					local vk = dump_value_(k)
					local vkl = string.len(vk)
					if vkl > keylen then
						keylen = vkl
					end
					values[k] = v
				end
				table.sort(
					keys,
					function(a, b)
						if type(a) == "number" and type(b) == "number" then
							return a < b
						else
							return tostring(a) < tostring(b)
						end
					end
				)
				for i, k in ipairs(keys) do
					dump_(values[k], k, indent2, nest + 1, keylen)
				end
				result[#result + 1] = string.format("%s}", indent)
			end
		end
	end
	dump_(value, desciption, "- ", 1)

	for i, line in ipairs(result) do
		print(line)
	end
end

StringUtils = {}

function StringUtils:split(str, pat)
	local t = {} -- NOTE: use {n = 0} in Lua-5.0
	local fpat = "(.-)" .. pat
	local last_end = 1
	local s, e, cap = str:find(fpat, 1)
	while s do
		if s ~= 1 or cap ~= "" then
			table.insert(t, cap)
		end
		last_end = e + 1
		s, e, cap = str:find(fpat, last_end)
	end
	if last_end <= #str then
		cap = str:sub(last_end)
		table.insert(t, cap)
	end
	return t
end

function StringUtils:length(str)
	return #str
end

function StringUtils:utf8len(str)
	local len = string.len(str)
	local left = len
	local cnt = 0
	local arr = {0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc}
	while left ~= 0 do
		local tmp = string.byte(str, -left)
		local i = #arr
		while arr[i] do
			if tmp >= arr[i] then
				left = left - i
				break
			end
			i = i - 1
		end
		cnt = cnt + 1
	end
	return cnt
end

-- 获取字符串的长度（任何单个字符长度都为1）
function StringUtils:getStringLength(inputstr)
	if not inputstr or type(inputstr) ~= "string" or #inputstr <= 0 then
		return nil
	end
	local length = 0 -- 字符的个数
	local i = 1
	while true do
		local curByte = string.byte(inputstr, i)
		local byteCount = 1
		if curByte > 239 then
			byteCount = 4 -- 4字节字符
		elseif curByte > 223 then
			byteCount = 3 -- 汉字
		elseif curByte > 128 then
			byteCount = 2 -- 双字节字符
		else
			byteCount = 1 -- 单字节字符
		end
		-- local char = string.sub(inputstr, i, i + byteCount - 1)
		-- print(char)  -- 打印单个字符
		i = i + byteCount
		length = length + 1
		if i > #inputstr then
			break
		end
	end
	return length
end

function table_read_only(t)
	local temp = t or {}
	local mt = {
		__index = function(t, k)
			return temp[k]
		end,
		__newindex = function(t, k, v)
			error("attempt to update a read-only table!")
		end
	}
	setmetatable(temp, mt)
	return temp
end

function clone(object)
	local lookup_table = {}
	local function _copy(object)
		if type(object) ~= "table" then
			return object
		elseif lookup_table[object] then
			return lookup_table[object]
		end
		local new_table = {}
		lookup_table[object] = new_table
		for key, value in pairs(object) do
			new_table[_copy(key)] = _copy(value)
		end
		return setmetatable(new_table, getmetatable(object))
	end
	return _copy(object)
end
