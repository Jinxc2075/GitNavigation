local JSON = require("Libs/json/json4lua")
local MsgIndex = 0
local function IncKeyMsgSeq()
    MsgIndex = MsgIndex + 1
    return MsgIndex
end
MsgType = {}
MsgTypeCmd = {}

local BASE_CMD = 10000
MsgTypeCmd.PROTO_VERTION = 2020072201
MsgTypeCmd.Request_Gm_Command_Cmd = BASE_CMD + 50
MsgTypeCmd.Response_Gm_Command_Cmd = BASE_CMD + 51
MsgTypeCmd.Request_Client_Error_Cmd = BASE_CMD + 60
MsgTypeCmd.Response_Client_Error_Cmd = BASE_CMD + 61
MsgTypeCmd.Response_Client_Af_Cmd = BASE_CMD + 62
MsgTypeCmd.Request_Gate_Cmd = BASE_CMD + 88
MsgTypeCmd.Response_Gate_Cmd = BASE_CMD + 89
MsgTypeCmd.Request_Csv_List_Cmd = BASE_CMD + 92
MsgTypeCmd.Response_Csv_List_Cmd = BASE_CMD + 93
MsgTypeCmd.Request_Csv_Load_Cmd = BASE_CMD + 94
MsgTypeCmd.Response_Csv_Load_Cmd = BASE_CMD + 95
MsgTypeCmd.Request_Heartbeat_Cmd = BASE_CMD + 90
MsgTypeCmd.Response_Heartbeat_Cmd = BASE_CMD + 91
MsgTypeCmd.Request_Heartbeat2_Cmd = BASE_CMD + 97
MsgTypeCmd.Response_Heartbeat2_Cmd = BASE_CMD + 98
MsgTypeCmd.Response_Notify_Cmd = BASE_CMD + 96
MsgTypeCmd.Request_User_BindingQuery_Cmd = BASE_CMD + 70
MsgTypeCmd.Response_User_BindingQuery_Cmd = BASE_CMD + 71
MsgTypeCmd.Request_User_Binding_Cmd = BASE_CMD + 72
MsgTypeCmd.Response_User_Binding_Cmd = BASE_CMD + 73
MsgTypeCmd.Request_User_BindingClaim_Cmd = BASE_CMD + 74
MsgTypeCmd.Response_User_BindingClaim_Cmd = BASE_CMD + 75
MsgTypeCmd.Request_User_Login_Cmd = BASE_CMD + 100
MsgTypeCmd.Response_User_Login_Cmd = BASE_CMD + 101
MsgTypeCmd.Request_User_Create_Cmd = BASE_CMD + 102
MsgTypeCmd.Response_User_Create_Cmd = BASE_CMD + 103
MsgTypeCmd.Request_User_Data_Cmd = BASE_CMD + 104
MsgTypeCmd.Response_User_Data_Cmd = BASE_CMD + 105
MsgTypeCmd.Response_User_DataChange_Cmd = BASE_CMD + 106
MsgTypeCmd.Request_User_ChangeName_Cmd = BASE_CMD + 107
MsgTypeCmd.Response_User_ChangeName_Cmd = BASE_CMD + 108
MsgTypeCmd.Request_User_DressList_Cmd = BASE_CMD + 109
MsgTypeCmd.Response_User_DressList_Cmd = BASE_CMD + 110
MsgTypeCmd.Request_User_BuyDress_Cmd = BASE_CMD + 111
MsgTypeCmd.Response_User_BuyDress_Cmd = BASE_CMD + 112
MsgTypeCmd.Request_User_Custom_Cmd = BASE_CMD + 113
MsgTypeCmd.Response_User_Custom_Cmd = BASE_CMD + 114
MsgTypeCmd.Request_User_Detail_Cmd = BASE_CMD + 115
MsgTypeCmd.Response_User_Detail_Cmd = BASE_CMD + 116
MsgTypeCmd.Request_User_SetGuide_Cmd = BASE_CMD + 117
MsgTypeCmd.Response_User_SetGuide_Cmd = BASE_CMD + 118
MsgTypeCmd.Request_User_SkipGuide_Cmd = BASE_CMD + 119
MsgTypeCmd.Response_User_SkipGuide_Cmd = BASE_CMD + 120
MsgTypeCmd.Request_User_MainTask_Cmd = BASE_CMD + 121
MsgTypeCmd.Response_User_MainTask_Cmd = BASE_CMD + 122
MsgTypeCmd.Response_User_MainTaskChange_Cmd = BASE_CMD + 123
MsgTypeCmd.Request_User_MainTaskReward_Cmd = BASE_CMD + 124
MsgTypeCmd.Response_User_MainTaskReward_Cmd = BASE_CMD + 125
MsgTypeCmd.Request_User_TriggerGuide_Cmd = BASE_CMD + 126
MsgTypeCmd.Response_User_TriggerGuide_Cmd = BASE_CMD + 127
MsgTypeCmd.Request_User_CheckTriggerGuide_Cmd = BASE_CMD + 128
MsgTypeCmd.Response_User_CheckTriggerGuide_Cmd = BASE_CMD + 129
MsgTypeCmd.Request_User_TriggerGuideFurnitureUpgrade_Cmd = BASE_CMD + 147
MsgTypeCmd.Response_User_TriggerGuideFurnitureUpgrade_Cmd = BASE_CMD + 148
MsgTypeCmd.Request_User_PetInfo_Cmd = BASE_CMD + 130
MsgTypeCmd.Response_User_PetInfo_Cmd = BASE_CMD + 131
MsgTypeCmd.Request_User_PetChangeName_Cmd = BASE_CMD + 132
MsgTypeCmd.Response_User_PetChangeName_Cmd = BASE_CMD + 133
MsgTypeCmd.Request_User_PetFeed_Cmd = BASE_CMD + 134
MsgTypeCmd.Response_User_PetFeed_Cmd = BASE_CMD + 135
MsgTypeCmd.Request_User_PetInfoUpdate_Cmd = BASE_CMD + 136
MsgTypeCmd.Response_User_PetInfoUpdate_Cmd = BASE_CMD + 137
MsgTypeCmd.Request_User_BuyPetSlot_Cmd = BASE_CMD + 138
MsgTypeCmd.Response_User_BuyPetSlot_Cmd = BASE_CMD + 139
MsgTypeCmd.Request_User_BuyPet_Cmd = BASE_CMD + 140
MsgTypeCmd.Response_User_BuyPet_Cmd = BASE_CMD + 141
MsgTypeCmd.Response_User_UserPetInfoUpdate_Cmd = BASE_CMD + 142
MsgTypeCmd.Request_User_SetPetSlot_Cmd = BASE_CMD + 143
MsgTypeCmd.Response_User_SetPetSlot_Cmd = BASE_CMD + 144
MsgTypeCmd.Request_User_SetMainPet_Cmd = BASE_CMD + 145
MsgTypeCmd.Response_User_SetMainPet_Cmd = BASE_CMD + 146
MsgTypeCmd.Response_User_CommonReward_Cmd = BASE_CMD + 149
MsgTypeCmd.Request_User_BehaviorCounter_Cmd = BASE_CMD + 157
MsgTypeCmd.Response_User_BehaviorCounter_Cmd = BASE_CMD + 158
MsgTypeCmd.Request_User_RankList_Cmd = BASE_CMD + 159
MsgTypeCmd.Response_User_RankList_Cmd = BASE_CMD + 160
MsgTypeCmd.Response_User_ProsperityLevelUp_Cmd = BASE_CMD + 161
MsgTypeCmd.Request_User_ShopperLevelPurchaseReward_Cmd = BASE_CMD + 162
MsgTypeCmd.Response_User_ShopperLevelPurchaseReward_Cmd = BASE_CMD + 163
MsgTypeCmd.Request_User_DailyBoxInfo_Cmd = BASE_CMD + 164
MsgTypeCmd.Response_User_DailyBoxInfo_Cmd = BASE_CMD + 165
MsgTypeCmd.Request_User_DailyBoxReward_Cmd = BASE_CMD + 166
MsgTypeCmd.Response_User_DailyBoxReward_Cmd = BASE_CMD + 167
MsgTypeCmd.Request_User_ExchangeCodeReward_Cmd = BASE_CMD + 168
MsgTypeCmd.Response_User_ExchangeCodeReward_Cmd = BASE_CMD + 169
MsgTypeCmd.Request_User_SearchHeroInfo_Cmd = BASE_CMD + 170
MsgTypeCmd.Response_User_SearchHeroInfo_Cmd = BASE_CMD + 171
MsgTypeCmd.Request_Bag_Data_Cmd = BASE_CMD + 150
MsgTypeCmd.Response_Bag_Data_Cmd = BASE_CMD + 151
MsgTypeCmd.Response_Bag_ResourceChange_Cmd = BASE_CMD + 152
MsgTypeCmd.Request_Bag_Del_Cmd = BASE_CMD + 153
MsgTypeCmd.Response_Bag_Del_Cmd = BASE_CMD + 154
MsgTypeCmd.Request_Bag_LockEquip_Cmd = BASE_CMD + 155
MsgTypeCmd.Response_Bag_LockEquip_Cmd = BASE_CMD + 156
MsgTypeCmd.Request_Resource_ProductionList_Cmd = BASE_CMD + 200
MsgTypeCmd.Response_Resource_ProductionList_Cmd = BASE_CMD + 201
MsgTypeCmd.Request_Resource_ProductionRefresh_Cmd = BASE_CMD + 202
MsgTypeCmd.Response_Resource_ProductionRefresh_Cmd = BASE_CMD + 203
MsgTypeCmd.Request_Resource_BuyProduction_Cmd = BASE_CMD + 204
MsgTypeCmd.Response_Resource_BuyProduction_Cmd = BASE_CMD + 205
MsgTypeCmd.Request_Resource_BuyProductionDaily_Cmd = BASE_CMD + 206
MsgTypeCmd.Response_Resource_BuyProductionDaily_Cmd = BASE_CMD + 207
MsgTypeCmd.Response_Resource_ProductionChange_Cmd = BASE_CMD + 299
MsgTypeCmd.Response_Equip_BagEquipChange_Cmd = BASE_CMD + 300
MsgTypeCmd.Response_Equip_EquipInfoChange_Cmd = BASE_CMD + 301
MsgTypeCmd.Request_Equip_Data_Cmd = BASE_CMD + 302
MsgTypeCmd.Response_Equip_Data_Cmd = BASE_CMD + 303
MsgTypeCmd.Request_Equip_MakeStart_Cmd = BASE_CMD + 304
MsgTypeCmd.Response_Equip_MakeStart_Cmd = BASE_CMD + 305
MsgTypeCmd.Request_Equip_MakeRefresh_Cmd = BASE_CMD + 306
MsgTypeCmd.Response_Equip_MakeRefresh_Cmd = BASE_CMD + 307
MsgTypeCmd.Request_Equip_MakeEnd_Cmd = BASE_CMD + 308
MsgTypeCmd.Response_Equip_MakeEnd_Cmd = BASE_CMD + 309
MsgTypeCmd.Request_Equip_MakeFaster_Cmd = BASE_CMD + 310
MsgTypeCmd.Response_Equip_MakeFaster_Cmd = BASE_CMD + 311
MsgTypeCmd.Request_Equip_MakeImprove_Cmd = BASE_CMD + 314
MsgTypeCmd.Response_Equip_MakeImprove_Cmd = BASE_CMD + 315
MsgTypeCmd.Request_Equip_BuySlot_Cmd = BASE_CMD + 312
MsgTypeCmd.Response_Equip_BuySlot_Cmd = BASE_CMD + 313
MsgTypeCmd.Request_Equip_Activate_Cmd = BASE_CMD + 316
MsgTypeCmd.Response_Equip_Activate_Cmd = BASE_CMD + 317
MsgTypeCmd.Request_Equip_FavoriteEquip_Cmd = BASE_CMD + 318
MsgTypeCmd.Response_Equip_FavoriteEquip_Cmd = BASE_CMD + 319
MsgTypeCmd.Response_Equip_MakingList_Cmd = BASE_CMD + 320
MsgTypeCmd.Request_DailyTask_Data_Cmd = BASE_CMD + 400
MsgTypeCmd.Response_DailyTask_Data_Cmd = BASE_CMD + 401
MsgTypeCmd.Request_DailyTask_Reward_Cmd = BASE_CMD + 402
MsgTypeCmd.Response_DailyTask_Reward_Cmd = BASE_CMD + 403
MsgTypeCmd.Request_DailyTask_Refresh_Cmd = BASE_CMD + 404
MsgTypeCmd.Response_DailyTask_Refresh_Cmd = BASE_CMD + 405
MsgTypeCmd.Response_DailyTask_Change_Cmd = BASE_CMD + 406
MsgTypeCmd.Request_Active_Reward_Cmd = BASE_CMD + 407
MsgTypeCmd.Response_Active_Reward_Cmd = BASE_CMD + 408
MsgTypeCmd.Request_Achievement_Check_Cmd = BASE_CMD + 409
MsgTypeCmd.Response_Achievement_Check_Cmd = BASE_CMD + 410
MsgTypeCmd.Response_Achievement_Change_Cmd = BASE_CMD + 412
MsgTypeCmd.Request_Achievement_Reward_Cmd = BASE_CMD + 413
MsgTypeCmd.Response_Achievement_Reward_Cmd = BASE_CMD + 414
MsgTypeCmd.Request_AchievementRoad_Reward_Cmd = BASE_CMD + 415
MsgTypeCmd.Response_AchievementRoad_Reward_Cmd = BASE_CMD + 416
MsgTypeCmd.Request_Hero_Data_Cmd = BASE_CMD + 500
MsgTypeCmd.Response_Hero_Data_Cmd = BASE_CMD + 501
MsgTypeCmd.Request_Hero_FieldUnlock_Cmd = BASE_CMD + 502
MsgTypeCmd.Response_Hero_FieldUnlock_Cmd = BASE_CMD + 503
MsgTypeCmd.Request_Hero_BuyList_Cmd = BASE_CMD + 504
MsgTypeCmd.Response_Hero_BuyList_Cmd = BASE_CMD + 505
MsgTypeCmd.Request_Hero_BuyListRefresh_Cmd = BASE_CMD + 506
MsgTypeCmd.Response_Hero_BuyListRefresh_Cmd = BASE_CMD + 507
MsgTypeCmd.Request_Hero_Buy_Cmd = BASE_CMD + 508
MsgTypeCmd.Response_Hero_Buy_Cmd = BASE_CMD + 509
MsgTypeCmd.Request_Hero_Equip_Cmd = BASE_CMD + 510
MsgTypeCmd.Response_Hero_Equip_Cmd = BASE_CMD + 511
MsgTypeCmd.Request_Hero_WarriorRankUp_Cmd = BASE_CMD + 512
MsgTypeCmd.Response_Hero_WarriorRankUp_Cmd = BASE_CMD + 513
MsgTypeCmd.Request_Hero_Setting_Cmd = BASE_CMD + 514
MsgTypeCmd.Response_Hero_Setting_Cmd = BASE_CMD + 515
MsgTypeCmd.Request_Hero_Fire_Cmd = BASE_CMD + 516
MsgTypeCmd.Response_Hero_Fire_Cmd = BASE_CMD + 517
MsgTypeCmd.Request_Hero_Transfer_Cmd = BASE_CMD + 518
MsgTypeCmd.Response_Hero_Transfer_Cmd = BASE_CMD + 519
MsgTypeCmd.Request_Hero_DataRefresh_Cmd = BASE_CMD + 520
MsgTypeCmd.Response_Hero_DataRefresh_Cmd = BASE_CMD + 521
MsgTypeCmd.Request_Hero_Recover_Cmd = BASE_CMD + 522
MsgTypeCmd.Response_Hero_Recover_Cmd = BASE_CMD + 523
MsgTypeCmd.Request_Hero_FixBrokenEquip_Cmd = BASE_CMD + 524
MsgTypeCmd.Response_Hero_FixBrokenEquip_Cmd = BASE_CMD + 525
MsgTypeCmd.Request_Hero_EquipAuto_Cmd = BASE_CMD + 526
MsgTypeCmd.Response_Hero_EquipAuto_Cmd = BASE_CMD + 527
MsgTypeCmd.Response_Hero_Change_Cmd = BASE_CMD + 599
MsgTypeCmd.Request_Hero_ExchangeList_Cmd = BASE_CMD + 530
MsgTypeCmd.Response_Hero_ExchangeList_Cmd = BASE_CMD + 531
MsgTypeCmd.Request_Hero_Exchange_Cmd = BASE_CMD + 532
MsgTypeCmd.Response_Hero_Exchange_Cmd = BASE_CMD + 533
MsgTypeCmd.Response_Worker_MakeExp_Cmd = BASE_CMD + 600
MsgTypeCmd.Response_Hero_WorkerChange_Cmd = BASE_CMD + 601
MsgTypeCmd.Request_Hero_WorkerUnlock_Cmd = BASE_CMD + 600
MsgTypeCmd.Response_Hero_WorkerUnlock_Cmd = BASE_CMD + 601
MsgTypeCmd.Request_Shopper_Data_Cmd = BASE_CMD + 700
MsgTypeCmd.Response_Shopper_Data_Cmd = BASE_CMD + 701
MsgTypeCmd.Request_Shopper_Coming_Cmd = BASE_CMD + 702
MsgTypeCmd.Response_Shopper_Coming_Cmd = BASE_CMD + 703
MsgTypeCmd.Response_Shopper_Change_Cmd = BASE_CMD + 704
MsgTypeCmd.Request_Shopper_Chat_Cmd = BASE_CMD + 705
MsgTypeCmd.Response_Shopper_Chat_Cmd = BASE_CMD + 706
MsgTypeCmd.Request_Shopper_Discount_Cmd = BASE_CMD + 707
MsgTypeCmd.Response_Shopper_Discount_Cmd = BASE_CMD + 708
MsgTypeCmd.Request_Shopper_Double_Cmd = BASE_CMD + 709
MsgTypeCmd.Response_Shopper_Double_Cmd = BASE_CMD + 710
MsgTypeCmd.Request_Shopper_Refuse_Cmd = BASE_CMD + 711
MsgTypeCmd.Response_Shopper_Refuse_Cmd = BASE_CMD + 712
MsgTypeCmd.Request_Shopper_Checkout_Cmd = BASE_CMD + 713
MsgTypeCmd.Response_Shopper_Checkout_Cmd = BASE_CMD + 714
MsgTypeCmd.Request_Shopper_Recommend_Cmd = BASE_CMD + 715
MsgTypeCmd.Response_Shopper_Recommend_Cmd = BASE_CMD + 716
MsgTypeCmd.Request_Shopper_Queue_Cmd = BASE_CMD + 717
MsgTypeCmd.Response_Shopper_Queue_Cmd = BASE_CMD + 718
MsgTypeCmd.Request_Shopper_Energy_Cmd = BASE_CMD + 719
MsgTypeCmd.Response_Shopper_Energy_Cmd = BASE_CMD + 720
MsgTypeCmd.Request_PiggyBank_ClickData_Cmd = BASE_CMD + 800
MsgTypeCmd.Response_PiggyBank_BaseData_Cmd = BASE_CMD + 801
MsgTypeCmd.Request_PiggyBank_Props_Cmd = BASE_CMD + 802
MsgTypeCmd.Response_PiggyBank_Props_Cmd = BASE_CMD + 803
MsgTypeCmd.Request_Chat_Data_Cmd = BASE_CMD + 900
MsgTypeCmd.Response_Chat_Data_Cmd = BASE_CMD + 901
MsgTypeCmd.Request_Chat_Send_Cmd = BASE_CMD + 902
MsgTypeCmd.Response_Chat_Send_Cmd = BASE_CMD + 903
MsgTypeCmd.Request_Union_Data_Cmd = BASE_CMD + 950
MsgTypeCmd.Response_Union_Data_Cmd = BASE_CMD + 951
MsgTypeCmd.Request_Union_List_Cmd = BASE_CMD + 952
MsgTypeCmd.Response_Union_List_Cmd = BASE_CMD + 953
MsgTypeCmd.Request_Union_Create_Cmd = BASE_CMD + 954
MsgTypeCmd.Response_Union_Create_Cmd = BASE_CMD + 955
MsgTypeCmd.Request_Union_Enter_Cmd = BASE_CMD + 956
MsgTypeCmd.Response_Union_Enter_Cmd = BASE_CMD + 957
MsgTypeCmd.Request_Union_Leave_Cmd = BASE_CMD + 958
MsgTypeCmd.Response_Union_Leave_Cmd = BASE_CMD + 959
MsgTypeCmd.Request_Union_UserData_Cmd = BASE_CMD + 960
MsgTypeCmd.Response_Union_UserData_Cmd = BASE_CMD + 961
MsgTypeCmd.Request_Union_KickOut_Cmd = BASE_CMD + 962
MsgTypeCmd.Response_Union_KickOut_Cmd = BASE_CMD + 963
MsgTypeCmd.Request_Union_SetInfo_Cmd = BASE_CMD + 964
MsgTypeCmd.Response_Union_SetInfo_Cmd = BASE_CMD + 965
MsgTypeCmd.Request_Union_SetUserRole_Cmd = BASE_CMD + 966
MsgTypeCmd.Response_Union_SetUserRole_Cmd = BASE_CMD + 967
MsgTypeCmd.Request_Union_SearchUserData_Cmd = BASE_CMD + 968
MsgTypeCmd.Response_Union_SearchUserData_Cmd = BASE_CMD + 969
MsgTypeCmd.Response_Union_MessageInfo_Cmd = BASE_CMD + 970
MsgTypeCmd.Request_Union_MessageInfoRefresh_Cmd = BASE_CMD + 971
MsgTypeCmd.Response_Union_MessageInfoRefresh_Cmd = BASE_CMD + 972
MsgTypeCmd.Request_Union_MemberHelpList_Cmd = BASE_CMD + 973
MsgTypeCmd.Response_Union_MemberHelpList_Cmd = BASE_CMD + 974
MsgTypeCmd.Request_Union_SetHelp_Cmd = BASE_CMD + 975
MsgTypeCmd.Response_Union_SetHelp_Cmd = BASE_CMD + 976
MsgTypeCmd.Request_Union_HelpMember_Cmd = BASE_CMD + 977
MsgTypeCmd.Response_Union_HelpMember_Cmd = BASE_CMD + 978
MsgTypeCmd.Request_Union_TaskList_Cmd = BASE_CMD + 979
MsgTypeCmd.Response_Union_TaskList_Cmd = BASE_CMD + 980
MsgTypeCmd.Request_Union_StartUnionTask_Cmd = BASE_CMD + 981
MsgTypeCmd.Response_Union_StartUnionTask_Cmd = BASE_CMD + 982
MsgTypeCmd.Request_Union_CancelUnionTask_Cmd = BASE_CMD + 983
MsgTypeCmd.Response_Union_CancelUnionTask_Cmd = BASE_CMD + 984
MsgTypeCmd.Response_Union_UnionTaskChange_Cmd = BASE_CMD + 985
MsgTypeCmd.Request_Union_RewardUnionTask_Cmd = BASE_CMD + 986
MsgTypeCmd.Response_Union_RewardUnionTask_Cmd = BASE_CMD + 987
MsgTypeCmd.Request_Union_CheckUnionTask_Cmd = BASE_CMD + 988
MsgTypeCmd.Response_Union_CheckUnionTask_Cmd = BASE_CMD + 989
MsgTypeCmd.Request_Union_AccelUnionTask_Cmd = BASE_CMD + 990
MsgTypeCmd.Response_Union_AccelUnionTask_Cmd = BASE_CMD + 991
MsgTypeCmd.Request_Union_UnionTaskRankList_Cmd = BASE_CMD + 992
MsgTypeCmd.Response_Union_UnionTaskRankList_Cmd = BASE_CMD + 993
MsgTypeCmd.Request_Union_ScienceList_Cmd = BASE_CMD + 940
MsgTypeCmd.Response_Union_ScienceList_Cmd = BASE_CMD + 941
MsgTypeCmd.Request_Union_ScienceSkillList_Cmd = BASE_CMD + 942
MsgTypeCmd.Response_Union_ScienceSkillList_Cmd = BASE_CMD + 943
MsgTypeCmd.Request_Union_ScienceUpgrade_Cmd = BASE_CMD + 944
MsgTypeCmd.Response_Union_ScienceUpgrade_Cmd = BASE_CMD + 945
MsgTypeCmd.Request_Union_ScienceSkillUse_Cmd = BASE_CMD + 946
MsgTypeCmd.Response_Union_ScienceSkillUse_Cmd = BASE_CMD + 947
MsgTypeCmd.Request_Union_ScienceSkillRefresh_Cmd = BASE_CMD + 948
MsgTypeCmd.Response_Union_ScienceSkillRefresh_Cmd = BASE_CMD + 949
MsgTypeCmd.Request_Union_TaskResult_Cmd = BASE_CMD + 930
MsgTypeCmd.Response_Union_TaskResult_Cmd = BASE_CMD + 931
MsgTypeCmd.Request_Union_KickOutMessage_Cmd = BASE_CMD + 932
MsgTypeCmd.Response_Union_KickOutMessage_Cmd = BASE_CMD + 933
MsgTypeCmd.Request_Union_Impeach_Cmd = BASE_CMD + 934
MsgTypeCmd.Response_Union_Impeach_Cmd = BASE_CMD + 935
MsgTypeCmd.Request_Market_BoothCount_Cmd = BASE_CMD + 1000
MsgTypeCmd.Response_Market_BoothCount_Cmd = BASE_CMD + 1001
MsgTypeCmd.Request_Market_BoothData_Cmd = BASE_CMD + 1002
MsgTypeCmd.Response_Market_BoothData_Cmd = BASE_CMD + 1003
MsgTypeCmd.Request_Market_ListedItems_Cmd = BASE_CMD +1004
MsgTypeCmd.Request_Market_DealWith_Cmd = BASE_CMD + 1006
MsgTypeCmd.Request_Market_OffShelf_Cmd = BASE_CMD + 1008
MsgTypeCmd.Request_Market_OneItemList_Cmd = BASE_CMD + 1010
MsgTypeCmd.Response_Market_OneItemList_Cmd = BASE_CMD + 1011
MsgTypeCmd.Request_Market_OneItemRef_Cmd = BASE_CMD + 1012
MsgTypeCmd.Response_Market_OneItemRef_Cmd = BASE_CMD + 1013
MsgTypeCmd.Request_Market_BuyOrSellOne_Cmd = BASE_CMD + 1014
MsgTypeCmd.Response_Market_BuyOrSellOne_Cmd = BASE_CMD + 1015
MsgTypeCmd.Request_Market_UpdatePut_Cmd = BASE_CMD + 1016
MsgTypeCmd.Request_Design_Data_Cmd = BASE_CMD + 1110
MsgTypeCmd.Response_Design_Data_Cmd = BASE_CMD + 1111
MsgTypeCmd.Request_Design_ShopUpgrade_Cmd = BASE_CMD + 1112
MsgTypeCmd.Response_Design_ShopUpgrade_Cmd = BASE_CMD + 1113
MsgTypeCmd.Request_Design_ShopRefresh_Cmd = BASE_CMD + 1114
MsgTypeCmd.Response_Design_ShopRefresh_Cmd = BASE_CMD + 1115
MsgTypeCmd.Request_Design_ShopFinish_Cmd = BASE_CMD + 1116
MsgTypeCmd.Response_Design_ShopFinish_Cmd = BASE_CMD + 1117
MsgTypeCmd.Request_Design_ShopImmediately_Cmd = BASE_CMD + 1118
MsgTypeCmd.Response_Design_ShopImmediately_Cmd = BASE_CMD + 1119
MsgTypeCmd.Request_Design_Buy_Cmd = BASE_CMD + 1120
MsgTypeCmd.Response_Design_Buy_Cmd = BASE_CMD + 1121
MsgTypeCmd.Request_Design_Move_Cmd = BASE_CMD + 1122
MsgTypeCmd.Response_Design_Move_Cmd = BASE_CMD + 1123
MsgTypeCmd.Request_Design_Upgrade_Cmd = BASE_CMD + 1124
MsgTypeCmd.Response_Design_Upgrade_Cmd = BASE_CMD + 1125
MsgTypeCmd.Request_Design_Refresh_Cmd = BASE_CMD + 1126
MsgTypeCmd.Response_Design_Refresh_Cmd = BASE_CMD + 1127
MsgTypeCmd.Request_Design_Finish_Cmd = BASE_CMD + 1128
MsgTypeCmd.Response_Design_Finish_Cmd = BASE_CMD + 1129
MsgTypeCmd.Request_Design_Immediately_Cmd = BASE_CMD + 1130
MsgTypeCmd.Response_Design_Immediately_Cmd = BASE_CMD + 1131
MsgTypeCmd.Request_Design_InStore_Cmd = BASE_CMD + 1132
MsgTypeCmd.Response_Design_InStore_Cmd = BASE_CMD + 1133
MsgTypeCmd.Request_Design_SetFloor_Cmd = BASE_CMD + 1134
MsgTypeCmd.Response_Design_SetFloor_Cmd = BASE_CMD + 1135
MsgTypeCmd.Request_Design_SetWall_Cmd = BASE_CMD + 1136
MsgTypeCmd.Response_Design_SetWall_Cmd = BASE_CMD + 1137
MsgTypeCmd.Response_Design_CounterChange_Cmd = BASE_CMD + 1138
MsgTypeCmd.Response_Design_FloorChange_Cmd = BASE_CMD + 1139
MsgTypeCmd.Response_Design_StoreBasketChange_Cmd = BASE_CMD + 1140
MsgTypeCmd.Response_Design_ResBasketChange_Cmd = BASE_CMD + 1141
MsgTypeCmd.Response_Design_ShelfChange_Cmd = BASE_CMD + 1142
MsgTypeCmd.Response_Design_FurnitureChange_Cmd = BASE_CMD + 1143
MsgTypeCmd.Request_Design_OnShelf_Cmd = BASE_CMD + 1144
MsgTypeCmd.Response_Design_OnShelf_Cmd = BASE_CMD + 1145
MsgTypeCmd.Request_Design_OffShelf_Cmd = BASE_CMD + 1146
MsgTypeCmd.Response_Design_OffShelf_Cmd = BASE_CMD + 1147
MsgTypeCmd.Response_Design_ShelfEquipChange_Cmd = BASE_CMD + 1148
MsgTypeCmd.Request_Hero_UseItem_Cmd = BASE_CMD + 1201
MsgTypeCmd.Response_Hero_UseItem_Cmd = BASE_CMD + 1202
MsgTypeCmd.Request_Hero_UseHeroStatusItem_Cmd = BASE_CMD + 1203
MsgTypeCmd.Response_Hero_UseHeroStatusItem_Cmd = BASE_CMD + 1204
MsgTypeCmd.Request_Hero_UseEquipItem_Cmd = BASE_CMD + 1205
MsgTypeCmd.Response_Hero_UseEquipItem_Cmd = BASE_CMD + 1206
MsgTypeCmd.Request_City_BuildData_Cmd = BASE_CMD + 1301
MsgTypeCmd.Response_City_BuildData_Cmd = BASE_CMD + 1302
MsgTypeCmd.Request_City_BuildCost_Cmd = BASE_CMD + 1303
MsgTypeCmd.Response_City_BuildDataChanged_Cmd = BASE_CMD + 1304
MsgTypeCmd.Request_City_BuildingRankData_Cmd = BASE_CMD + 1305
MsgTypeCmd.Response_City_BuildingRankData_Cmd = BASE_CMD + 1306
MsgTypeCmd.Request_Explore_BuySlot_Cmd = BASE_CMD + 1400
MsgTypeCmd.Response_Explore_BuySlot_Cmd = BASE_CMD + 1401
MsgTypeCmd.Request_Explore_Data_Cmd = BASE_CMD + 1402
MsgTypeCmd.Response_Explore_Data_Cmd = BASE_CMD + 1403
MsgTypeCmd.Request_Explore_Start_Cmd = BASE_CMD + 1404
MsgTypeCmd.Response_Explore_Start_Cmd = BASE_CMD + 1405
MsgTypeCmd.Request_Explore_End_Cmd = BASE_CMD + 1406
MsgTypeCmd.Response_Explore_End_Cmd = BASE_CMD + 1407
MsgTypeCmd.Request_Explore_Unlock_Cmd = BASE_CMD + 1408
MsgTypeCmd.Response_Explore_Unlock_Cmd = BASE_CMD + 1409
MsgTypeCmd.Request_ExploreSlot_Data_Cmd = BASE_CMD + 1410
MsgTypeCmd.Response_ExploreSlot_Data_Cmd = BASE_CMD + 1411
MsgTypeCmd.Request_Explore_Refresh_Cmd = BASE_CMD + 1412
MsgTypeCmd.Response_Explore_Refresh_Cmd = BASE_CMD + 1413
MsgTypeCmd.Request_Explore_Immediately_Cmd = BASE_CMD + 1414
MsgTypeCmd.Response_Explore_Immediately_Cmd = BASE_CMD + 1415
MsgTypeCmd.Request_Explore_RewardVip_Cmd = BASE_CMD + 1416
MsgTypeCmd.Response_Explore_RewardVip_Cmd = BASE_CMD + 1417
MsgTypeCmd.Request_TreasureBox_Data_Cmd = BASE_CMD + 1500
MsgTypeCmd.Response_TreasureBox_Data_Cmd = BASE_CMD + 1501
MsgTypeCmd.Request_TreasureBox_Open_Cmd = BASE_CMD + 1502
MsgTypeCmd.Response_TreasureBox_Open_Cmd = BASE_CMD + 1503
MsgTypeCmd.Request_Mail_List_Cmd = BASE_CMD + 1600
MsgTypeCmd.Response_Mail_List_Cmd = BASE_CMD + 1601
MsgTypeCmd.Request_Mail_Read_Cmd = BASE_CMD + 1602
MsgTypeCmd.Response_Mail_Read_Cmd = BASE_CMD + 1603
MsgTypeCmd.Request_Mail_Claimed_Cmd = BASE_CMD + 1604
MsgTypeCmd.Response_Mail_Claimed_Cmd = BASE_CMD + 1605
MsgTypeCmd.Request_Mail_Delete_Cmd = BASE_CMD + 1606
MsgTypeCmd.Response_Mail_Delete_Cmd = BASE_CMD + 1607
MsgTypeCmd.Request_Mail_Feedback_Cmd = BASE_CMD + 1608
MsgTypeCmd.Response_Mail_Feedback_Cmd = BASE_CMD + 1609
MsgTypeCmd.Request_Activity_List_Cmd = BASE_CMD + 1700
MsgTypeCmd.Response_Activity_List_Cmd = BASE_CMD + 1701
MsgTypeCmd.Request_Activity_DailyGiftReward_Cmd = BASE_CMD + 1702
MsgTypeCmd.Response_Activity_DailyGiftReward_Cmd = BASE_CMD + 1703
MsgTypeCmd.Request_Activity_SevenDayCheck_Cmd = BASE_CMD + 1704
MsgTypeCmd.Response_Activity_SevenDayCheck_Cmd = BASE_CMD + 1705
MsgTypeCmd.Request_Activity_SevenDayReward_Cmd = BASE_CMD + 1706
MsgTypeCmd.Response_Activity_SevenDayReward_Cmd = BASE_CMD + 1707
MsgTypeCmd.Request_Activity_SevenDayListReward_Cmd = BASE_CMD + 1708
MsgTypeCmd.Response_Activity_SevenDayListReward_Cmd = BASE_CMD + 1709
MsgTypeCmd.Response_Activity_SevenDayChange_Cmd = BASE_CMD + 1710
MsgTypeCmd.Response_Activity_SevenDayListChange_Cmd = BASE_CMD + 1711
MsgTypeCmd.Response_Activity_Buff_Info_Cmd = BASE_CMD + 1712
MsgTypeCmd.Request_Activity_Buff_Refresh_Cmd = BASE_CMD + 1713
MsgTypeCmd.Response_Activity_Buff_Refresh_Cmd = BASE_CMD + 1714
MsgTypeCmd.Request_Activity_Buff_Update_Cmd = BASE_CMD + 1715
MsgTypeCmd.Response_Activity_Buff_Update_Cmd = BASE_CMD + 1716
MsgTypeCmd.Request_Activity_Data_Cmd = BASE_CMD + 1717
MsgTypeCmd.Response_Activity_Data_Cmd = BASE_CMD + 1718
MsgTypeCmd.Request_Activity_Battle_Cmd = BASE_CMD + 1719
MsgTypeCmd.Response_Activity_Battle_Cmd = BASE_CMD + 1720
MsgTypeCmd.Request_Jackpot_Data_Cmd = BASE_CMD + 1800
MsgTypeCmd.Response_Jackpot_Data_Cmd = BASE_CMD + 1801
MsgTypeCmd.Request_Jackpot_Refresh_Cmd = BASE_CMD + 1802
MsgTypeCmd.Response_Jackpot_Refresh_Cmd = BASE_CMD + 1803
MsgTypeCmd.Request_User_Lottery_Cmd = BASE_CMD + 1804
MsgTypeCmd.Response_User_Lottery_Cmd = BASE_CMD + 1805
MsgTypeCmd.Request_User_LotteryTenth_Cmd = BASE_CMD + 1806
MsgTypeCmd.Response_User_LotteryTenth_Cmd = BASE_CMD + 1807
MsgTypeCmd.Request_Cumulative_Reward_Cmd = BASE_CMD + 1808
MsgTypeCmd.Response_Cumulative_Reward_Cmd = BASE_CMD + 1809
MsgTypeCmd.Response_Roulette_Recording_Cmd = BASE_CMD + 1810
MsgTypeCmd.Request_Prize_Free_Cmd = BASE_CMD + 1811
MsgTypeCmd.Response_Prize_Free_Cmd = BASE_CMD + 1812
MsgTypeCmd.Response_Rubbish_List_Cmd = BASE_CMD + 1900
MsgTypeCmd.Request_Rubbish_Refresh_Cmd = BASE_CMD + 1901
MsgTypeCmd.Response_Rubbish_Refresh_Cmd = BASE_CMD + 1901
MsgTypeCmd.Request_Rubbish_Claimed_Cmd = BASE_CMD + 1902
MsgTypeCmd.Response_Rubbish_Claimed_Cmd = BASE_CMD + 1903
MsgTypeCmd.Request_Pay_Order_Cmd = BASE_CMD + 2000
MsgTypeCmd.Response_Pay_Order_Cmd = BASE_CMD + 2001
MsgTypeCmd.Request_Pay_Balance_Cmd = BASE_CMD + 2002
MsgTypeCmd.Response_Pay_Balance_Cmd = BASE_CMD + 2003
MsgTypeCmd.Request_Pay_StoreList_Cmd = BASE_CMD + 2004
MsgTypeCmd.Response_Pay_StoreList_Cmd = BASE_CMD + 2005
MsgTypeCmd.Request_Pay_StoreRefresh_Cmd = BASE_CMD + 2006
MsgTypeCmd.Response_Pay_StoreRefresh_Cmd = BASE_CMD + 2007
MsgTypeCmd.Request_Pay_StoreBuy_Cmd = BASE_CMD + 2008
MsgTypeCmd.Response_Pay_StoreBuy_Cmd = BASE_CMD + 2009
MsgTypeCmd.Request_Pay_BuyVIP_Cmd = BASE_CMD + 2010
MsgTypeCmd.Response_Pay_BuyVIP_Cmd = BASE_CMD + 2011
MsgTypeCmd.Response_Pay_VIPChange_Cmd = BASE_CMD + 2012
MsgTypeCmd.Request_Pay_GeneralPurchase_Cmd = BASE_CMD + 2013
MsgTypeCmd.Response_Pay_GeneralPurchase_Cmd = BASE_CMD + 2014
MsgTypeCmd.Request_Pay_DailySale_Cmd = BASE_CMD + 2015
MsgTypeCmd.Response_Pay_DailySale_Cmd = BASE_CMD + 2016
MsgTypeCmd.Request_Pay_DirectPurchase_Cmd = BASE_CMD + 2017
MsgTypeCmd.Response_Pay_DirectPurchase_Cmd = BASE_CMD + 2018
MsgTypeCmd.Request_Pay_ShopperLevelPurchase_Cmd = BASE_CMD + 2019
MsgTypeCmd.Response_Pay_ShopperLevelPurchase_Cmd = BASE_CMD + 2020
MsgTypeCmd.Request_Pay_IOSBuy_Cmd = BASE_CMD + 2021
MsgTypeCmd.Response_Pay_IOSBuy_Cmd = BASE_CMD + 2022
MsgTypeCmd.Request_Pay_AmountCheck_Cmd = BASE_CMD + 2023
MsgTypeCmd.Response_Pay_AmountCheck_Cmd = BASE_CMD + 2024
MsgTypeCmd.Request_Pay_AmountReward_Cmd = BASE_CMD + 2025
MsgTypeCmd.Response_Pay_AmountReward_Cmd = BASE_CMD + 2026
MsgTypeCmd.Request_Pay_OrderCancel_Cmd = BASE_CMD + 2027
MsgTypeCmd.Response_Pay_OrderCancel_Cmd = BASE_CMD + 2028
MsgTypeCmd.Request_Pay_GoldVip_Cmd = BASE_CMD + 2029
MsgTypeCmd.Response_Pay_GoldVip_Cmd = BASE_CMD + 2030
MsgTypeCmd.Request_Pay_GoldVipReward_Cmd = BASE_CMD + 2031
MsgTypeCmd.Response_Pay_GoldVipReward_Cmd = BASE_CMD + 2032
MsgTypeCmd.Request_Pay_PointActivityPurchase_Cmd = BASE_CMD + 2033
MsgTypeCmd.Response_Pay_PointActivityPurchase_Cmd = BASE_CMD + 2034
MsgTypeCmd.Request_OperatingActivity_Check_Cmd = BASE_CMD + 2100
MsgTypeCmd.Response_OperatingActivity_Check_Cmd = BASE_CMD + 2101
MsgTypeCmd.Request_OperatingActivity_CheckReward_Cmd = BASE_CMD + 2102
MsgTypeCmd.Response_OperatingActivity_CheckReward_Cmd = BASE_CMD + 2103
MsgTypeCmd.Request_OperatingActivity_CheckExchange_Cmd = BASE_CMD + 2104
MsgTypeCmd.Response_OperatingActivity_CheckExchange_Cmd = BASE_CMD + 2105
MsgTypeCmd.Request_OperatingActivity_Reward_Cmd = BASE_CMD + 2106
MsgTypeCmd.Response_OperatingActivity_Reward_Cmd = BASE_CMD + 2107
MsgTypeCmd.Request_OperatingActivity_Exchange_Cmd = BASE_CMD + 2108
MsgTypeCmd.Response_OperatingActivity_Exchange_Cmd = BASE_CMD + 2109
MsgTypeCmd.Request_OperatingActivity_UpdateInfo_Cmd = BASE_CMD + 2110
MsgTypeCmd.Response_OperatingActivity_UpdateInfo_Cmd = BASE_CMD + 2111
MsgTypeCmd.Request_OperatingActivity_UpdateExchange_Cmd = BASE_CMD + 2112
MsgTypeCmd.Response_OperatingActivity_UpdateExchange_Cmd = BASE_CMD + 2113
MsgTypeCmd.Response_OperatingActivity_EquipMakeInfo_Cmd = BASE_CMD + 2114
MsgTypeCmd.Request_OperatingActivity_DataCheck_Cmd = BASE_CMD + 2115
MsgTypeCmd.Response_OperatingActivity_DataCheck_Cmd = BASE_CMD + 2116
MsgTypeCmd.Response_OperatingActivity_ActivityPointChange_Cmd = BASE_CMD + 2117
MsgTypeCmd.Response_OperatingActivity_CoinChange_Cmd = BASE_CMD + 2118
MsgTypeCmd.Response_OperatingActivity_RewardChange_Cmd = BASE_CMD + 2119
MsgTypeCmd.Request_OperatingActivity_DailyCoin_Cmd = BASE_CMD + 2120
MsgTypeCmd.Response_OperatingActivity_DailyCoin_Cmd = BASE_CMD + 2121
MsgTypeCmd.Request_Pay_OperatingActivityPurchase_Cmd = BASE_CMD + 2122
MsgTypeCmd.Response_Pay_OperatingActivityPurchase_Cmd = BASE_CMD + 2123
MsgTypeCmd.Request_OperatingActivity_UnionRankList_Cmd = BASE_CMD + 2124
MsgTypeCmd.Response_OperatingActivity_UnionRankList_Cmd = BASE_CMD + 2125
MsgTypeCmd.Request_OperatingActivity2_DataCheck_Cmd = BASE_CMD + 2126
MsgTypeCmd.Response_OperatingActivity2_DataCheck_Cmd = BASE_CMD + 2127
MsgTypeCmd.Request_OperatingActivity2_CheckReward_Cmd = BASE_CMD + 2128
MsgTypeCmd.Response_OperatingActivity2_CheckReward_Cmd = BASE_CMD + 2129
MsgTypeCmd.Request_OperatingActivity2_Reward_Cmd = BASE_CMD + 2130
MsgTypeCmd.Response_OperatingActivity2_Reward_Cmd = BASE_CMD + 2131
MsgTypeCmd.Response_OperatingActivity2_ActivityPointChange_Cmd = BASE_CMD + 2132
MsgTypeCmd.Response_OperatingActivity2_RewardChange_Cmd = BASE_CMD + 2133
MsgTypeCmd.Request_OperatingActivity2_DailyReward_Cmd = BASE_CMD + 2134
MsgTypeCmd.Response_OperatingActivity2_DailyReward_Cmd = BASE_CMD + 2135
MsgTypeCmd.Request_OperatingActivity2_UnionRankList_Cmd = BASE_CMD + 2136
MsgTypeCmd.Response_OperatingActivity2_UnionRankList_Cmd = BASE_CMD + 2137
MsgTypeCmd.Request_OperatingActivity2_ExploreStart_Cmd = BASE_CMD + 2138
MsgTypeCmd.Response_OperatingActivity2_ExploreStart_Cmd = BASE_CMD + 2139
MsgTypeCmd.Request_OperatingActivity2_ExploreEnd_Cmd = BASE_CMD + 2140
MsgTypeCmd.Response_OperatingActivity2_ExploreEnd_Cmd = BASE_CMD + 2141
MsgTypeCmd.Request_OperatingActivity2_ExploreImmediately_Cmd = BASE_CMD + 2142
MsgTypeCmd.Response_OperatingActivity2_ExploreImmediately_Cmd = BASE_CMD + 2143
MsgTypeCmd.Request_User_GuideTask_Cmd = BASE_CMD + 2200
MsgTypeCmd.Response_User_GuideTask_Cmd = BASE_CMD + 2201
MsgTypeCmd.Response_User_GuideTaskChange_Cmd = BASE_CMD + 2202
MsgTypeCmd.Request_User_GuideTaskReward_Cmd = BASE_CMD + 2203
MsgTypeCmd.Response_User_GuideTaskReward_Cmd = BASE_CMD + 2204
MsgTypeCmd.Request_AD_Start_Cmd = BASE_CMD + 2300
MsgTypeCmd.Response_AD_Start_Cmd = BASE_CMD + 2301
MsgTypeCmd.Request_AD_End_Cmd = BASE_CMD + 2302
MsgTypeCmd.Response_AD_End_Cmd = BASE_CMD + 2303
MsgTypeCmd.Request_AD_UserData_Cmd = BASE_CMD + 2304
MsgTypeCmd.Response_AD_UserData_Cmd = BASE_CMD + 2305
MsgTypeCmd.Request_User_OnlineRewardList_Cmd = BASE_CMD + 2400
MsgTypeCmd.Response_User_OnlineRewardList_Cmd = BASE_CMD + 2401
MsgTypeCmd.Request_User_OnlineRewardListReward_Cmd = BASE_CMD + 2402
MsgTypeCmd.Response_User_OnlineRewardListReward_Cmd = BASE_CMD + 2403
MsgTypeCmd.Request_Tower_Info_Cmd = BASE_CMD + 2500
MsgTypeCmd.Response_Tower_Info_Cmd = BASE_CMD + 2501
MsgTypeCmd.Request_Tower_ExploreStart_Cmd = BASE_CMD + 2502
MsgTypeCmd.Response_Tower_ExploreStart_Cmd = BASE_CMD + 2503
MsgTypeCmd.Request_Tower_ExploreEnd_Cmd = BASE_CMD + 2504
MsgTypeCmd.Response_Tower_ExploreEnd_Cmd = BASE_CMD + 2505
MsgTypeCmd.Request_Tower_ExploreImmediately_Cmd = BASE_CMD + 2506
MsgTypeCmd.Response_Tower_ExploreImmediately_Cmd = BASE_CMD + 2507
MsgTypeCmd.Request_Tower_Reward_Cmd = BASE_CMD + 2508
MsgTypeCmd.Response_Tower_Reward_Cmd = BASE_CMD + 2509
MsgTypeCmd.Request_PointActivity_CheckData_Cmd = BASE_CMD + 2600
MsgTypeCmd.Response_PointActivity_CheckData_Cmd = BASE_CMD + 2601
MsgTypeCmd.Request_PointActivity_Reward_Cmd = BASE_CMD + 2602
MsgTypeCmd.Response_PointActivity_Reward_Cmd = BASE_CMD + 2603
MsgTypeCmd.Request_PointActivity_Exchange_Cmd = BASE_CMD + 2604
MsgTypeCmd.Response_PointActivity_Exchange_Cmd = BASE_CMD + 2605
MsgTypeCmd.Response_PointActivity_TaskChange_Cmd = BASE_CMD + 2606
MsgTypeCmd.Request_PointActivity_CheckExchange_Cmd = BASE_CMD + 2607
MsgTypeCmd.Response_PointActivity_CheckExchange_Cmd = BASE_CMD + 2608
MsgTypeCmd.Request_PointActivity_CheckExchange2_Cmd = BASE_CMD + 2609
MsgTypeCmd.Response_PointActivity_CheckExchange2_Cmd = BASE_CMD + 2610
MsgTypeCmd.Request_PointActivity2_CheckData_Cmd = BASE_CMD + 2650
MsgTypeCmd.Response_PointActivity2_CheckData_Cmd = BASE_CMD + 2651
MsgTypeCmd.Response_PointActivity2_TaskChange_Cmd = BASE_CMD + 2652
MsgTypeCmd.Request_PointActivity2_TaskReward_Cmd = BASE_CMD + 2653
MsgTypeCmd.Response_PointActivity2_TaskReward_Cmd = BASE_CMD + 2654
MsgTypeCmd.Request_PointActivity2_CheckReward_Cmd = BASE_CMD + 2655
MsgTypeCmd.Response_PointActivity2_CheckReward_Cmd = BASE_CMD + 2656
MsgTypeCmd.Request_PointActivity2_Reward_Cmd = BASE_CMD + 2657
MsgTypeCmd.Response_PointActivity2_Reward_Cmd = BASE_CMD + 2658
MsgTypeCmd.Response_PointActivity2_RewardChange_Cmd = BASE_CMD + 2659
MsgTypeCmd.Response_PointActivity2_ActivityPointChange_Cmd = BASE_CMD + 2660
MsgTypeCmd.Request_PointActivity2_UnionRankList_Cmd = BASE_CMD + 2661
MsgTypeCmd.Response_PointActivity2_UnionRankList_Cmd = BASE_CMD + 2662
MsgTypeCmd.Request_Dragon_CheckData_Cmd = BASE_CMD + 2700
MsgTypeCmd.Response_Dragon_CheckData_Cmd = BASE_CMD + 2701
MsgTypeCmd.Request_Dragon_CheckReward_Cmd = BASE_CMD + 2702
MsgTypeCmd.Response_Dragon_CheckReward_Cmd = BASE_CMD + 2703
MsgTypeCmd.Response_Dragon_StageChange_Cmd = BASE_CMD + 2704
MsgTypeCmd.Response_Dragon_PointChange_Cmd = BASE_CMD + 2705
MsgTypeCmd.Request_Dragon_Reward_Cmd = BASE_CMD + 2706
MsgTypeCmd.Response_Dragon_Reward_Cmd = BASE_CMD + 2707
MsgTypeCmd.Response_Dragon_RewardChange_Cmd = BASE_CMD + 2708
MsgTypeCmd.Request_Dragon_SetHero_Cmd = BASE_CMD + 2709
MsgTypeCmd.Response_Dragon_SetHero_Cmd = BASE_CMD + 2710
MsgTypeCmd.Request_Dragon_SetEquip_Cmd = BASE_CMD + 2711
MsgTypeCmd.Response_Dragon_SetEquip_Cmd = BASE_CMD + 2712
MsgTypeCmd.Request_Dragon_SetItem_Cmd = BASE_CMD + 2713
MsgTypeCmd.Response_Dragon_SetItem_Cmd = BASE_CMD + 2714

MsgType.EErrorCode = {
    EEC_Success = 0,
    EEC_AppVersionUpdated = 101,
    EEC_ResVersionUpdated = 102,
    EEC_DuplicateLogin = 103,
    EEC_BanLogin = 104,
    EEC_BanChat = 105,
    EEC_ServerMaintain = 106,
    EEC_BindingFail = 201,
    EEC_PayNotOpen = 202,
    EEC_TransactionNotOpen = 203,
    EEC_NetworkError = 10000,
    EEC_NeedReLogin = 10001,
    EEC_Union_HaveNoUnionData = 10002,
    EEC_Union_NoMemberLimitData = 10003,
    EEC_Union_ReachedMemberLimit = 10004,
    EEC_Union_IsDeleted = 10005,
    EEC_Union_CantEnterUnion = 10006,
    EEC_Union_LevelLimit = 10007,
    EEC_Union_NoUnionName = 10008,
    EEC_Union_NextUnionId = 10009,
    EEC_Union_UnionNameExisted = 10010,
    EEC_Union_SettingPersonal = 10011,
    EEC_Union_Other = 10012,
    EEC_Union_AlreadyImpeach = 10013,
    EEC_Union_ImpeachNotEnough = 10014,
    EEC_Union_ImpeachFail = 10015,
    EEC_Union_InvestLimit = 10016,
    EEC_TriggerGuide_FurnitureUpgrade = 11001,
    EEC_ExchangeCodeReward_Failed = 12001,
    EEC_ExchangeCodeReward_CodeUsed = 12002,
    EEC_ExchangeCodeReward_Rewarded = 12003,
    EEC_ExchangeCodeReward_TimeOut = 12004,
    EEC_ExchangeCodeReward_NotTime = 12005,
    EEC_Worker_UnlockFailed = 13001,
    EEC_OperatingActivity_DataError = 20000,
    EEC_OperatingActivity_Over = 20001,
    EEC_OperatingActivity_RewardOver = 20002,
    EEC_OperatingActivity_RewardNotEnoughPoint = 20003,
    EEC_OperatingActivity_Rewarded = 20004,
    EEC_OperatingActivity_NotCanReward = 20005,
    EEC_OperatingActivity_ExchangeOver = 20006,
    EEC_OperatingActivity_ExchangeNotEnoughCoin = 20007,
    EEC_OperatingActivity_ExchangeRefreshNotEnoughCoin = 20008,
    EEC_OperatingActivity_UserRewardNotEnoughPoint = 20009,
    EEC_Activity_ExpeditionError = 30000,
    EEC_GoldCastle_DataError = 40000,
    EEC_GoldCastle_Over = 40001,
    EEC_GoldCastle_RewardOver = 40002,
    EEC_GoldCastle_RewardNotEnoughPoint = 40003,
    EEC_GoldCastle_Rewarded = 40004,
    EEC_GoldCastle_NotCanReward = 40005,
    EEC_GoldCastle_UserRewardNotEnoughPoint = 40006,
    EEC_PointActivity_DataError = 50000,
    EEC_PointActivity_Over = 50001,
    EEC_PointActivity_RewardOver = 50002,
    EEC_PointActivity_Rewarded = 50003,
    EEC_PointActivity_NotCanReward = 50004,
    EEC_PointActivity_UserRewardNotEnoughPoint = 50005,
    EEC_PointActivity_ExchangeOver = 50006,
    EEC_PointActivity_ExchangeNotEnoughCoin = 50007,
    EEC_PointActivity2_DataError = 51000,
    EEC_PointActivity2_Over = 51001,
    EEC_PointActivity2_RewardOver = 51002,
    EEC_PointActivity2_RewardNotEnoughPoint = 51003,
    EEC_PointActivity2_Rewarded = 51004,
    EEC_PointActivity2_NotCanReward = 51005,
    EEC_PointActivity2_UserRewardNotEnoughPoint = 51006,
    EEC_PointActivity2_ExchangeOver = 51006,
    EEC_PointActivity2_ExchangeNotEnoughCoin = 51007
}

MsgType.VIPInfo = {
    level = 0,
    state = 0,
    type = 0,
    endTime = 0,
    remainTime = 0
}
MsgType.VIPInfo.__index = MsgType.VIPInfo

function MsgType.VIPInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.VIPInfo:Encode()
    local tb = {}
    if nil ~= self.level and 0 ~= self.level then
        tb.b = self.level
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.c = self.state
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.d = self.type
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.e = self.endTime
    end
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.f = self.remainTime
    end
    return tb
end

function MsgType.VIPInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.level = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.state = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.type = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.endTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.remainTime = tonumber(data.f) or 0
    end
    return self
end

function MsgType.VIPInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.VIPInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.EOsType = {
    None = 0,
    Android = 1,
    Ios = 2
}

MsgType.EPlatform = {
    Test = 0,
    Google = 1,
    Ios = 2,
    QuickAndroid = 3,
    QuickIos = 4
}

MsgType.EPlatform2OsType = {
    Platform2OsType_0 = 0,
    Platform2OsType_1 = 1,
    Platform2OsType_2 = 2,
    Platform2OsType_3 = 1,
    Platform2OsType_4 = 2
}

MsgType.EBindingType = {
    None = 0,
    Google = 1,
    GameCenter = 2
}

MsgType.EGender = {
    Male = 1,
    Female = 2
}

MsgType.ELangType = {
    Cn = 0,
    Tc = 1,
    En = 2,
    Min = 0,
    Max = 2
}

MsgType.EGoldOrGem = {
    None = 0,
    Item1 = 1,
    Gold = 10001,
    Gem = 10002
}

MsgType.EUnionJob = {
    Common = 0,
    Manager = 1,
    President = 8
}

MsgType.EUnionEnter = {
    Public = 0,
    Personal = 1
}

MsgType.EMarketBuybackTrigger = {
    TriggerOFF = 0,
    TriggerON = 1
}

MsgType.EMarketBuybackGroupType = {
    Equip = 1,
    Item = 2
}

MsgType.EMarketBuybackSubType = {
    Equip_N = 1,
    Equip_R = 2,
    Equip_SR = 3,
    Equip_SSR = 4,
    Equip_Legend = 5,
    Item_Resource = 6,
    Item_Box = 8
}

MsgType.RoleDress = {
    modelColor = 0,
    face = 0,
    faceColor = 0,
    hair = 0,
    hairColor = 0,
    eyesColor = 0,
    weapon = 0,
    upper = 0,
    lower = 0,
    shoes = 0,
    headHat = 0
}
MsgType.RoleDress.__index = MsgType.RoleDress

function MsgType.RoleDress:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.RoleDress:Encode()
    local tb = {}
    if nil ~= self.modelColor and 0 ~= self.modelColor then
        tb.b = self.modelColor
    end
    if nil ~= self.face and 0 ~= self.face then
        tb.c = self.face
    end
    if nil ~= self.faceColor and 0 ~= self.faceColor then
        tb.d = self.faceColor
    end
    if nil ~= self.hair and 0 ~= self.hair then
        tb.e = self.hair
    end
    if nil ~= self.hairColor and 0 ~= self.hairColor then
        tb.f = self.hairColor
    end
    if nil ~= self.eyesColor and 0 ~= self.eyesColor then
        tb.g = self.eyesColor
    end
    if nil ~= self.weapon and 0 ~= self.weapon then
        tb.h = self.weapon
    end
    if nil ~= self.upper and 0 ~= self.upper then
        tb.i = self.upper
    end
    if nil ~= self.lower and 0 ~= self.lower then
        tb.j = self.lower
    end
    if nil ~= self.shoes and 0 ~= self.shoes then
        tb.k = self.shoes
    end
    if nil ~= self.headHat and 0 ~= self.headHat then
        tb.l = self.headHat
    end
    return tb
end

function MsgType.RoleDress:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.modelColor = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.face = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.faceColor = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.hair = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.hairColor = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.eyesColor = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.weapon = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.upper = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.lower = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.shoes = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.headHat = tonumber(data.l) or 0
    end
    return self
end

function MsgType.RoleDress:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.RoleDress:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.UnionMember = {
    userId = "",
    nickName = "",
    gender = 0, --enum EGender
    memberJob = 0, --enum EUnionJob
    worth = 0,
    invest = 0,
    level = 0,
    roleDress = {}
}
MsgType.UnionMember.__index = MsgType.UnionMember
setmetatable(MsgType.UnionMember.roleDress, MsgType.RoleDress)

function MsgType.UnionMember:New()
    local tb = {}
    setmetatable(tb, self)
    tb.roleDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.UnionMember:Encode()
    local tb = {}
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.b = self.userId
    end
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.c = self.nickName
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.d = self.gender
    end
    if nil ~= self.memberJob and 0 ~= self.memberJob then
        tb.e = self.memberJob
    end
    if nil ~= self.worth and 0 ~= self.worth then
        tb.f = self.worth
    end
    if nil ~= self.invest and 0 ~= self.invest then
        tb.g = self.invest
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.h = self.level
    end
    tb.i = self.roleDress:Encode()
    return tb
end

function MsgType.UnionMember:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.userId = tostring(data.b)
    end
    if nil ~= data.c then
        self.nickName = tostring(data.c)
    end
    if nil ~= data.d then
        self.gender = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.memberJob = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.worth = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.invest = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.level = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.roleDress:Decode(data.i)
    end
    return self
end

function MsgType.UnionMember:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UnionMember:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.UnionDetailData = {
    unionId = "",
    unionName = "",
    unionLevel = 0,
    presidentUserId = "",
    presidentNickName = "",
    enterSetting = 0, --enum EUnionEnter
    enterLevel = 0,
    memberNumLimit = 0,
    memberList = {}, -- array of MsgType.UnionMember
    enterInvest = 0
}
MsgType.UnionDetailData.__index = MsgType.UnionDetailData

function MsgType.UnionDetailData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.memberList = {}
    return tb
end

function MsgType.UnionDetailData:_memberListEncode()
    local tb = {}
    for i=1, #self.memberList do
        tb[i] = self.memberList[i]:Encode()
    end
    return tb
end
function MsgType.UnionDetailData:Encode()
    local tb = {}
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.b = self.unionId
    end
    if nil ~= self.unionName and string.len(self.unionName) > 0 then
        tb.c = self.unionName
    end
    if nil ~= self.unionLevel and 0 ~= self.unionLevel then
        tb.d = self.unionLevel
    end
    if nil ~= self.presidentUserId and string.len(self.presidentUserId) > 0 then
        tb.e = self.presidentUserId
    end
    if nil ~= self.presidentNickName and string.len(self.presidentNickName) > 0 then
        tb.f = self.presidentNickName
    end
    if nil ~= self.enterSetting and 0 ~= self.enterSetting then
        tb.g = self.enterSetting
    end
    if nil ~= self.enterLevel and 0 ~= self.enterLevel then
        tb.h = self.enterLevel
    end
    if nil ~= self.memberNumLimit and 0 ~= self.memberNumLimit then
        tb.i = self.memberNumLimit
    end
    tb.j = self:_memberListEncode()
    if nil ~= self.enterInvest and 0 ~= self.enterInvest then
        tb.k = self.enterInvest
    end
    return tb
end

function MsgType.UnionDetailData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.unionId = tostring(data.b)
    end
    if nil ~= data.c then
        self.unionName = tostring(data.c)
    end
    if nil ~= data.d then
        self.unionLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.presidentUserId = tostring(data.e)
    end
    if nil ~= data.f then
        self.presidentNickName = tostring(data.f)
    end
    if nil ~= data.g then
        self.enterSetting = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.enterLevel = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.memberNumLimit = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpMemberListObj = MsgType.UnionMember:New()
            tmpMemberListObj:Decode(data.j[i])
            self.memberList[i] = tmpMemberListObj
        end
    end
    if nil ~= data.k then
        self.enterInvest = tonumber(data.k) or 0
    end
    return self
end

function MsgType.UnionDetailData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UnionDetailData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.UnionSimpleData = {
    unionId = "",
    unionName = "",
    unionLevel = 0,
    presidentUserId = "",
    presidentNickName = "",
    memberNum = 0,
    memberNumLimit = 0,
    enterSetting = 0, --enum EUnionEnter
    enterLevel = 0
}
MsgType.UnionSimpleData.__index = MsgType.UnionSimpleData

function MsgType.UnionSimpleData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UnionSimpleData:Encode()
    local tb = {}
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.b = self.unionId
    end
    if nil ~= self.unionName and string.len(self.unionName) > 0 then
        tb.c = self.unionName
    end
    if nil ~= self.unionLevel and 0 ~= self.unionLevel then
        tb.d = self.unionLevel
    end
    if nil ~= self.presidentUserId and string.len(self.presidentUserId) > 0 then
        tb.e = self.presidentUserId
    end
    if nil ~= self.presidentNickName and string.len(self.presidentNickName) > 0 then
        tb.f = self.presidentNickName
    end
    if nil ~= self.memberNum and 0 ~= self.memberNum then
        tb.g = self.memberNum
    end
    if nil ~= self.memberNumLimit and 0 ~= self.memberNumLimit then
        tb.h = self.memberNumLimit
    end
    if nil ~= self.enterSetting and 0 ~= self.enterSetting then
        tb.i = self.enterSetting
    end
    if nil ~= self.enterLevel and 0 ~= self.enterLevel then
        tb.j = self.enterLevel
    end
    return tb
end

function MsgType.UnionSimpleData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.unionId = tostring(data.b)
    end
    if nil ~= data.c then
        self.unionName = tostring(data.c)
    end
    if nil ~= data.d then
        self.unionLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.presidentUserId = tostring(data.e)
    end
    if nil ~= data.f then
        self.presidentNickName = tostring(data.f)
    end
    if nil ~= data.g then
        self.memberNum = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.memberNumLimit = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.enterSetting = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.enterLevel = tonumber(data.j) or 0
    end
    return self
end

function MsgType.UnionSimpleData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UnionSimpleData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatSkillItem = {
    skillId = 0,
    level = 0
}
MsgType.CombatSkillItem.__index = MsgType.CombatSkillItem

function MsgType.CombatSkillItem:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CombatSkillItem:Encode()
    local tb = {}
    if nil ~= self.skillId and 0 ~= self.skillId then
        tb.b = self.skillId
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.c = self.level
    end
    return tb
end

function MsgType.CombatSkillItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.skillId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.level = tonumber(data.c) or 0
    end
    return self
end

function MsgType.CombatSkillItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatSkillItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatFighter = {
    key = 0,
    site = 0,
    isMonster = 0,
    sex = 0,
    name = "",
    job = 0,
    level = 0,
    aptitude = 0,
    hp = 0,
    currentHp = 0,
    anger = 0,
    currentAnger = 0,
    str = 0,
    speed = 0,
    weapon = 0,
    equips = {}, -- array of number
    activeSkill = {}, -- array of MsgType.CombatSkillItem
    passiveSkill = {}, -- array of MsgType.CombatSkillItem
    roleDress = {}
}
MsgType.CombatFighter.__index = MsgType.CombatFighter
setmetatable(MsgType.CombatFighter.roleDress, MsgType.RoleDress)

function MsgType.CombatFighter:New()
    local tb = {}
    setmetatable(tb, self)
    tb.equips = {}
    tb.activeSkill = {}
    tb.passiveSkill = {}
    tb.roleDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.CombatFighter:_activeSkillEncode()
    local tb = {}
    for i=1, #self.activeSkill do
        tb[i] = self.activeSkill[i]:Encode()
    end
    return tb
end
function MsgType.CombatFighter:_passiveSkillEncode()
    local tb = {}
    for i=1, #self.passiveSkill do
        tb[i] = self.passiveSkill[i]:Encode()
    end
    return tb
end
function MsgType.CombatFighter:Encode()
    local tb = {}
    if nil ~= self.key and 0 ~= self.key then
        tb.b = self.key
    end
    if nil ~= self.site and 0 ~= self.site then
        tb.c = self.site
    end
    if nil ~= self.isMonster and 0 ~= self.isMonster then
        tb.d = self.isMonster
    end
    if nil ~= self.sex and 0 ~= self.sex then
        tb.e = self.sex
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.f = self.name
    end
    if nil ~= self.job and 0 ~= self.job then
        tb.g = self.job
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.h = self.level
    end
    if nil ~= self.aptitude and 0 ~= self.aptitude then
        tb.i = self.aptitude
    end
    if nil ~= self.hp and 0 ~= self.hp then
        tb.j = self.hp
    end
    if nil ~= self.currentHp and 0 ~= self.currentHp then
        tb.k = self.currentHp
    end
    if nil ~= self.anger and 0 ~= self.anger then
        tb.l = self.anger
    end
    if nil ~= self.currentAnger and 0 ~= self.currentAnger then
        tb.m = self.currentAnger
    end
    if nil ~= self.str and 0 ~= self.str then
        tb.n = self.str
    end
    if nil ~= self.speed and 0 ~= self.speed then
        tb.o = self.speed
    end
    if nil ~= self.weapon and 0 ~= self.weapon then
        tb.p = self.weapon
    end
    if nil ~= self.equips and #self.equips > 0 then
        for i=1, #self.equips do
            tb.e[i] = tonumber(self.equips[i])
        end
    end
    tb.r = self:_activeSkillEncode()
    tb.s = self:_passiveSkillEncode()
    tb.t = self.roleDress:Encode()
    return tb
end

function MsgType.CombatFighter:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.key = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.site = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.isMonster = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.sex = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.name = tostring(data.f)
    end
    if nil ~= data.g then
        self.job = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.level = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.aptitude = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.hp = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.currentHp = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.anger = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.currentAnger = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.str = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.speed = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.weapon = tonumber(data.p) or 0
    end
    if nil ~= data.q and #data.q > 0 then
        for i=1, #data.q do
            self.equips[i] = tonumber(data.q[i])
        end
    end
    if nil ~= data.r then
        for i=1, #data.r do
            local tmpActiveSkillObj = MsgType.CombatSkillItem:New()
            tmpActiveSkillObj:Decode(data.r[i])
            self.activeSkill[i] = tmpActiveSkillObj
        end
    end
    if nil ~= data.s then
        for i=1, #data.s do
            local tmpPassiveSkillObj = MsgType.CombatSkillItem:New()
            tmpPassiveSkillObj:Decode(data.s[i])
            self.passiveSkill[i] = tmpPassiveSkillObj
        end
    end
    if nil ~= data.t then
        self.roleDress:Decode(data.t)
    end
    return self
end

function MsgType.CombatFighter:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatFighter:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatInfo = {
    attackers = {}, -- array of MsgType.CombatFighter
    adversarys = {} -- array of MsgType.CombatFighter
}
MsgType.CombatInfo.__index = MsgType.CombatInfo

function MsgType.CombatInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.attackers = {}
    tb.adversarys = {}
    return tb
end

function MsgType.CombatInfo:_attackersEncode()
    local tb = {}
    for i=1, #self.attackers do
        tb[i] = self.attackers[i]:Encode()
    end
    return tb
end
function MsgType.CombatInfo:_adversarysEncode()
    local tb = {}
    for i=1, #self.adversarys do
        tb[i] = self.adversarys[i]:Encode()
    end
    return tb
end
function MsgType.CombatInfo:Encode()
    local tb = {}
    tb.b = self:_attackersEncode()
    tb.c = self:_adversarysEncode()
    return tb
end

function MsgType.CombatInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpAttackersObj = MsgType.CombatFighter:New()
            tmpAttackersObj:Decode(data.b[i])
            self.attackers[i] = tmpAttackersObj
        end
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpAdversarysObj = MsgType.CombatFighter:New()
            tmpAdversarysObj:Decode(data.c[i])
            self.adversarys[i] = tmpAdversarysObj
        end
    end
    return self
end

function MsgType.CombatInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatAtker = {
    key = 0,
    weapon = 0,
    anger = 0
}
MsgType.CombatAtker.__index = MsgType.CombatAtker

function MsgType.CombatAtker:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CombatAtker:Encode()
    local tb = {}
    if nil ~= self.key and 0 ~= self.key then
        tb.b = self.key
    end
    if nil ~= self.weapon and 0 ~= self.weapon then
        tb.c = self.weapon
    end
    if nil ~= self.anger and 0 ~= self.anger then
        tb.d = self.anger
    end
    return tb
end

function MsgType.CombatAtker:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.key = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.weapon = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.anger = tonumber(data.d) or 0
    end
    return self
end

function MsgType.CombatAtker:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatAtker:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatTargetEffect = {
    hp = 0,
    critical = 0,
    hited = 0,
    piercingDmg = 0,
    burnDmg = 0,
    mentDmg = 0,
    electricityDmg = 0,
    radiationDmg = 0
}
MsgType.CombatTargetEffect.__index = MsgType.CombatTargetEffect

function MsgType.CombatTargetEffect:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CombatTargetEffect:Encode()
    local tb = {}
    if nil ~= self.hp and 0 ~= self.hp then
        tb.b = self.hp
    end
    if nil ~= self.critical and 0 ~= self.critical then
        tb.c = self.critical
    end
    if nil ~= self.hited and 0 ~= self.hited then
        tb.d = self.hited
    end
    if nil ~= self.piercingDmg and 0 ~= self.piercingDmg then
        tb.e = self.piercingDmg
    end
    if nil ~= self.burnDmg and 0 ~= self.burnDmg then
        tb.f = self.burnDmg
    end
    if nil ~= self.mentDmg and 0 ~= self.mentDmg then
        tb.g = self.mentDmg
    end
    if nil ~= self.electricityDmg and 0 ~= self.electricityDmg then
        tb.h = self.electricityDmg
    end
    if nil ~= self.radiationDmg and 0 ~= self.radiationDmg then
        tb.i = self.radiationDmg
    end
    return tb
end

function MsgType.CombatTargetEffect:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.hp = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.critical = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.hited = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.piercingDmg = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.burnDmg = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.mentDmg = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.electricityDmg = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.radiationDmg = tonumber(data.i) or 0
    end
    return self
end

function MsgType.CombatTargetEffect:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatTargetEffect:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatTarget = {
    key = 0,
    weapon = 0,
    anger = 0,
    effectList = {}, -- array of MsgType.CombatTargetEffect
    addBuffList = {}, -- array of number
    removeBuffList = {}, -- array of number
    actions = {} -- array of MsgType.CombatAction
}
MsgType.CombatTarget.__index = MsgType.CombatTarget

function MsgType.CombatTarget:New()
    local tb = {}
    setmetatable(tb, self)
    tb.effectList = {}
    tb.addBuffList = {}
    tb.removeBuffList = {}
    tb.actions = {}
    return tb
end

function MsgType.CombatTarget:_effectListEncode()
    local tb = {}
    for i=1, #self.effectList do
        tb[i] = self.effectList[i]:Encode()
    end
    return tb
end
function MsgType.CombatTarget:_actionsEncode()
    local tb = {}
    for i=1, #self.actions do
        tb[i] = self.actions[i]:Encode()
    end
    return tb
end
function MsgType.CombatTarget:Encode()
    local tb = {}
    if nil ~= self.key and 0 ~= self.key then
        tb.b = self.key
    end
    if nil ~= self.weapon and 0 ~= self.weapon then
        tb.c = self.weapon
    end
    if nil ~= self.anger and 0 ~= self.anger then
        tb.d = self.anger
    end
    tb.e = self:_effectListEncode()
    if nil ~= self.addBuffList and #self.addBuffList > 0 then
        for i=1, #self.addBuffList do
            tb.e[i] = tonumber(self.addBuffList[i])
        end
    end
    if nil ~= self.removeBuffList and #self.removeBuffList > 0 then
        for i=1, #self.removeBuffList do
            tb.e[i] = tonumber(self.removeBuffList[i])
        end
    end
    tb.h = self:_actionsEncode()
    return tb
end

function MsgType.CombatTarget:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.key = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.weapon = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.anger = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpEffectListObj = MsgType.CombatTargetEffect:New()
            tmpEffectListObj:Decode(data.e[i])
            self.effectList[i] = tmpEffectListObj
        end
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.addBuffList[i] = tonumber(data.f[i])
        end
    end
    if nil ~= data.g and #data.g > 0 then
        for i=1, #data.g do
            self.removeBuffList[i] = tonumber(data.g[i])
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpActionsObj = MsgType.CombatAction:New()
            tmpActionsObj:Decode(data.h[i])
            self.actions[i] = tmpActionsObj
        end
    end
    return self
end

function MsgType.CombatTarget:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatTarget:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatAction = {
    actionId = 0,
    actionType = 0,
    skillId = 0,
    buffId = 0,
    actionFrom = {},
    actionTarget = {} -- array of MsgType.CombatTarget
}
MsgType.CombatAction.__index = MsgType.CombatAction
setmetatable(MsgType.CombatAction.actionFrom, MsgType.CombatAtker)

function MsgType.CombatAction:New()
    local tb = {}
    setmetatable(tb, self)
    tb.actionFrom = MsgType.CombatAtker:New()
    tb.actionTarget = {}
    return tb
end

function MsgType.CombatAction:_actionTargetEncode()
    local tb = {}
    for i=1, #self.actionTarget do
        tb[i] = self.actionTarget[i]:Encode()
    end
    return tb
end
function MsgType.CombatAction:Encode()
    local tb = {}
    if nil ~= self.actionId and 0 ~= self.actionId then
        tb.b = self.actionId
    end
    if nil ~= self.actionType and 0 ~= self.actionType then
        tb.c = self.actionType
    end
    if nil ~= self.skillId and 0 ~= self.skillId then
        tb.d = self.skillId
    end
    if nil ~= self.buffId and 0 ~= self.buffId then
        tb.e = self.buffId
    end
    tb.f = self.actionFrom:Encode()
    tb.g = self:_actionTargetEncode()
    return tb
end

function MsgType.CombatAction:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.actionId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.actionType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.skillId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.buffId = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.actionFrom:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpActionTargetObj = MsgType.CombatTarget:New()
            tmpActionTargetObj:Decode(data.g[i])
            self.actionTarget[i] = tmpActionTargetObj
        end
    end
    return self
end

function MsgType.CombatAction:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatAction:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatRound = {
    roundId = 0,
    beforeActions = {}, -- array of MsgType.CombatAction
    actions = {}, -- array of MsgType.CombatAction
    endActions = {} -- array of MsgType.CombatAction
}
MsgType.CombatRound.__index = MsgType.CombatRound

function MsgType.CombatRound:New()
    local tb = {}
    setmetatable(tb, self)
    tb.beforeActions = {}
    tb.actions = {}
    tb.endActions = {}
    return tb
end

function MsgType.CombatRound:_beforeActionsEncode()
    local tb = {}
    for i=1, #self.beforeActions do
        tb[i] = self.beforeActions[i]:Encode()
    end
    return tb
end
function MsgType.CombatRound:_actionsEncode()
    local tb = {}
    for i=1, #self.actions do
        tb[i] = self.actions[i]:Encode()
    end
    return tb
end
function MsgType.CombatRound:_endActionsEncode()
    local tb = {}
    for i=1, #self.endActions do
        tb[i] = self.endActions[i]:Encode()
    end
    return tb
end
function MsgType.CombatRound:Encode()
    local tb = {}
    if nil ~= self.roundId and 0 ~= self.roundId then
        tb.b = self.roundId
    end
    tb.c = self:_beforeActionsEncode()
    tb.d = self:_actionsEncode()
    tb.e = self:_endActionsEncode()
    return tb
end

function MsgType.CombatRound:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.roundId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpBeforeActionsObj = MsgType.CombatAction:New()
            tmpBeforeActionsObj:Decode(data.c[i])
            self.beforeActions[i] = tmpBeforeActionsObj
        end
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpActionsObj = MsgType.CombatAction:New()
            tmpActionsObj:Decode(data.d[i])
            self.actions[i] = tmpActionsObj
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpEndActionsObj = MsgType.CombatAction:New()
            tmpEndActionsObj:Decode(data.e[i])
            self.endActions[i] = tmpEndActionsObj
        end
    end
    return self
end

function MsgType.CombatRound:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatRound:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatWave = {
    waveId = 0,
    attackerKeys = {}, -- array of number
    adversaryKeys = {}, -- array of number
    rounds = {} -- array of MsgType.CombatRound
}
MsgType.CombatWave.__index = MsgType.CombatWave

function MsgType.CombatWave:New()
    local tb = {}
    setmetatable(tb, self)
    tb.attackerKeys = {}
    tb.adversaryKeys = {}
    tb.rounds = {}
    return tb
end

function MsgType.CombatWave:_roundsEncode()
    local tb = {}
    for i=1, #self.rounds do
        tb[i] = self.rounds[i]:Encode()
    end
    return tb
end
function MsgType.CombatWave:Encode()
    local tb = {}
    if nil ~= self.waveId and 0 ~= self.waveId then
        tb.b = self.waveId
    end
    if nil ~= self.attackerKeys and #self.attackerKeys > 0 then
        for i=1, #self.attackerKeys do
            tb.e[i] = tonumber(self.attackerKeys[i])
        end
    end
    if nil ~= self.adversaryKeys and #self.adversaryKeys > 0 then
        for i=1, #self.adversaryKeys do
            tb.e[i] = tonumber(self.adversaryKeys[i])
        end
    end
    tb.e = self:_roundsEncode()
    return tb
end

function MsgType.CombatWave:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.waveId = tonumber(data.b) or 0
    end
    if nil ~= data.c and #data.c > 0 then
        for i=1, #data.c do
            self.attackerKeys[i] = tonumber(data.c[i])
        end
    end
    if nil ~= data.d and #data.d > 0 then
        for i=1, #data.d do
            self.adversaryKeys[i] = tonumber(data.d[i])
        end
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpRoundsObj = MsgType.CombatRound:New()
            tmpRoundsObj:Decode(data.e[i])
            self.rounds[i] = tmpRoundsObj
        end
    end
    return self
end

function MsgType.CombatWave:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatWave:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatResultFighter = {
    key = 0,
    hp = 0,
    dead = 0
}
MsgType.CombatResultFighter.__index = MsgType.CombatResultFighter

function MsgType.CombatResultFighter:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CombatResultFighter:Encode()
    local tb = {}
    if nil ~= self.key and 0 ~= self.key then
        tb.b = self.key
    end
    if nil ~= self.hp and 0 ~= self.hp then
        tb.c = self.hp
    end
    if nil ~= self.dead and 0 ~= self.dead then
        tb.d = self.dead
    end
    return tb
end

function MsgType.CombatResultFighter:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.key = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.hp = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.dead = tonumber(data.d) or 0
    end
    return self
end

function MsgType.CombatResultFighter:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatResultFighter:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatResult = {
    winSide = 0,
    attacker = {}, -- array of MsgType.CombatResultFighter
    adversary = {} -- array of MsgType.CombatResultFighter
}
MsgType.CombatResult.__index = MsgType.CombatResult

function MsgType.CombatResult:New()
    local tb = {}
    setmetatable(tb, self)
    tb.attacker = {}
    tb.adversary = {}
    return tb
end

function MsgType.CombatResult:_attackerEncode()
    local tb = {}
    for i=1, #self.attacker do
        tb[i] = self.attacker[i]:Encode()
    end
    return tb
end
function MsgType.CombatResult:_adversaryEncode()
    local tb = {}
    for i=1, #self.adversary do
        tb[i] = self.adversary[i]:Encode()
    end
    return tb
end
function MsgType.CombatResult:Encode()
    local tb = {}
    if nil ~= self.winSide and 0 ~= self.winSide then
        tb.b = self.winSide
    end
    tb.c = self:_attackerEncode()
    tb.d = self:_adversaryEncode()
    return tb
end

function MsgType.CombatResult:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.winSide = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpAttackerObj = MsgType.CombatResultFighter:New()
            tmpAttackerObj:Decode(data.c[i])
            self.attacker[i] = tmpAttackerObj
        end
    end
    if nil ~= data.d then
        for i=1, #data.d do
            local tmpAdversaryObj = MsgType.CombatResultFighter:New()
            tmpAdversaryObj:Decode(data.d[i])
            self.adversary[i] = tmpAdversaryObj
        end
    end
    return self
end

function MsgType.CombatResult:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatResult:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CombatReport = {
    info = {},
    waves = {}, -- array of MsgType.CombatWave
    result = {}
}
MsgType.CombatReport.__index = MsgType.CombatReport
setmetatable(MsgType.CombatReport.info, MsgType.CombatInfo)
setmetatable(MsgType.CombatReport.result, MsgType.CombatResult)

function MsgType.CombatReport:New()
    local tb = {}
    setmetatable(tb, self)
    tb.info = MsgType.CombatInfo:New()
    tb.waves = {}
    tb.result = MsgType.CombatResult:New()
    return tb
end

function MsgType.CombatReport:_wavesEncode()
    local tb = {}
    for i=1, #self.waves do
        tb[i] = self.waves[i]:Encode()
    end
    return tb
end
function MsgType.CombatReport:Encode()
    local tb = {}
    tb.b = self.info:Encode()
    tb.c = self:_wavesEncode()
    tb.d = self.result:Encode()
    return tb
end

function MsgType.CombatReport:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.info:Decode(data.b)
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpWavesObj = MsgType.CombatWave:New()
            tmpWavesObj:Decode(data.c[i])
            self.waves[i] = tmpWavesObj
        end
    end
    if nil ~= data.d then
        self.result:Decode(data.d)
    end
    return self
end

function MsgType.CombatReport:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CombatReport:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Gm_Command = {
    msgSeq = 0,
    command = ""
}
MsgType.Request_Gm_Command.__index = MsgType.Request_Gm_Command

function MsgType.Request_Gm_Command:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Gm_Command:GetCmd()
    return MsgTypeCmd.Request_Gm_Command_Cmd
end
function MsgType.Request_Gm_Command:GetUrl()
    return "Request_Gm_Command"
end
function MsgType.Request_Gm_Command:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.command and string.len(self.command) > 0 then
        tb.c = self.command
    end
    return tb
end

function MsgType.Request_Gm_Command:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Gm_Command:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Gm_Command = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    testReport = {}
}
MsgType.Response_Gm_Command.__index = MsgType.Response_Gm_Command
setmetatable(MsgType.Response_Gm_Command.testReport, MsgType.CombatReport)

function MsgType.Response_Gm_Command:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.testReport = MsgType.CombatReport:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Gm_Command:GetCmd()
    return MsgTypeCmd.Response_Gm_Command_Cmd
end
function MsgType.Response_Gm_Command:GetUrl()
    return "Response_Gm_Command"
end
function MsgType.Response_Gm_Command:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.testReport:Decode(data.f)
    end
    return self
end


MsgType.Request_Client_Error = {
    msgSeq = 0,
    userId = "",
    ver = "",
    err = "",
    osType = 0, --enum EOsType
    stackTrack = ""
}
MsgType.Request_Client_Error.__index = MsgType.Request_Client_Error

function MsgType.Request_Client_Error:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Client_Error:GetCmd()
    return MsgTypeCmd.Request_Client_Error_Cmd
end
function MsgType.Request_Client_Error:GetUrl()
    return "Request_Client_Error"
end
function MsgType.Request_Client_Error:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.c = self.userId
    end
    if nil ~= self.ver and string.len(self.ver) > 0 then
        tb.d = self.ver
    end
    if nil ~= self.err and string.len(self.err) > 0 then
        tb.e = self.err
    end
    if nil ~= self.osType and 0 ~= self.osType then
        tb.f = self.osType
    end
    if nil ~= self.stackTrack and string.len(self.stackTrack) > 0 then
        tb.g = self.stackTrack
    end
    return tb
end

function MsgType.Request_Client_Error:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Client_Error:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Client_Error = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Client_Error.__index = MsgType.Response_Client_Error

function MsgType.Response_Client_Error:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Client_Error:GetCmd()
    return MsgTypeCmd.Response_Client_Error_Cmd
end
function MsgType.Response_Client_Error:GetUrl()
    return "Response_Client_Error"
end
function MsgType.Response_Client_Error:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Response_Client_Af = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    eventName = "",
    eventArg = 0
}
MsgType.Response_Client_Af.__index = MsgType.Response_Client_Af

function MsgType.Response_Client_Af:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Client_Af:GetCmd()
    return MsgTypeCmd.Response_Client_Af_Cmd
end
function MsgType.Response_Client_Af:GetUrl()
    return "Response_Client_Af"
end
function MsgType.Response_Client_Af:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.eventName = tostring(data.f)
    end
    if nil ~= data.g then
        self.eventArg = tonumber(data.g) or 0
    end
    return self
end


MsgType.Notice = {
    lang = 0, --enum ELangType
    noticeTitle = "",
    noticeContent = ""
}
MsgType.Notice.__index = MsgType.Notice

function MsgType.Notice:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.Notice:Encode()
    local tb = {}
    if nil ~= self.lang and 0 ~= self.lang then
        tb.b = self.lang
    end
    if nil ~= self.noticeTitle and string.len(self.noticeTitle) > 0 then
        tb.c = self.noticeTitle
    end
    if nil ~= self.noticeContent and string.len(self.noticeContent) > 0 then
        tb.d = self.noticeContent
    end
    return tb
end

function MsgType.Notice:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.lang = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.noticeTitle = tostring(data.c)
    end
    if nil ~= data.d then
        self.noticeContent = tostring(data.d)
    end
    return self
end

function MsgType.Notice:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Notice:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CsvFileMd5 = {
    fileName = "",
    fileMd5 = ""
}
MsgType.CsvFileMd5.__index = MsgType.CsvFileMd5

function MsgType.CsvFileMd5:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CsvFileMd5:Encode()
    local tb = {}
    if nil ~= self.fileName and string.len(self.fileName) > 0 then
        tb.b = self.fileName
    end
    if nil ~= self.fileMd5 and string.len(self.fileMd5) > 0 then
        tb.c = self.fileMd5
    end
    return tb
end

function MsgType.CsvFileMd5:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.fileName = tostring(data.b)
    end
    if nil ~= data.c then
        self.fileMd5 = tostring(data.c)
    end
    return self
end

function MsgType.CsvFileMd5:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CsvFileMd5:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.CsvFileContent = {
    fileName = "",
    fileMd5 = "",
    fileContent = ""
}
MsgType.CsvFileContent.__index = MsgType.CsvFileContent

function MsgType.CsvFileContent:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CsvFileContent:Encode()
    local tb = {}
    if nil ~= self.fileName and string.len(self.fileName) > 0 then
        tb.b = self.fileName
    end
    if nil ~= self.fileMd5 and string.len(self.fileMd5) > 0 then
        tb.c = self.fileMd5
    end
    if nil ~= self.fileContent and string.len(self.fileContent) > 0 then
        tb.d = self.fileContent
    end
    return tb
end

function MsgType.CsvFileContent:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.fileName = tostring(data.b)
    end
    if nil ~= data.c then
        self.fileMd5 = tostring(data.c)
    end
    if nil ~= data.d then
        self.fileContent = tostring(data.d)
    end
    return self
end

function MsgType.CsvFileContent:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CsvFileContent:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Gate = {
    msgSeq = 0,
    osType = 0, --enum EOsType
    lang = 0, --enum ELangType
    appVer = "",
    resVer = "",
    gameUrl = ""
}
MsgType.Request_Gate.__index = MsgType.Request_Gate

function MsgType.Request_Gate:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Gate:GetCmd()
    return MsgTypeCmd.Request_Gate_Cmd
end
function MsgType.Request_Gate:GetUrl()
    return "Request_Gate"
end
function MsgType.Request_Gate:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.osType and 0 ~= self.osType then
        tb.c = self.osType
    end
    if nil ~= self.lang and 0 ~= self.lang then
        tb.d = self.lang
    end
    if nil ~= self.appVer and string.len(self.appVer) > 0 then
        tb.e = self.appVer
    end
    if nil ~= self.resVer and string.len(self.resVer) > 0 then
        tb.f = self.resVer
    end
    if nil ~= self.gameUrl and string.len(self.gameUrl) > 0 then
        tb.g = self.gameUrl
    end
    return tb
end

function MsgType.Request_Gate:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Gate:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Gate = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    appVer = "",
    resVer = "",
    gameUrl = "",
    resUrl = "",
    noticeAutoCloseTime = 0,
    noticeList = {}, -- array of MsgType.Notice
    userBehaviorReportFlag = 0,
    lei = 0
}
MsgType.Response_Gate.__index = MsgType.Response_Gate

function MsgType.Response_Gate:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.noticeList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Gate:GetCmd()
    return MsgTypeCmd.Response_Gate_Cmd
end
function MsgType.Response_Gate:GetUrl()
    return "Response_Gate"
end
function MsgType.Response_Gate:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.appVer = tostring(data.f)
    end
    if nil ~= data.g then
        self.resVer = tostring(data.g)
    end
    if nil ~= data.h then
        self.gameUrl = tostring(data.h)
    end
    if nil ~= data.i then
        self.resUrl = tostring(data.i)
    end
    if nil ~= data.j then
        self.noticeAutoCloseTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpNoticeListObj = MsgType.Notice:New()
            tmpNoticeListObj:Decode(data.k[i])
            self.noticeList[i] = tmpNoticeListObj
        end
    end
    if nil ~= data.l then
        self.userBehaviorReportFlag = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.lei = tonumber(data.m) or 0
    end
    return self
end


MsgType.Request_Csv_List = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Csv_List.__index = MsgType.Request_Csv_List

function MsgType.Request_Csv_List:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Csv_List:GetCmd()
    return MsgTypeCmd.Request_Csv_List_Cmd
end
function MsgType.Request_Csv_List:GetUrl()
    return "Request_Csv_List"
end
function MsgType.Request_Csv_List:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Csv_List:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Csv_List:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Csv_List = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    csvFileMd5List = {} -- array of MsgType.CsvFileMd5
}
MsgType.Response_Csv_List.__index = MsgType.Response_Csv_List

function MsgType.Response_Csv_List:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.csvFileMd5List = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Csv_List:GetCmd()
    return MsgTypeCmd.Response_Csv_List_Cmd
end
function MsgType.Response_Csv_List:GetUrl()
    return "Response_Csv_List"
end
function MsgType.Response_Csv_List:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpCsvFileMd5ListObj = MsgType.CsvFileMd5:New()
            tmpCsvFileMd5ListObj:Decode(data.f[i])
            self.csvFileMd5List[i] = tmpCsvFileMd5ListObj
        end
    end
    return self
end


MsgType.Request_Csv_Load = {
    msgSeq = 0,
    csvFileNameList = ""
}
MsgType.Request_Csv_Load.__index = MsgType.Request_Csv_Load

function MsgType.Request_Csv_Load:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Csv_Load:GetCmd()
    return MsgTypeCmd.Request_Csv_Load_Cmd
end
function MsgType.Request_Csv_Load:GetUrl()
    return "Request_Csv_Load"
end
function MsgType.Request_Csv_Load:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.csvFileNameList and string.len(self.csvFileNameList) > 0 then
        tb.c = self.csvFileNameList
    end
    return tb
end

function MsgType.Request_Csv_Load:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Csv_Load:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Csv_Load = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    csvFileContentList = {} -- array of MsgType.CsvFileContent
}
MsgType.Response_Csv_Load.__index = MsgType.Response_Csv_Load

function MsgType.Response_Csv_Load:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.csvFileContentList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Csv_Load:GetCmd()
    return MsgTypeCmd.Response_Csv_Load_Cmd
end
function MsgType.Response_Csv_Load:GetUrl()
    return "Response_Csv_Load"
end
function MsgType.Response_Csv_Load:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpCsvFileContentListObj = MsgType.CsvFileContent:New()
            tmpCsvFileContentListObj:Decode(data.f[i])
            self.csvFileContentList[i] = tmpCsvFileContentListObj
        end
    end
    return self
end


MsgType.Request_Heartbeat = {
    msgSeq = 0,
    appVer = "",
    resVer = "",
    heartbeat = 0,
    unionId = "",
    lastDay = 0,
    onlineTime = 0,
    mailTime = 0,
    chatIndex = 0,
    raceLampIndex = 0,
    activityBuffVersion = 0,
    verStr = "",
    ver1 = 0,
    ver2 = 0,
    ver3 = 0,
    ver4 = 0,
    ver5 = 0,
    ver6 = 0,
    ver7 = 0,
    ver8 = 0,
    ver9 = 0,
    ver10 = 0
}
MsgType.Request_Heartbeat.__index = MsgType.Request_Heartbeat

function MsgType.Request_Heartbeat:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Heartbeat:GetCmd()
    return MsgTypeCmd.Request_Heartbeat_Cmd
end
function MsgType.Request_Heartbeat:GetUrl()
    return "Request_Heartbeat"
end
function MsgType.Request_Heartbeat:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.appVer and string.len(self.appVer) > 0 then
        tb.c = self.appVer
    end
    if nil ~= self.resVer and string.len(self.resVer) > 0 then
        tb.d = self.resVer
    end
    if nil ~= self.heartbeat and 0 ~= self.heartbeat then
        tb.e = self.heartbeat
    end
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.f = self.unionId
    end
    if nil ~= self.lastDay and 0 ~= self.lastDay then
        tb.g = self.lastDay
    end
    if nil ~= self.onlineTime and 0 ~= self.onlineTime then
        tb.h = self.onlineTime
    end
    if nil ~= self.mailTime and 0 ~= self.mailTime then
        tb.i = self.mailTime
    end
    if nil ~= self.chatIndex and 0 ~= self.chatIndex then
        tb.j = self.chatIndex
    end
    if nil ~= self.raceLampIndex and 0 ~= self.raceLampIndex then
        tb.k = self.raceLampIndex
    end
    if nil ~= self.activityBuffVersion and 0 ~= self.activityBuffVersion then
        tb.l = self.activityBuffVersion
    end
    if nil ~= self.verStr and string.len(self.verStr) > 0 then
        tb.m = self.verStr
    end
    if nil ~= self.ver1 and 0 ~= self.ver1 then
        tb.n = self.ver1
    end
    if nil ~= self.ver2 and 0 ~= self.ver2 then
        tb.o = self.ver2
    end
    if nil ~= self.ver3 and 0 ~= self.ver3 then
        tb.p = self.ver3
    end
    if nil ~= self.ver4 and 0 ~= self.ver4 then
        tb.q = self.ver4
    end
    if nil ~= self.ver5 and 0 ~= self.ver5 then
        tb.r = self.ver5
    end
    if nil ~= self.ver6 and 0 ~= self.ver6 then
        tb.s = self.ver6
    end
    if nil ~= self.ver7 and 0 ~= self.ver7 then
        tb.t = self.ver7
    end
    if nil ~= self.ver8 and 0 ~= self.ver8 then
        tb.u = self.ver8
    end
    if nil ~= self.ver9 and 0 ~= self.ver9 then
        tb.v = self.ver9
    end
    if nil ~= self.ver10 and 0 ~= self.ver10 then
        tb.w = self.ver10
    end
    return tb
end

function MsgType.Request_Heartbeat:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Heartbeat:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Heartbeat = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heartbeat = 0,
    lastDay = 0,
    onlineTime = 0,
    mailTime = 0,
    chatIndex = 0,
    raceLampIndex = 0,
    newChatEvent = 0,
    newMailEvent = 0,
    newShopperEvent = 0,
    newDesignEvent = 0,
    newMarketEvent = 0,
    newUnionEvent = 0,
    newUnionScienceEvent = 0,
    newUnionSkillEvent = 0,
    newUnionBuildEvent = 0,
    newUnionHelpEvent = 0,
    newUnionTaskEvent = 0,
    newUnionOperatingActivityEvent = 0,
    newUnionGoldCastleEvent = 0,
    activityBuffVersion = 0,
    verStr = "",
    ver1 = 0,
    ver2 = 0,
    ver3 = 0,
    ver4 = 0,
    ver5 = 0,
    ver6 = 0,
    ver7 = 0,
    ver8 = 0,
    ver9 = 0,
    ver10 = 0,
    newSystemMsgEvent = 0
}
MsgType.Response_Heartbeat.__index = MsgType.Response_Heartbeat

function MsgType.Response_Heartbeat:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Heartbeat:GetCmd()
    return MsgTypeCmd.Response_Heartbeat_Cmd
end
function MsgType.Response_Heartbeat:GetUrl()
    return "Response_Heartbeat"
end
function MsgType.Response_Heartbeat:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.heartbeat = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.lastDay = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.onlineTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.mailTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.chatIndex = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.raceLampIndex = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.newChatEvent = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.newMailEvent = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.newShopperEvent = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.newDesignEvent = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.newMarketEvent = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        self.newUnionEvent = tonumber(data.q) or 0
    end
    if nil ~= data.r then
        self.newUnionScienceEvent = tonumber(data.r) or 0
    end
    if nil ~= data.s then
        self.newUnionSkillEvent = tonumber(data.s) or 0
    end
    if nil ~= data.t then
        self.newUnionBuildEvent = tonumber(data.t) or 0
    end
    if nil ~= data.u then
        self.newUnionHelpEvent = tonumber(data.u) or 0
    end
    if nil ~= data.v then
        self.newUnionTaskEvent = tonumber(data.v) or 0
    end
    if nil ~= data.w then
        self.newUnionOperatingActivityEvent = tonumber(data.w) or 0
    end
    if nil ~= data.x then
        self.newUnionGoldCastleEvent = tonumber(data.x) or 0
    end
    if nil ~= data.y then
        self.activityBuffVersion = tonumber(data.y) or 0
    end
    if nil ~= data.z then
        self.verStr = tostring(data.z)
    end
    if nil ~= data.a1 then
        self.ver1 = tonumber(data.a1) or 0
    end
    if nil ~= data.a2 then
        self.ver2 = tonumber(data.a2) or 0
    end
    if nil ~= data.a3 then
        self.ver3 = tonumber(data.a3) or 0
    end
    if nil ~= data.a4 then
        self.ver4 = tonumber(data.a4) or 0
    end
    if nil ~= data.a5 then
        self.ver5 = tonumber(data.a5) or 0
    end
    if nil ~= data.a6 then
        self.ver6 = tonumber(data.a6) or 0
    end
    if nil ~= data.a7 then
        self.ver7 = tonumber(data.a7) or 0
    end
    if nil ~= data.a8 then
        self.ver8 = tonumber(data.a8) or 0
    end
    if nil ~= data.a9 then
        self.ver9 = tonumber(data.a9) or 0
    end
    if nil ~= data.aa then
        self.ver10 = tonumber(data.aa) or 0
    end
    if nil ~= data.ab then
        self.newSystemMsgEvent = tonumber(data.ab) or 0
    end
    return self
end


MsgType.Request_Heartbeat2 = {
    msgSeq = 0,
    heartbeat = 0,
    unionId = "",
    ver1 = 0
}
MsgType.Request_Heartbeat2.__index = MsgType.Request_Heartbeat2

function MsgType.Request_Heartbeat2:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Heartbeat2:GetCmd()
    return MsgTypeCmd.Request_Heartbeat2_Cmd
end
function MsgType.Request_Heartbeat2:GetUrl()
    return "Request_Heartbeat2"
end
function MsgType.Request_Heartbeat2:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heartbeat and 0 ~= self.heartbeat then
        tb.c = self.heartbeat
    end
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.d = self.unionId
    end
    if nil ~= self.ver1 and 0 ~= self.ver1 then
        tb.e = self.ver1
    end
    return tb
end

function MsgType.Request_Heartbeat2:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Heartbeat2:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Heartbeat2 = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heartbeat = 0,
    newPointActivity2Event = 0,
    ver1 = 0
}
MsgType.Response_Heartbeat2.__index = MsgType.Response_Heartbeat2

function MsgType.Response_Heartbeat2:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Heartbeat2:GetCmd()
    return MsgTypeCmd.Response_Heartbeat2_Cmd
end
function MsgType.Response_Heartbeat2:GetUrl()
    return "Response_Heartbeat2"
end
function MsgType.Response_Heartbeat2:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.heartbeat = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.newPointActivity2Event = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.ver1 = tonumber(data.h) or 0
    end
    return self
end


MsgType.Response_Notify = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    text = ""
}
MsgType.Response_Notify.__index = MsgType.Response_Notify

function MsgType.Response_Notify:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Notify:GetCmd()
    return MsgTypeCmd.Response_Notify_Cmd
end
function MsgType.Response_Notify:GetUrl()
    return "Response_Notify"
end
function MsgType.Response_Notify:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.text = tostring(data.f)
    end
    return self
end


MsgType.Request_User_Login = {
    msgSeq = 0,
    platform = 0, --enum EPlatform
    osType = 0, --enum EOsType
    libCode = "",
    appVer = "",
    resVer = "",
    deviceId = "",
    accountToken = "",
    account = "",
    platformUid = "",
    platformToken = "",
    platformChannel = "",
    s1 = "",
    s2 = "",
    s3 = "",
    s4 = ""
}
MsgType.Request_User_Login.__index = MsgType.Request_User_Login

function MsgType.Request_User_Login:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_Login:GetCmd()
    return MsgTypeCmd.Request_User_Login_Cmd
end
function MsgType.Request_User_Login:GetUrl()
    return "Request_User_Login"
end
function MsgType.Request_User_Login:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.platform and 0 ~= self.platform then
        tb.c = self.platform
    end
    if nil ~= self.osType and 0 ~= self.osType then
        tb.d = self.osType
    end
    if nil ~= self.libCode and string.len(self.libCode) > 0 then
        tb.e = self.libCode
    end
    if nil ~= self.appVer and string.len(self.appVer) > 0 then
        tb.f = self.appVer
    end
    if nil ~= self.resVer and string.len(self.resVer) > 0 then
        tb.g = self.resVer
    end
    if nil ~= self.deviceId and string.len(self.deviceId) > 0 then
        tb.h = self.deviceId
    end
    if nil ~= self.accountToken and string.len(self.accountToken) > 0 then
        tb.i = self.accountToken
    end
    if nil ~= self.account and string.len(self.account) > 0 then
        tb.j = self.account
    end
    if nil ~= self.platformUid and string.len(self.platformUid) > 0 then
        tb.k = self.platformUid
    end
    if nil ~= self.platformToken and string.len(self.platformToken) > 0 then
        tb.l = self.platformToken
    end
    if nil ~= self.platformChannel and string.len(self.platformChannel) > 0 then
        tb.m = self.platformChannel
    end
    if nil ~= self.s1 and string.len(self.s1) > 0 then
        tb.n = self.s1
    end
    if nil ~= self.s2 and string.len(self.s2) > 0 then
        tb.o = self.s2
    end
    if nil ~= self.s3 and string.len(self.s3) > 0 then
        tb.p = self.s3
    end
    if nil ~= self.s4 and string.len(self.s4) > 0 then
        tb.q = self.s4
    end
    return tb
end

function MsgType.Request_User_Login:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_Login:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_Login = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    account = "",
    userId = "",
    nickName = "",
    accountToken = "",
    bindingType = 0, --enum EBindingType
    bindingId = "",
    bindingClaimState = 0,
    isNewUser = 0,
    k1 = ""
}
MsgType.Response_User_Login.__index = MsgType.Response_User_Login

function MsgType.Response_User_Login:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_Login:GetCmd()
    return MsgTypeCmd.Response_User_Login_Cmd
end
function MsgType.Response_User_Login:GetUrl()
    return "Response_User_Login"
end
function MsgType.Response_User_Login:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.account = tostring(data.f)
    end
    if nil ~= data.g then
        self.userId = tostring(data.g)
    end
    if nil ~= data.h then
        self.nickName = tostring(data.h)
    end
    if nil ~= data.i then
        self.accountToken = tostring(data.i)
    end
    if nil ~= data.j then
        self.bindingType = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.bindingId = tostring(data.k)
    end
    if nil ~= data.l then
        self.bindingClaimState = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.isNewUser = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.k1 = tostring(data.n)
    end
    return self
end


MsgType.UserDress = {
    dress1 = 0,
    dress2 = 0,
    dress3 = 0,
    dress4 = 0,
    dress5 = 0,
    dress6 = 0,
    dress7 = 0,
    dress8 = 0,
    dress20 = 0,
    dress21 = 0,
    dress22 = 0,
    dress23 = 0,
    dress24 = 0,
    dress25 = 0
}
MsgType.UserDress.__index = MsgType.UserDress

function MsgType.UserDress:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UserDress:Encode()
    local tb = {}
    if nil ~= self.dress1 and 0 ~= self.dress1 then
        tb.b = self.dress1
    end
    if nil ~= self.dress2 and 0 ~= self.dress2 then
        tb.c = self.dress2
    end
    if nil ~= self.dress3 and 0 ~= self.dress3 then
        tb.d = self.dress3
    end
    if nil ~= self.dress4 and 0 ~= self.dress4 then
        tb.e = self.dress4
    end
    if nil ~= self.dress5 and 0 ~= self.dress5 then
        tb.f = self.dress5
    end
    if nil ~= self.dress6 and 0 ~= self.dress6 then
        tb.g = self.dress6
    end
    if nil ~= self.dress7 and 0 ~= self.dress7 then
        tb.h = self.dress7
    end
    if nil ~= self.dress8 and 0 ~= self.dress8 then
        tb.i = self.dress8
    end
    if nil ~= self.dress20 and 0 ~= self.dress20 then
        tb.j = self.dress20
    end
    if nil ~= self.dress21 and 0 ~= self.dress21 then
        tb.k = self.dress21
    end
    if nil ~= self.dress22 and 0 ~= self.dress22 then
        tb.l = self.dress22
    end
    if nil ~= self.dress23 and 0 ~= self.dress23 then
        tb.m = self.dress23
    end
    if nil ~= self.dress24 and 0 ~= self.dress24 then
        tb.n = self.dress24
    end
    if nil ~= self.dress25 and 0 ~= self.dress25 then
        tb.o = self.dress25
    end
    return tb
end

function MsgType.UserDress:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.dress1 = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.dress2 = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.dress3 = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.dress4 = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.dress5 = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.dress6 = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.dress7 = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.dress8 = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.dress20 = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.dress21 = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.dress22 = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.dress23 = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.dress24 = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.dress25 = tonumber(data.o) or 0
    end
    return self
end

function MsgType.UserDress:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UserDress:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.UnionMemberData = {
    unionName = "",
    unionMember = {}
}
MsgType.UnionMemberData.__index = MsgType.UnionMemberData
setmetatable(MsgType.UnionMemberData.unionMember, MsgType.UnionMember)

function MsgType.UnionMemberData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.unionMember = MsgType.UnionMember:New()
    return tb
end

function MsgType.UnionMemberData:Encode()
    local tb = {}
    if nil ~= self.unionName and string.len(self.unionName) > 0 then
        tb.b = self.unionName
    end
    tb.c = self.unionMember:Encode()
    return tb
end

function MsgType.UnionMemberData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.unionName = tostring(data.b)
    end
    if nil ~= data.c then
        self.unionMember:Decode(data.c)
    end
    return self
end

function MsgType.UnionMemberData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UnionMemberData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_Create = {
    msgSeq = 0,
    nickName = "",
    gender = 0, --enum EGender
    userDress = {}
}
MsgType.Request_User_Create.__index = MsgType.Request_User_Create
setmetatable(MsgType.Request_User_Create.userDress, MsgType.RoleDress)

function MsgType.Request_User_Create:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.Request_User_Create:GetCmd()
    return MsgTypeCmd.Request_User_Create_Cmd
end
function MsgType.Request_User_Create:GetUrl()
    return "Request_User_Create"
end
function MsgType.Request_User_Create:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.c = self.nickName
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.d = self.gender
    end
    tb.e = self.userDress:Encode()
    return tb
end

function MsgType.Request_User_Create:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_Create:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_Create = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    account = "",
    userId = ""
}
MsgType.Response_User_Create.__index = MsgType.Response_User_Create

function MsgType.Response_User_Create:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_Create:GetCmd()
    return MsgTypeCmd.Response_User_Create_Cmd
end
function MsgType.Response_User_Create:GetUrl()
    return "Response_User_Create"
end
function MsgType.Response_User_Create:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.account = tostring(data.f)
    end
    if nil ~= data.g then
        self.userId = tostring(data.g)
    end
    return self
end


MsgType.UserData = {
    nickName = "",
    gender = 0, --enum EGender
    userDress = {},
    exp = 0,
    level = 0,
    gold = 0,
    gem = 0,
    energy = 0,
    energyLimit = 0,
    drawing = 0,
    worth = 0,
    invest = 0,
    prosperity = 0,
    masterCount = 0,
    bagLimit = 0,
    pileLimit = 0,
    guideId = 0,
    unionCoin = 0,
    unionHelpCount = 0,
    unionTaskCrownCount = 0
}
MsgType.UserData.__index = MsgType.UserData
setmetatable(MsgType.UserData.userDress, MsgType.RoleDress)

function MsgType.UserData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.userDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.UserData:Encode()
    local tb = {}
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.b = self.nickName
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.c = self.gender
    end
    tb.d = self.userDress:Encode()
    if nil ~= self.exp and 0 ~= self.exp then
        tb.e = self.exp
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.f = self.level
    end
    if nil ~= self.gold and 0 ~= self.gold then
        tb.g = self.gold
    end
    if nil ~= self.gem and 0 ~= self.gem then
        tb.h = self.gem
    end
    if nil ~= self.energy and 0 ~= self.energy then
        tb.i = self.energy
    end
    if nil ~= self.energyLimit and 0 ~= self.energyLimit then
        tb.j = self.energyLimit
    end
    if nil ~= self.drawing and 0 ~= self.drawing then
        tb.k = self.drawing
    end
    if nil ~= self.worth and 0 ~= self.worth then
        tb.l = self.worth
    end
    if nil ~= self.invest and 0 ~= self.invest then
        tb.m = self.invest
    end
    if nil ~= self.prosperity and 0 ~= self.prosperity then
        tb.n = self.prosperity
    end
    if nil ~= self.masterCount and 0 ~= self.masterCount then
        tb.o = self.masterCount
    end
    if nil ~= self.bagLimit and 0 ~= self.bagLimit then
        tb.p = self.bagLimit
    end
    if nil ~= self.pileLimit and 0 ~= self.pileLimit then
        tb.q = self.pileLimit
    end
    if nil ~= self.guideId and 0 ~= self.guideId then
        tb.r = self.guideId
    end
    if nil ~= self.unionCoin and 0 ~= self.unionCoin then
        tb.s = self.unionCoin
    end
    if nil ~= self.unionHelpCount and 0 ~= self.unionHelpCount then
        tb.t = self.unionHelpCount
    end
    if nil ~= self.unionTaskCrownCount and 0 ~= self.unionTaskCrownCount then
        tb.u = self.unionTaskCrownCount
    end
    return tb
end

function MsgType.UserData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.nickName = tostring(data.b)
    end
    if nil ~= data.c then
        self.gender = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.userDress:Decode(data.d)
    end
    if nil ~= data.e then
        self.exp = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.level = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.gold = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.gem = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.energy = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.energyLimit = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.drawing = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.worth = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.invest = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.prosperity = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.masterCount = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.bagLimit = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        self.pileLimit = tonumber(data.q) or 0
    end
    if nil ~= data.r then
        self.guideId = tonumber(data.r) or 0
    end
    if nil ~= data.s then
        self.unionCoin = tonumber(data.s) or 0
    end
    if nil ~= data.t then
        self.unionHelpCount = tonumber(data.t) or 0
    end
    if nil ~= data.u then
        self.unionTaskCrownCount = tonumber(data.u) or 0
    end
    return self
end

function MsgType.UserData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UserData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.UserExtData = {
    freeNameCount = 0
}
MsgType.UserExtData.__index = MsgType.UserExtData

function MsgType.UserExtData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UserExtData:Encode()
    local tb = {}
    if nil ~= self.freeNameCount and 0 ~= self.freeNameCount then
        tb.b = self.freeNameCount
    end
    return tb
end

function MsgType.UserExtData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.freeNameCount = tonumber(data.b) or 0
    end
    return self
end

function MsgType.UserExtData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UserExtData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.UnionData = {
    unionId = "",
    unionName = "",
    unionLevel = 0,
    memberJob = 0 --enum EUnionJob
}
MsgType.UnionData.__index = MsgType.UnionData

function MsgType.UnionData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.UnionData:Encode()
    local tb = {}
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.b = self.unionId
    end
    if nil ~= self.unionName and string.len(self.unionName) > 0 then
        tb.c = self.unionName
    end
    if nil ~= self.unionLevel and 0 ~= self.unionLevel then
        tb.d = self.unionLevel
    end
    if nil ~= self.memberJob and 0 ~= self.memberJob then
        tb.e = self.memberJob
    end
    return tb
end

function MsgType.UnionData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.unionId = tostring(data.b)
    end
    if nil ~= data.c then
        self.unionName = tostring(data.c)
    end
    if nil ~= data.d then
        self.unionLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.memberJob = tonumber(data.e) or 0
    end
    return self
end

function MsgType.UnionData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UnionData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.EUnionMessageType = {
    EnterUnion = 1,
    ChangeJobToMember = 2,
    ChangeJobToManager = 3,
    ChangeJobToPresident = 4,
    LeaveUnion = 5,
    UnionKickOut = 6,
    Impeach = 7
}

MsgType.UnionMsgData = {
    unionMsgType = 0, --enum EUnionMessageType
    unionId = 0,
    eventTime = 0,
    userId = "",
    nickName = "",
    optionUserId = "",
    gender = 0, --enum EGender
    level = 0,
    userDress = {},
    memberJob = 0 --enum EUnionJob
}
MsgType.UnionMsgData.__index = MsgType.UnionMsgData
setmetatable(MsgType.UnionMsgData.userDress, MsgType.RoleDress)

function MsgType.UnionMsgData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.userDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.UnionMsgData:Encode()
    local tb = {}
    if nil ~= self.unionMsgType and 0 ~= self.unionMsgType then
        tb.b = self.unionMsgType
    end
    if nil ~= self.unionId and 0 ~= self.unionId then
        tb.c = self.unionId
    end
    if nil ~= self.eventTime and 0 ~= self.eventTime then
        tb.d = self.eventTime
    end
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.e = self.userId
    end
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.f = self.nickName
    end
    if nil ~= self.optionUserId and string.len(self.optionUserId) > 0 then
        tb.g = self.optionUserId
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.h = self.gender
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.i = self.level
    end
    tb.j = self.userDress:Encode()
    if nil ~= self.memberJob and 0 ~= self.memberJob then
        tb.k = self.memberJob
    end
    return tb
end

function MsgType.UnionMsgData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.unionMsgType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.unionId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.eventTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.userId = tostring(data.e)
    end
    if nil ~= data.f then
        self.nickName = tostring(data.f)
    end
    if nil ~= data.g then
        self.optionUserId = tostring(data.g)
    end
    if nil ~= data.h then
        self.gender = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.level = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.userDress:Decode(data.j)
    end
    if nil ~= data.k then
        self.memberJob = tonumber(data.k) or 0
    end
    return self
end

function MsgType.UnionMsgData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.UnionMsgData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.GuildData = {
    guildName = "",
    guildLevel = 0
}
MsgType.GuildData.__index = MsgType.GuildData

function MsgType.GuildData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.GuildData:Encode()
    local tb = {}
    if nil ~= self.guildName and string.len(self.guildName) > 0 then
        tb.b = self.guildName
    end
    if nil ~= self.guildLevel and 0 ~= self.guildLevel then
        tb.c = self.guildLevel
    end
    return tb
end

function MsgType.GuildData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.guildName = tostring(data.b)
    end
    if nil ~= data.c then
        self.guildLevel = tonumber(data.c) or 0
    end
    return self
end

function MsgType.GuildData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.GuildData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.EDesignState = {
    Idle = 0,
    Upgrading = 1,
    Finished = 2,
    InStore = 3
}

MsgType.EDesignType = {
    Wall = 1,
    Floor = 2,
    Carpet = 3,
    WallDecoration = 4,
    InsideDecoration = 5,
    Counter = 6,
    Shelf = 7,
    StoreBasket = 8,
    ResBasket = 9,
    OutsideDecoration = 10,
    PetFurniture = 11
}

MsgType.EShelfType = {
    Firearm = 1,
    Weapons = 2,
    Armor = 3,
    Item = 4
}

MsgType.EResBasketType = {
    Iron = 1,
    Wood = 2,
    Leather = 3,
    Herbs = 4,
    Steel = 5,
    Hardwood = 6,
    Cloth = 7,
    Oil = 8,
    Jewel = 9,
    Ether = 10
}

MsgType.DesignData = {
    shopLevel = 0,
    shopState = 0, --enum EDesignState
    shopStateRemainTime = 0
}
MsgType.DesignData.__index = MsgType.DesignData

function MsgType.DesignData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.DesignData:Encode()
    local tb = {}
    if nil ~= self.shopLevel and 0 ~= self.shopLevel then
        tb.b = self.shopLevel
    end
    if nil ~= self.shopState and 0 ~= self.shopState then
        tb.c = self.shopState
    end
    if nil ~= self.shopStateRemainTime and 0 ~= self.shopStateRemainTime then
        tb.d = self.shopStateRemainTime
    end
    return tb
end

function MsgType.DesignData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.shopLevel = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.shopState = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.shopStateRemainTime = tonumber(data.d) or 0
    end
    return self
end

function MsgType.DesignData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.DesignData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.FreeData = {
    freeDesignBuyCount = 0,
    freeHeroBuyCount = 0,
    freeEquipImproveCount = 0,
    freeExploreImmediateCount = 0
}
MsgType.FreeData.__index = MsgType.FreeData

function MsgType.FreeData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.FreeData:Encode()
    local tb = {}
    if nil ~= self.freeDesignBuyCount and 0 ~= self.freeDesignBuyCount then
        tb.b = self.freeDesignBuyCount
    end
    if nil ~= self.freeHeroBuyCount and 0 ~= self.freeHeroBuyCount then
        tb.c = self.freeHeroBuyCount
    end
    if nil ~= self.freeEquipImproveCount and 0 ~= self.freeEquipImproveCount then
        tb.d = self.freeEquipImproveCount
    end
    if nil ~= self.freeExploreImmediateCount and 0 ~= self.freeExploreImmediateCount then
        tb.e = self.freeExploreImmediateCount
    end
    return tb
end

function MsgType.FreeData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.freeDesignBuyCount = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.freeHeroBuyCount = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.freeEquipImproveCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.freeExploreImmediateCount = tonumber(data.e) or 0
    end
    return self
end

function MsgType.FreeData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.FreeData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.EItemType = {
    Gold = 1,
    Gem = 2,
    Energy = 3,
    Piece = 4,
    Production = 5,
    CopyItem = 6,
    Bag = 7,
    Chest = 8,
    Key = 9,
    Stone = 10,
    City = 11,
    WarriorCoin = 12,
    Hero = 13,
    Worker = 14,
    SpecialEquipItem = 15,
    FixedEquipItem = 16,
    LotteryItem = 17,
    HeroExpCard = 18,
    HeroChangeJobCard = 19,
    ExploreTimeItem = 20,
    ExploreAddDropItem = 21,
    ExploreAddAtkItem = 22,
    HeroRestResetItem = 23,
    ExploreAddExpItem = 24,
    FixEquipItem = 25,
    Equip = 26,
    Active = 27,
    GiftPack = 28,
    UnionCoin = 29,
    UnionPoint = 30,
    UnionPrestige = 31,
    Furniture = 40,
    UserDress = 41,
    HeroJob1SSR = 42,
    MakeSlotCount = 43,
    ExploreSlotCount = 44,
    ShopLevel = 45,
    HeroSlotCount = 46,
    SaleSlotCount = 47,
    OperatingActivityCoin = 48,
    EquipStartItem = 49,
    HeroStatusItem = 50,
    PetSkin = 51,
    GoldCastlePoint = 53,
    PointActivity2Point = 55
}

MsgType.OneRewardItem = {
    itemType = 0, --enum EItemType
    itemId = 0,
    quality = 0,
    count = 0,
    recycledItemType1 = 0, --enum EItemType
    recycledItemId1 = 0,
    recycledQuality1 = 0,
    recycledCount1 = 0,
    recycledItemType2 = 0, --enum EItemType
    recycledItemId2 = 0,
    recycledQuality2 = 0,
    recycledCount2 = 0
}
MsgType.OneRewardItem.__index = MsgType.OneRewardItem

function MsgType.OneRewardItem:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneRewardItem:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    if nil ~= self.quality and 0 ~= self.quality then
        tb.d = self.quality
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.e = self.count
    end
    if nil ~= self.recycledItemType1 and 0 ~= self.recycledItemType1 then
        tb.f = self.recycledItemType1
    end
    if nil ~= self.recycledItemId1 and 0 ~= self.recycledItemId1 then
        tb.g = self.recycledItemId1
    end
    if nil ~= self.recycledQuality1 and 0 ~= self.recycledQuality1 then
        tb.h = self.recycledQuality1
    end
    if nil ~= self.recycledCount1 and 0 ~= self.recycledCount1 then
        tb.i = self.recycledCount1
    end
    if nil ~= self.recycledItemType2 and 0 ~= self.recycledItemType2 then
        tb.j = self.recycledItemType2
    end
    if nil ~= self.recycledItemId2 and 0 ~= self.recycledItemId2 then
        tb.k = self.recycledItemId2
    end
    if nil ~= self.recycledQuality2 and 0 ~= self.recycledQuality2 then
        tb.l = self.recycledQuality2
    end
    if nil ~= self.recycledCount2 and 0 ~= self.recycledCount2 then
        tb.m = self.recycledCount2
    end
    return tb
end

function MsgType.OneRewardItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.quality = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.count = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.recycledItemType1 = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.recycledItemId1 = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.recycledQuality1 = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.recycledCount1 = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.recycledItemType2 = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.recycledItemId2 = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.recycledQuality2 = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.recycledCount2 = tonumber(data.m) or 0
    end
    return self
end

function MsgType.OneRewardItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneRewardItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_CommonReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_CommonReward.__index = MsgType.Response_User_CommonReward

function MsgType.Response_User_CommonReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_CommonReward:GetCmd()
    return MsgTypeCmd.Response_User_CommonReward_Cmd
end
function MsgType.Response_User_CommonReward:GetUrl()
    return "Response_User_CommonReward"
end
function MsgType.Response_User_CommonReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.f[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Request_User_ExchangeCodeReward = {
    msgSeq = 0,
    exchangeCode = ""
}
MsgType.Request_User_ExchangeCodeReward.__index = MsgType.Request_User_ExchangeCodeReward

function MsgType.Request_User_ExchangeCodeReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_ExchangeCodeReward:GetCmd()
    return MsgTypeCmd.Request_User_ExchangeCodeReward_Cmd
end
function MsgType.Request_User_ExchangeCodeReward:GetUrl()
    return "Request_User_ExchangeCodeReward"
end
function MsgType.Request_User_ExchangeCodeReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exchangeCode and string.len(self.exchangeCode) > 0 then
        tb.c = self.exchangeCode
    end
    return tb
end

function MsgType.Request_User_ExchangeCodeReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_ExchangeCodeReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_ExchangeCodeReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_ExchangeCodeReward.__index = MsgType.Response_User_ExchangeCodeReward

function MsgType.Response_User_ExchangeCodeReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_ExchangeCodeReward:GetCmd()
    return MsgTypeCmd.Response_User_ExchangeCodeReward_Cmd
end
function MsgType.Response_User_ExchangeCodeReward:GetUrl()
    return "Response_User_ExchangeCodeReward"
end
function MsgType.Response_User_ExchangeCodeReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.f[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.EPetState = {
    Lock = 1,
    Idle = 2,
    Store = 3
}

MsgType.OnePetInfo = {
    petUid = 0,
    furnitureUid = 0,
    petId = 0,
    petName = "",
    petType = 0,
    petLevel = 0,
    petState = 0, --enum EPetState
    petExp = 0,
    petEnergy = 0,
    petReputation = 0,
    petNextFeedTime = 0
}
MsgType.OnePetInfo.__index = MsgType.OnePetInfo

function MsgType.OnePetInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OnePetInfo:Encode()
    local tb = {}
    if nil ~= self.petUid and 0 ~= self.petUid then
        tb.b = self.petUid
    end
    if nil ~= self.furnitureUid and 0 ~= self.furnitureUid then
        tb.c = self.furnitureUid
    end
    if nil ~= self.petId and 0 ~= self.petId then
        tb.d = self.petId
    end
    if nil ~= self.petName and string.len(self.petName) > 0 then
        tb.e = self.petName
    end
    if nil ~= self.petType and 0 ~= self.petType then
        tb.f = self.petType
    end
    if nil ~= self.petLevel and 0 ~= self.petLevel then
        tb.g = self.petLevel
    end
    if nil ~= self.petState and 0 ~= self.petState then
        tb.h = self.petState
    end
    if nil ~= self.petExp and 0 ~= self.petExp then
        tb.i = self.petExp
    end
    if nil ~= self.petEnergy and 0 ~= self.petEnergy then
        tb.j = self.petEnergy
    end
    if nil ~= self.petReputation and 0 ~= self.petReputation then
        tb.k = self.petReputation
    end
    if nil ~= self.petNextFeedTime and 0 ~= self.petNextFeedTime then
        tb.l = self.petNextFeedTime
    end
    return tb
end

function MsgType.OnePetInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.petUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.furnitureUid = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.petId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.petName = tostring(data.e)
    end
    if nil ~= data.f then
        self.petType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.petLevel = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.petState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.petExp = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.petEnergy = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.petReputation = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.petNextFeedTime = tonumber(data.l) or 0
    end
    return self
end

function MsgType.OnePetInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OnePetInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_Data.__index = MsgType.Request_User_Data

function MsgType.Request_User_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_Data:GetCmd()
    return MsgTypeCmd.Request_User_Data_Cmd
end
function MsgType.Request_User_Data:GetUrl()
    return "Request_User_Data"
end
function MsgType.Request_User_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userData = {},
    userExtData = {},
    designData = {},
    unionData = {},
    freeData = {},
    vipData = {},
    petInfo = {},
    mainPetUid = 0
}
MsgType.Response_User_Data.__index = MsgType.Response_User_Data
setmetatable(MsgType.Response_User_Data.userData, MsgType.UserData)
setmetatable(MsgType.Response_User_Data.userExtData, MsgType.UserExtData)
setmetatable(MsgType.Response_User_Data.designData, MsgType.DesignData)
setmetatable(MsgType.Response_User_Data.unionData, MsgType.UnionData)
setmetatable(MsgType.Response_User_Data.freeData, MsgType.FreeData)
setmetatable(MsgType.Response_User_Data.vipData, MsgType.VIPInfo)
setmetatable(MsgType.Response_User_Data.petInfo, MsgType.OnePetInfo)

function MsgType.Response_User_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userData = MsgType.UserData:New()
    tb.userExtData = MsgType.UserExtData:New()
    tb.designData = MsgType.DesignData:New()
    tb.unionData = MsgType.UnionData:New()
    tb.freeData = MsgType.FreeData:New()
    tb.vipData = MsgType.VIPInfo:New()
    tb.petInfo = MsgType.OnePetInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_Data:GetCmd()
    return MsgTypeCmd.Response_User_Data_Cmd
end
function MsgType.Response_User_Data:GetUrl()
    return "Response_User_Data"
end
function MsgType.Response_User_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userData:Decode(data.f)
    end
    if nil ~= data.g then
        self.userExtData:Decode(data.g)
    end
    if nil ~= data.h then
        self.designData:Decode(data.h)
    end
    if nil ~= data.i then
        self.unionData:Decode(data.i)
    end
    if nil ~= data.j then
        self.freeData:Decode(data.j)
    end
    if nil ~= data.k then
        self.vipData:Decode(data.k)
    end
    if nil ~= data.l then
        self.petInfo:Decode(data.l)
    end
    if nil ~= data.m then
        self.mainPetUid = tonumber(data.m) or 0
    end
    return self
end


MsgType.EItemLogReason = {
    Guide = 1,
    GuideReturn = 2,
    GuideSkip = 3,
    GmCommand = 4,
    ChangeName = 5,
    ProductionResourceBuy = 6,
    MailReward = 7,
    UnionCreate = 8,
    ShopperLevelUp = 9,
    BuyDress = 10,
    BagDel = 11,
    ItemUse = 12,
    GiftPack = 13,
    PiggyBank = 14,
    ExploreTimeItem = 15,
    ExploreAddDropItem = 16,
    ExploreAddAtkItem = 17,
    ExploreAddExpItem = 18,
    Prize = 19,
    Pay = 20,
    MainTask = 21,
    MainTask2 = 22,
    Pet = 23,
    PetSlot = 24,
    PetBuy = 25,
    GuideTaskReward = 26,
    GuideTaskShopperAward = 27,
    TriggerGuideEffect = 28,
    ShopUpgrade = 102,
    CounterUpgrade = 103,
    StoreBasketUpgrade = 104,
    ResBasketUpgrade = 105,
    ShelfUpgrade = 106,
    DesignCounterSpeedUp = 107,
    DesignStoreBasketSpeedUp = 108,
    DesignResBasketSpeedUp = 109,
    DesignShelfSpeedUp = 110,
    EquipMaking = 200,
    EquipProgressLevelUp = 201,
    EquipMakeImprove = 202,
    EquipInfoActivate = 203,
    BuySlot = 204,
    EquipMakingFaster = 205,
    BuyFloor = 302,
    BuyFurniture = 303,
    BuyWall = 304,
    DailyTask = 400,
    Achievement = 401,
    AchievementRoad = 402,
    SevenDayTask = 403,
    SevenDayTaskList = 404,
    ShopperDiscount = 500,
    ShopperDouble = 501,
    ShopperChat = 502,
    ShopperRefuse = 503,
    ShopperCheckout = 504,
    ShopperRecommend = 505,
    ActiveReward = 506,
    ShopperEnergy = 507,
    HeroFieldUnlock = 600,
    HeroListRefresh = 601,
    HeroBuy = 602,
    HeroEquipOn = 603,
    HeroEquipOff = 604,
    HeroWarriorRankUp = 605,
    HeroRecover = 606,
    HeroFire = 607,
    HeroEquipFix = 608,
    UnlockWorker = 609,
    HeroTransfer = 610,
    HeroExchange = 611,
    ActivityStoreRefresh = 650,
    ActivityStoreBuy = 651,
    TransactionBoothItem = 700,
    TransactionBoothItemOff = 701,
    TransactionBuy = 702,
    TransactionSell = 703,
    TransactionManualBuy = 704,
    TransactionManualSell = 705,
    TreasureBoxOpen = 706,
    ExploreFieldUnlock = 800,
    ExplorePass = 801,
    ExploreUnlock = 802,
    ExploreImmediately = 803,
    ActivityDailyGiftReward = 900,
    BuildCost = 1000,
    RubbishClaimed = 1100,
    UnionHelpGem = 1200,
    UnionTask = 1201,
    UnionHelp = 1202,
    AccountBinding = 1300
}

MsgType.EUserDataChangeType = {
    Exp = 1,
    Level = 2,
    Gold = 3,
    Gem = 4,
    Energy = 5,
    EnergyLimit = 6,
    Drawing = 7,
    Worth = 8,
    Prosperity = 9,
    MasterCount = 10,
    BagLimit = 11,
    PileLimit = 12,
    FreeDesignBuyCount = 13,
    FreeHeroBuyCount = 14,
    FreeEquipImproveCount = 15,
    FreeExploreImmediateCount = 16,
    Invest = 17,
    MemberJob = 18,
    UnionCoin = 19,
    Pet = 20,
    UnionHelpCount = 21,
    UnionTaskCrownCount = 22,
    ShopperLevelUp = 23
}

MsgType.EUserProsperityType = {
    ShelfUpgrade1 = 1,
    ShelfUpgrade2 = 2,
    ShopperLimit = 3,
    ArmorSell = 4,
    WeaponSell = 5,
    OtherSell = 6
}

MsgType.Response_User_DataChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    dataType = 0, --enum EUserDataChangeType
    oldValue = 0,
    changeValue = 0,
    newValue = 0,
    reason = 0 --enum EItemLogReason
}
MsgType.Response_User_DataChange.__index = MsgType.Response_User_DataChange

function MsgType.Response_User_DataChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_DataChange:GetCmd()
    return MsgTypeCmd.Response_User_DataChange_Cmd
end
function MsgType.Response_User_DataChange:GetUrl()
    return "Response_User_DataChange"
end
function MsgType.Response_User_DataChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.dataType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.oldValue = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.changeValue = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.newValue = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.reason = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_User_ChangeName = {
    msgSeq = 0,
    nickName = ""
}
MsgType.Request_User_ChangeName.__index = MsgType.Request_User_ChangeName

function MsgType.Request_User_ChangeName:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_ChangeName:GetCmd()
    return MsgTypeCmd.Request_User_ChangeName_Cmd
end
function MsgType.Request_User_ChangeName:GetUrl()
    return "Request_User_ChangeName"
end
function MsgType.Request_User_ChangeName:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.c = self.nickName
    end
    return tb
end

function MsgType.Request_User_ChangeName:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_ChangeName:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_ChangeName = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    nickName = ""
}
MsgType.Response_User_ChangeName.__index = MsgType.Response_User_ChangeName

function MsgType.Response_User_ChangeName:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_ChangeName:GetCmd()
    return MsgTypeCmd.Response_User_ChangeName_Cmd
end
function MsgType.Response_User_ChangeName:GetUrl()
    return "Response_User_ChangeName"
end
function MsgType.Response_User_ChangeName:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.nickName = tostring(data.f)
    end
    return self
end


MsgType.Request_User_DressList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_DressList.__index = MsgType.Request_User_DressList

function MsgType.Request_User_DressList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_DressList:GetCmd()
    return MsgTypeCmd.Request_User_DressList_Cmd
end
function MsgType.Request_User_DressList:GetUrl()
    return "Request_User_DressList"
end
function MsgType.Request_User_DressList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_DressList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_DressList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_DressList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    dressList = {} -- array of number
}
MsgType.Response_User_DressList.__index = MsgType.Response_User_DressList

function MsgType.Response_User_DressList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.dressList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_DressList:GetCmd()
    return MsgTypeCmd.Response_User_DressList_Cmd
end
function MsgType.Response_User_DressList:GetUrl()
    return "Response_User_DressList"
end
function MsgType.Response_User_DressList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.dressList[i] = tonumber(data.f[i])
        end
    end
    return self
end


MsgType.Request_User_BuyDress = {
    msgSeq = 0,
    dressIdList = {} -- array of number
}
MsgType.Request_User_BuyDress.__index = MsgType.Request_User_BuyDress

function MsgType.Request_User_BuyDress:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.dressIdList = {}
    return tb
end

function MsgType.Request_User_BuyDress:GetCmd()
    return MsgTypeCmd.Request_User_BuyDress_Cmd
end
function MsgType.Request_User_BuyDress:GetUrl()
    return "Request_User_BuyDress"
end
function MsgType.Request_User_BuyDress:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.dressIdList and #self.dressIdList > 0 then
        for i=1, #self.dressIdList do
            tb.e[i] = tonumber(self.dressIdList[i])
        end
    end
    return tb
end

function MsgType.Request_User_BuyDress:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_BuyDress:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_BuyDress = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    dressIdList = {}, -- array of number
    dressList = {} -- array of number
}
MsgType.Response_User_BuyDress.__index = MsgType.Response_User_BuyDress

function MsgType.Response_User_BuyDress:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.dressIdList = {}
    tb.dressList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_BuyDress:GetCmd()
    return MsgTypeCmd.Response_User_BuyDress_Cmd
end
function MsgType.Response_User_BuyDress:GetUrl()
    return "Response_User_BuyDress"
end
function MsgType.Response_User_BuyDress:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.dressIdList[i] = tonumber(data.f[i])
        end
    end
    if nil ~= data.g and #data.g > 0 then
        for i=1, #data.g do
            self.dressList[i] = tonumber(data.g[i])
        end
    end
    return self
end


MsgType.Request_User_Custom = {
    msgSeq = 0,
    gender = 0, --enum EGender
    userDress = {}
}
MsgType.Request_User_Custom.__index = MsgType.Request_User_Custom
setmetatable(MsgType.Request_User_Custom.userDress, MsgType.RoleDress)

function MsgType.Request_User_Custom:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.Request_User_Custom:GetCmd()
    return MsgTypeCmd.Request_User_Custom_Cmd
end
function MsgType.Request_User_Custom:GetUrl()
    return "Request_User_Custom"
end
function MsgType.Request_User_Custom:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.gender and 0 ~= self.gender then
        tb.c = self.gender
    end
    tb.d = self.userDress:Encode()
    return tb
end

function MsgType.Request_User_Custom:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_Custom:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_Custom = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    gender = 0, --enum EGender
    userDress = {}
}
MsgType.Response_User_Custom.__index = MsgType.Response_User_Custom
setmetatable(MsgType.Response_User_Custom.userDress, MsgType.RoleDress)

function MsgType.Response_User_Custom:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userDress = MsgType.RoleDress:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_Custom:GetCmd()
    return MsgTypeCmd.Response_User_Custom_Cmd
end
function MsgType.Response_User_Custom:GetUrl()
    return "Response_User_Custom"
end
function MsgType.Response_User_Custom:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.gender = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userDress:Decode(data.g)
    end
    return self
end


MsgType.Request_User_Detail = {
    msgSeq = 0,
    userId = ""
}
MsgType.Request_User_Detail.__index = MsgType.Request_User_Detail

function MsgType.Request_User_Detail:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_Detail:GetCmd()
    return MsgTypeCmd.Request_User_Detail_Cmd
end
function MsgType.Request_User_Detail:GetUrl()
    return "Request_User_Detail"
end
function MsgType.Request_User_Detail:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.c = self.userId
    end
    return tb
end

function MsgType.Request_User_Detail:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_Detail:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_Detail = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userId = "",
    unionId = "",
    userData = {},
    guildData = {},
    shopData = {},
    floorData = {},
    wallData = {},
    furnitureList = {}, -- array of MsgType.OneFurniture
    petList = {} -- array of MsgType.OnePetInfo
}
MsgType.Response_User_Detail.__index = MsgType.Response_User_Detail
setmetatable(MsgType.Response_User_Detail.userData, MsgType.UserData)
setmetatable(MsgType.Response_User_Detail.guildData, MsgType.GuildData)
setmetatable(MsgType.Response_User_Detail.shopData, MsgType.ShopData)
setmetatable(MsgType.Response_User_Detail.floorData, MsgType.FloorData)
setmetatable(MsgType.Response_User_Detail.wallData, MsgType.WallData)

function MsgType.Response_User_Detail:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userData = MsgType.UserData:New()
    tb.guildData = MsgType.GuildData:New()
    tb.shopData = MsgType.ShopData:New()
    tb.floorData = MsgType.FloorData:New()
    tb.wallData = MsgType.WallData:New()
    tb.furnitureList = {}
    tb.petList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_Detail:GetCmd()
    return MsgTypeCmd.Response_User_Detail_Cmd
end
function MsgType.Response_User_Detail:GetUrl()
    return "Response_User_Detail"
end
function MsgType.Response_User_Detail:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userId = tostring(data.f)
    end
    if nil ~= data.g then
        self.unionId = tostring(data.g)
    end
    if nil ~= data.h then
        self.userData:Decode(data.h)
    end
    if nil ~= data.i then
        self.guildData:Decode(data.i)
    end
    if nil ~= data.j then
        self.shopData:Decode(data.j)
    end
    if nil ~= data.k then
        self.floorData:Decode(data.k)
    end
    if nil ~= data.l then
        self.wallData:Decode(data.l)
    end
    if nil ~= data.m then
        for i=1, #data.m do
            local tmpFurnitureListObj = MsgType.OneFurniture:New()
            tmpFurnitureListObj:Decode(data.m[i])
            self.furnitureList[i] = tmpFurnitureListObj
        end
    end
    if nil ~= data.n then
        for i=1, #data.n do
            local tmpPetListObj = MsgType.OnePetInfo:New()
            tmpPetListObj:Decode(data.n[i])
            self.petList[i] = tmpPetListObj
        end
    end
    return self
end


MsgType.Request_User_SetGuide = {
    msgSeq = 0,
    guideId = 0
}
MsgType.Request_User_SetGuide.__index = MsgType.Request_User_SetGuide

function MsgType.Request_User_SetGuide:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_SetGuide:GetCmd()
    return MsgTypeCmd.Request_User_SetGuide_Cmd
end
function MsgType.Request_User_SetGuide:GetUrl()
    return "Request_User_SetGuide"
end
function MsgType.Request_User_SetGuide:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.guideId and 0 ~= self.guideId then
        tb.c = self.guideId
    end
    return tb
end

function MsgType.Request_User_SetGuide:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_SetGuide:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_SetGuide = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    guideId = 0
}
MsgType.Response_User_SetGuide.__index = MsgType.Response_User_SetGuide

function MsgType.Response_User_SetGuide:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_SetGuide:GetCmd()
    return MsgTypeCmd.Response_User_SetGuide_Cmd
end
function MsgType.Response_User_SetGuide:GetUrl()
    return "Response_User_SetGuide"
end
function MsgType.Response_User_SetGuide:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.guideId = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_User_SkipGuide = {
    msgSeq = 0,
    guideId = 0
}
MsgType.Request_User_SkipGuide.__index = MsgType.Request_User_SkipGuide

function MsgType.Request_User_SkipGuide:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_SkipGuide:GetCmd()
    return MsgTypeCmd.Request_User_SkipGuide_Cmd
end
function MsgType.Request_User_SkipGuide:GetUrl()
    return "Request_User_SkipGuide"
end
function MsgType.Request_User_SkipGuide:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.guideId and 0 ~= self.guideId then
        tb.c = self.guideId
    end
    return tb
end

function MsgType.Request_User_SkipGuide:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_SkipGuide:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_SkipGuide = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    guideId = 0
}
MsgType.Response_User_SkipGuide.__index = MsgType.Response_User_SkipGuide

function MsgType.Response_User_SkipGuide:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_SkipGuide:GetCmd()
    return MsgTypeCmd.Response_User_SkipGuide_Cmd
end
function MsgType.Response_User_SkipGuide:GetUrl()
    return "Response_User_SkipGuide"
end
function MsgType.Response_User_SkipGuide:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.guideId = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_User_BindingQuery = {
    msgSeq = 0,
    platform = 0, --enum EPlatform
    osType = 0, --enum EOsType
    platformUid = "",
    platformToken = ""
}
MsgType.Request_User_BindingQuery.__index = MsgType.Request_User_BindingQuery

function MsgType.Request_User_BindingQuery:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_BindingQuery:GetCmd()
    return MsgTypeCmd.Request_User_BindingQuery_Cmd
end
function MsgType.Request_User_BindingQuery:GetUrl()
    return "Request_User_BindingQuery"
end
function MsgType.Request_User_BindingQuery:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.platform and 0 ~= self.platform then
        tb.c = self.platform
    end
    if nil ~= self.osType and 0 ~= self.osType then
        tb.d = self.osType
    end
    if nil ~= self.platformUid and string.len(self.platformUid) > 0 then
        tb.e = self.platformUid
    end
    if nil ~= self.platformToken and string.len(self.platformToken) > 0 then
        tb.f = self.platformToken
    end
    return tb
end

function MsgType.Request_User_BindingQuery:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_BindingQuery:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_BindingQuery = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    isBinding = 0,
    alreadyBindingUser = {},
    alreadyBindingAccountToken = ""
}
MsgType.Response_User_BindingQuery.__index = MsgType.Response_User_BindingQuery
setmetatable(MsgType.Response_User_BindingQuery.alreadyBindingUser, MsgType.UserData)

function MsgType.Response_User_BindingQuery:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.alreadyBindingUser = MsgType.UserData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_BindingQuery:GetCmd()
    return MsgTypeCmd.Response_User_BindingQuery_Cmd
end
function MsgType.Response_User_BindingQuery:GetUrl()
    return "Response_User_BindingQuery"
end
function MsgType.Response_User_BindingQuery:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.isBinding = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.alreadyBindingUser:Decode(data.g)
    end
    if nil ~= data.h then
        self.alreadyBindingAccountToken = tostring(data.h)
    end
    return self
end


MsgType.Request_User_Binding = {
    msgSeq = 0,
    platform = 0, --enum EPlatform
    osType = 0, --enum EOsType
    platformUid = "",
    platformToken = "",
    platformUserName = ""
}
MsgType.Request_User_Binding.__index = MsgType.Request_User_Binding

function MsgType.Request_User_Binding:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_Binding:GetCmd()
    return MsgTypeCmd.Request_User_Binding_Cmd
end
function MsgType.Request_User_Binding:GetUrl()
    return "Request_User_Binding"
end
function MsgType.Request_User_Binding:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.platform and 0 ~= self.platform then
        tb.c = self.platform
    end
    if nil ~= self.osType and 0 ~= self.osType then
        tb.d = self.osType
    end
    if nil ~= self.platformUid and string.len(self.platformUid) > 0 then
        tb.e = self.platformUid
    end
    if nil ~= self.platformToken and string.len(self.platformToken) > 0 then
        tb.f = self.platformToken
    end
    if nil ~= self.platformUserName and string.len(self.platformUserName) > 0 then
        tb.g = self.platformUserName
    end
    return tb
end

function MsgType.Request_User_Binding:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_Binding:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_Binding = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    bindingType = 0, --enum EBindingType
    bindingId = "",
    bindingClaimState = 0
}
MsgType.Response_User_Binding.__index = MsgType.Response_User_Binding

function MsgType.Response_User_Binding:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_Binding:GetCmd()
    return MsgTypeCmd.Response_User_Binding_Cmd
end
function MsgType.Response_User_Binding:GetUrl()
    return "Response_User_Binding"
end
function MsgType.Response_User_Binding:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.bindingType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.bindingId = tostring(data.g)
    end
    if nil ~= data.h then
        self.bindingClaimState = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_User_BindingClaim = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_BindingClaim.__index = MsgType.Request_User_BindingClaim

function MsgType.Request_User_BindingClaim:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_BindingClaim:GetCmd()
    return MsgTypeCmd.Request_User_BindingClaim_Cmd
end
function MsgType.Request_User_BindingClaim:GetUrl()
    return "Request_User_BindingClaim"
end
function MsgType.Request_User_BindingClaim:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_BindingClaim:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_BindingClaim:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_BindingClaim = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    bindingType = 0, --enum EBindingType
    bindingId = "",
    bindingClaimState = 0
}
MsgType.Response_User_BindingClaim.__index = MsgType.Response_User_BindingClaim

function MsgType.Response_User_BindingClaim:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_BindingClaim:GetCmd()
    return MsgTypeCmd.Response_User_BindingClaim_Cmd
end
function MsgType.Response_User_BindingClaim:GetUrl()
    return "Response_User_BindingClaim"
end
function MsgType.Response_User_BindingClaim:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.bindingType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.bindingId = tostring(data.g)
    end
    if nil ~= data.h then
        self.bindingClaimState = tonumber(data.h) or 0
    end
    return self
end


MsgType.EMainTaskType = {
    MakeEquip = 1,
    FurnitureLevelUp = 2,
    FurnitureCount = 3,
    HireWorker = 4,
    HireHero = 5,
    HeroTransfer = 6,
    HeroLevel = 7,
    GoldDeal = 8,
    HeroEquip = 9,
    ExploreHero = 10,
    ExploreLevel = 11,
    ShopLevelUp = 12,
    ExploreID = 13,
    OpenBox = 14,
    ShopperLevel = 15,
    InvestNum = 16,
    SoldEquip = 17,
    SoldEquipRaisePrice = 18,
    SoldEquipDiscount = 19,
    InvestBuilding = 20
}

MsgType.EMainTaskState = {
    Idle = 1,
    CanReward = 2,
    Rewarded = 3
}

MsgType.OneMainTask = {
    taskId = 0,
    taskParam = 0,
    taskLimit = 0,
    taskState = 0 --enum EMainTaskState
}
MsgType.OneMainTask.__index = MsgType.OneMainTask

function MsgType.OneMainTask:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneMainTask:Encode()
    local tb = {}
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.b = self.taskId
    end
    if nil ~= self.taskParam and 0 ~= self.taskParam then
        tb.c = self.taskParam
    end
    if nil ~= self.taskLimit and 0 ~= self.taskLimit then
        tb.d = self.taskLimit
    end
    if nil ~= self.taskState and 0 ~= self.taskState then
        tb.e = self.taskState
    end
    return tb
end

function MsgType.OneMainTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.taskId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskParam = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskLimit = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.taskState = tonumber(data.e) or 0
    end
    return self
end

function MsgType.OneMainTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneMainTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_MainTask = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_MainTask.__index = MsgType.Request_User_MainTask

function MsgType.Request_User_MainTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_MainTask:GetCmd()
    return MsgTypeCmd.Request_User_MainTask_Cmd
end
function MsgType.Request_User_MainTask:GetUrl()
    return "Request_User_MainTask"
end
function MsgType.Request_User_MainTask:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_MainTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_MainTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_MainTask = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    mainTaskFlag = 0,
    taskIndex = 0,
    task = {},
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_MainTask.__index = MsgType.Response_User_MainTask
setmetatable(MsgType.Response_User_MainTask.task, MsgType.OneMainTask)

function MsgType.Response_User_MainTask:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.task = MsgType.OneMainTask:New()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_MainTask:GetCmd()
    return MsgTypeCmd.Response_User_MainTask_Cmd
end
function MsgType.Response_User_MainTask:GetUrl()
    return "Response_User_MainTask"
end
function MsgType.Response_User_MainTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.mainTaskFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.taskIndex = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.task:Decode(data.h)
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Response_User_MainTaskChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskIndex = 0,
    task = {},
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_MainTaskChange.__index = MsgType.Response_User_MainTaskChange
setmetatable(MsgType.Response_User_MainTaskChange.task, MsgType.OneMainTask)

function MsgType.Response_User_MainTaskChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.task = MsgType.OneMainTask:New()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_MainTaskChange:GetCmd()
    return MsgTypeCmd.Response_User_MainTaskChange_Cmd
end
function MsgType.Response_User_MainTaskChange:GetUrl()
    return "Response_User_MainTaskChange"
end
function MsgType.Response_User_MainTaskChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.taskIndex = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.task:Decode(data.g)
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.h[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Request_User_MainTaskReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_MainTaskReward.__index = MsgType.Request_User_MainTaskReward

function MsgType.Request_User_MainTaskReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_MainTaskReward:GetCmd()
    return MsgTypeCmd.Request_User_MainTaskReward_Cmd
end
function MsgType.Request_User_MainTaskReward:GetUrl()
    return "Request_User_MainTaskReward"
end
function MsgType.Request_User_MainTaskReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_MainTaskReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_MainTaskReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_MainTaskReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    mainTaskFlag = 0,
    taskIndex = 0,
    task = {},
    rewardList = {}, -- array of MsgType.OneRewardItem
    nowTask = {},
    nowRewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_MainTaskReward.__index = MsgType.Response_User_MainTaskReward
setmetatable(MsgType.Response_User_MainTaskReward.task, MsgType.OneMainTask)
setmetatable(MsgType.Response_User_MainTaskReward.nowTask, MsgType.OneMainTask)

function MsgType.Response_User_MainTaskReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.task = MsgType.OneMainTask:New()
    tb.rewardList = {}
    tb.nowTask = MsgType.OneMainTask:New()
    tb.nowRewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_MainTaskReward:GetCmd()
    return MsgTypeCmd.Response_User_MainTaskReward_Cmd
end
function MsgType.Response_User_MainTaskReward:GetUrl()
    return "Response_User_MainTaskReward"
end
function MsgType.Response_User_MainTaskReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.mainTaskFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.taskIndex = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.task:Decode(data.h)
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        self.nowTask:Decode(data.j)
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpNowRewardListObj = MsgType.OneRewardItem:New()
            tmpNowRewardListObj:Decode(data.k[i])
            self.nowRewardList[i] = tmpNowRewardListObj
        end
    end
    return self
end


MsgType.OneTriggerGuide = {
    groupId = 0,
    groupFlag = 0,
    groupParam = 0
}
MsgType.OneTriggerGuide.__index = MsgType.OneTriggerGuide

function MsgType.OneTriggerGuide:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneTriggerGuide:Encode()
    local tb = {}
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.b = self.groupId
    end
    if nil ~= self.groupFlag and 0 ~= self.groupFlag then
        tb.c = self.groupFlag
    end
    if nil ~= self.groupParam and 0 ~= self.groupParam then
        tb.d = self.groupParam
    end
    return tb
end

function MsgType.OneTriggerGuide:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.groupId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.groupFlag = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.groupParam = tonumber(data.d) or 0
    end
    return self
end

function MsgType.OneTriggerGuide:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneTriggerGuide:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_TriggerGuide = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_TriggerGuide.__index = MsgType.Request_User_TriggerGuide

function MsgType.Request_User_TriggerGuide:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_TriggerGuide:GetCmd()
    return MsgTypeCmd.Request_User_TriggerGuide_Cmd
end
function MsgType.Request_User_TriggerGuide:GetUrl()
    return "Request_User_TriggerGuide"
end
function MsgType.Request_User_TriggerGuide:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_TriggerGuide:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_TriggerGuide:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_TriggerGuide = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    triggerGuideList = {} -- array of MsgType.OneTriggerGuide
}
MsgType.Response_User_TriggerGuide.__index = MsgType.Response_User_TriggerGuide

function MsgType.Response_User_TriggerGuide:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.triggerGuideList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_TriggerGuide:GetCmd()
    return MsgTypeCmd.Response_User_TriggerGuide_Cmd
end
function MsgType.Response_User_TriggerGuide:GetUrl()
    return "Response_User_TriggerGuide"
end
function MsgType.Response_User_TriggerGuide:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTriggerGuideListObj = MsgType.OneTriggerGuide:New()
            tmpTriggerGuideListObj:Decode(data.f[i])
            self.triggerGuideList[i] = tmpTriggerGuideListObj
        end
    end
    return self
end


MsgType.Request_User_CheckTriggerGuide = {
    msgSeq = 0,
    groupId = 0
}
MsgType.Request_User_CheckTriggerGuide.__index = MsgType.Request_User_CheckTriggerGuide

function MsgType.Request_User_CheckTriggerGuide:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_CheckTriggerGuide:GetCmd()
    return MsgTypeCmd.Request_User_CheckTriggerGuide_Cmd
end
function MsgType.Request_User_CheckTriggerGuide:GetUrl()
    return "Request_User_CheckTriggerGuide"
end
function MsgType.Request_User_CheckTriggerGuide:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.c = self.groupId
    end
    return tb
end

function MsgType.Request_User_CheckTriggerGuide:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_CheckTriggerGuide:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_CheckTriggerGuide = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    triggerGuideData = {}
}
MsgType.Response_User_CheckTriggerGuide.__index = MsgType.Response_User_CheckTriggerGuide
setmetatable(MsgType.Response_User_CheckTriggerGuide.triggerGuideData, MsgType.OneTriggerGuide)

function MsgType.Response_User_CheckTriggerGuide:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.triggerGuideData = MsgType.OneTriggerGuide:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_CheckTriggerGuide:GetCmd()
    return MsgTypeCmd.Response_User_CheckTriggerGuide_Cmd
end
function MsgType.Response_User_CheckTriggerGuide:GetUrl()
    return "Response_User_CheckTriggerGuide"
end
function MsgType.Response_User_CheckTriggerGuide:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.triggerGuideData:Decode(data.f)
    end
    return self
end


MsgType.Request_User_TriggerGuideFurnitureUpgrade = {
    msgSeq = 0,
    groupId = 0,
    furnitureUid = 0,
    designType = 0
}
MsgType.Request_User_TriggerGuideFurnitureUpgrade.__index = MsgType.Request_User_TriggerGuideFurnitureUpgrade

function MsgType.Request_User_TriggerGuideFurnitureUpgrade:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_TriggerGuideFurnitureUpgrade:GetCmd()
    return MsgTypeCmd.Request_User_TriggerGuideFurnitureUpgrade_Cmd
end
function MsgType.Request_User_TriggerGuideFurnitureUpgrade:GetUrl()
    return "Request_User_TriggerGuideFurnitureUpgrade"
end
function MsgType.Request_User_TriggerGuideFurnitureUpgrade:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.c = self.groupId
    end
    if nil ~= self.furnitureUid and 0 ~= self.furnitureUid then
        tb.d = self.furnitureUid
    end
    if nil ~= self.designType and 0 ~= self.designType then
        tb.e = self.designType
    end
    return tb
end

function MsgType.Request_User_TriggerGuideFurnitureUpgrade:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_TriggerGuideFurnitureUpgrade:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_TriggerGuideFurnitureUpgrade = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    triggerGuideData = {},
    furnitureInfo = {}
}
MsgType.Response_User_TriggerGuideFurnitureUpgrade.__index = MsgType.Response_User_TriggerGuideFurnitureUpgrade
setmetatable(MsgType.Response_User_TriggerGuideFurnitureUpgrade.triggerGuideData, MsgType.OneTriggerGuide)
setmetatable(MsgType.Response_User_TriggerGuideFurnitureUpgrade.furnitureInfo, MsgType.OneFurniture)

function MsgType.Response_User_TriggerGuideFurnitureUpgrade:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.triggerGuideData = MsgType.OneTriggerGuide:New()
    tb.furnitureInfo = MsgType.OneFurniture:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_TriggerGuideFurnitureUpgrade:GetCmd()
    return MsgTypeCmd.Response_User_TriggerGuideFurnitureUpgrade_Cmd
end
function MsgType.Response_User_TriggerGuideFurnitureUpgrade:GetUrl()
    return "Response_User_TriggerGuideFurnitureUpgrade"
end
function MsgType.Response_User_TriggerGuideFurnitureUpgrade:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.triggerGuideData:Decode(data.f)
    end
    if nil ~= data.g then
        self.furnitureInfo:Decode(data.g)
    end
    return self
end


MsgType.EGuideTaskType = {
    MakeEquip = 1,
    FurnitureLevelUp = 2,
    FurnitureCount = 3,
    HireWorker = 4,
    HeroEquip = 9,
    ExploreHero = 10,
    ExploreLevel = 11,
    ShopLevelUp = 12,
    SoldEquipRaisePrice = 18,
    SoldEquipDiscount = 19,
    FurnitureBuyAny = 20,
    FurnitureLevelUpAny = 21,
    FurnitureBuyDesignAny = 22,
    FreeChat = 23
}

MsgType.EGuideTaskState = {
    Idle = 1,
    Done = 2
}

MsgType.EGuideTaskGroupState = {
    Idle = 1,
    CanReward = 2,
    Rewarded = 3,
    Done = 4
}

MsgType.OneGuideTask = {
    taskId = 0,
    taskGroupId = 0,
    taskParam = 0,
    taskLimit = 0,
    taskState = 0 --enum EGuideTaskState
}
MsgType.OneGuideTask.__index = MsgType.OneGuideTask

function MsgType.OneGuideTask:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneGuideTask:Encode()
    local tb = {}
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.b = self.taskId
    end
    if nil ~= self.taskGroupId and 0 ~= self.taskGroupId then
        tb.c = self.taskGroupId
    end
    if nil ~= self.taskParam and 0 ~= self.taskParam then
        tb.d = self.taskParam
    end
    if nil ~= self.taskLimit and 0 ~= self.taskLimit then
        tb.e = self.taskLimit
    end
    if nil ~= self.taskState and 0 ~= self.taskState then
        tb.f = self.taskState
    end
    return tb
end

function MsgType.OneGuideTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.taskId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskGroupId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskParam = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.taskLimit = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.taskState = tonumber(data.f) or 0
    end
    return self
end

function MsgType.OneGuideTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneGuideTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_GuideTask = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_GuideTask.__index = MsgType.Request_User_GuideTask

function MsgType.Request_User_GuideTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_GuideTask:GetCmd()
    return MsgTypeCmd.Request_User_GuideTask_Cmd
end
function MsgType.Request_User_GuideTask:GetUrl()
    return "Request_User_GuideTask"
end
function MsgType.Request_User_GuideTask:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_GuideTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_GuideTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_GuideTask = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    guideTaskFlag = 0,
    taskIndex = 0,
    guideTaskState = 0, --enum EGuideTaskGroupState
    taskList = {}, -- array of MsgType.OneGuideTask
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_GuideTask.__index = MsgType.Response_User_GuideTask

function MsgType.Response_User_GuideTask:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_GuideTask:GetCmd()
    return MsgTypeCmd.Response_User_GuideTask_Cmd
end
function MsgType.Response_User_GuideTask:GetUrl()
    return "Response_User_GuideTask"
end
function MsgType.Response_User_GuideTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.guideTaskFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.taskIndex = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.guideTaskState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpTaskListObj = MsgType.OneGuideTask:New()
            tmpTaskListObj:Decode(data.i[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.j[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Response_User_GuideTaskChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskIndex = 0,
    guideTaskState = 0, --enum EGuideTaskGroupState
    taskList = {}, -- array of MsgType.OneGuideTask
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_GuideTaskChange.__index = MsgType.Response_User_GuideTaskChange

function MsgType.Response_User_GuideTaskChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_GuideTaskChange:GetCmd()
    return MsgTypeCmd.Response_User_GuideTaskChange_Cmd
end
function MsgType.Response_User_GuideTaskChange:GetUrl()
    return "Response_User_GuideTaskChange"
end
function MsgType.Response_User_GuideTaskChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.taskIndex = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.guideTaskState = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpTaskListObj = MsgType.OneGuideTask:New()
            tmpTaskListObj:Decode(data.h[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Request_User_GuideTaskReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_GuideTaskReward.__index = MsgType.Request_User_GuideTaskReward

function MsgType.Request_User_GuideTaskReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_GuideTaskReward:GetCmd()
    return MsgTypeCmd.Request_User_GuideTaskReward_Cmd
end
function MsgType.Request_User_GuideTaskReward:GetUrl()
    return "Request_User_GuideTaskReward"
end
function MsgType.Request_User_GuideTaskReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_GuideTaskReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_GuideTaskReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_GuideTaskReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    guideTaskFlag = 0,
    taskIndex = 0,
    guideTaskState = 0, --enum EGuideTaskGroupState
    rewardList = {}, -- array of MsgType.OneRewardItem
    nowTaskList = {}, -- array of MsgType.OneGuideTask
    nowRewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_GuideTaskReward.__index = MsgType.Response_User_GuideTaskReward

function MsgType.Response_User_GuideTaskReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    tb.nowTaskList = {}
    tb.nowRewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_GuideTaskReward:GetCmd()
    return MsgTypeCmd.Response_User_GuideTaskReward_Cmd
end
function MsgType.Response_User_GuideTaskReward:GetUrl()
    return "Response_User_GuideTaskReward"
end
function MsgType.Response_User_GuideTaskReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.guideTaskFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.taskIndex = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.guideTaskState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpNowTaskListObj = MsgType.OneGuideTask:New()
            tmpNowTaskListObj:Decode(data.j[i])
            self.nowTaskList[i] = tmpNowTaskListObj
        end
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpNowRewardListObj = MsgType.OneRewardItem:New()
            tmpNowRewardListObj:Decode(data.k[i])
            self.nowRewardList[i] = tmpNowRewardListObj
        end
    end
    return self
end


MsgType.EPetFeedType = {
    Free = 1,
    Gold = 2,
    Gem = 3
}

MsgType.OneUserPetInfo = {
    petId = 0,
    existTime = 0
}
MsgType.OneUserPetInfo.__index = MsgType.OneUserPetInfo

function MsgType.OneUserPetInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneUserPetInfo:Encode()
    local tb = {}
    if nil ~= self.petId and 0 ~= self.petId then
        tb.b = self.petId
    end
    if nil ~= self.existTime and 0 ~= self.existTime then
        tb.c = self.existTime
    end
    return tb
end

function MsgType.OneUserPetInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.petId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.existTime = tonumber(data.c) or 0
    end
    return self
end

function MsgType.OneUserPetInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneUserPetInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_PetInfo = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_PetInfo.__index = MsgType.Request_User_PetInfo

function MsgType.Request_User_PetInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_PetInfo:GetCmd()
    return MsgTypeCmd.Request_User_PetInfo_Cmd
end
function MsgType.Request_User_PetInfo:GetUrl()
    return "Request_User_PetInfo"
end
function MsgType.Request_User_PetInfo:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_PetInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_PetInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_PetInfo = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    petList = {}, -- array of MsgType.OnePetInfo
    petCount = 0,
    petInfoList = {}, -- array of MsgType.OneUserPetInfo
    mainPetUid = 0
}
MsgType.Response_User_PetInfo.__index = MsgType.Response_User_PetInfo

function MsgType.Response_User_PetInfo:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.petList = {}
    tb.petInfoList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_PetInfo:GetCmd()
    return MsgTypeCmd.Response_User_PetInfo_Cmd
end
function MsgType.Response_User_PetInfo:GetUrl()
    return "Response_User_PetInfo"
end
function MsgType.Response_User_PetInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpPetListObj = MsgType.OnePetInfo:New()
            tmpPetListObj:Decode(data.f[i])
            self.petList[i] = tmpPetListObj
        end
    end
    if nil ~= data.g then
        self.petCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpPetInfoListObj = MsgType.OneUserPetInfo:New()
            tmpPetInfoListObj:Decode(data.h[i])
            self.petInfoList[i] = tmpPetInfoListObj
        end
    end
    if nil ~= data.i then
        self.mainPetUid = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_User_SetMainPet = {
    msgSeq = 0,
    petUid = 0
}
MsgType.Request_User_SetMainPet.__index = MsgType.Request_User_SetMainPet

function MsgType.Request_User_SetMainPet:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_SetMainPet:GetCmd()
    return MsgTypeCmd.Request_User_SetMainPet_Cmd
end
function MsgType.Request_User_SetMainPet:GetUrl()
    return "Request_User_SetMainPet"
end
function MsgType.Request_User_SetMainPet:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.petUid and 0 ~= self.petUid then
        tb.c = self.petUid
    end
    return tb
end

function MsgType.Request_User_SetMainPet:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_SetMainPet:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_SetMainPet = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    mainPetUid = 0
}
MsgType.Response_User_SetMainPet.__index = MsgType.Response_User_SetMainPet

function MsgType.Response_User_SetMainPet:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_SetMainPet:GetCmd()
    return MsgTypeCmd.Response_User_SetMainPet_Cmd
end
function MsgType.Response_User_SetMainPet:GetUrl()
    return "Response_User_SetMainPet"
end
function MsgType.Response_User_SetMainPet:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.mainPetUid = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_User_BuyPetSlot = {
    msgSeq = 0,
    costType = 0
}
MsgType.Request_User_BuyPetSlot.__index = MsgType.Request_User_BuyPetSlot

function MsgType.Request_User_BuyPetSlot:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_BuyPetSlot:GetCmd()
    return MsgTypeCmd.Request_User_BuyPetSlot_Cmd
end
function MsgType.Request_User_BuyPetSlot:GetUrl()
    return "Request_User_BuyPetSlot"
end
function MsgType.Request_User_BuyPetSlot:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.costType and 0 ~= self.costType then
        tb.c = self.costType
    end
    return tb
end

function MsgType.Request_User_BuyPetSlot:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_BuyPetSlot:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_BuyPetSlot = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    petInfo = {},
    petCount = 0
}
MsgType.Response_User_BuyPetSlot.__index = MsgType.Response_User_BuyPetSlot
setmetatable(MsgType.Response_User_BuyPetSlot.petInfo, MsgType.OnePetInfo)

function MsgType.Response_User_BuyPetSlot:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.petInfo = MsgType.OnePetInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_BuyPetSlot:GetCmd()
    return MsgTypeCmd.Response_User_BuyPetSlot_Cmd
end
function MsgType.Response_User_BuyPetSlot:GetUrl()
    return "Response_User_BuyPetSlot"
end
function MsgType.Response_User_BuyPetSlot:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.petInfo:Decode(data.f)
    end
    if nil ~= data.g then
        self.petCount = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_User_BuyPet = {
    msgSeq = 0,
    petId = 0,
    costType = 0
}
MsgType.Request_User_BuyPet.__index = MsgType.Request_User_BuyPet

function MsgType.Request_User_BuyPet:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_BuyPet:GetCmd()
    return MsgTypeCmd.Request_User_BuyPet_Cmd
end
function MsgType.Request_User_BuyPet:GetUrl()
    return "Request_User_BuyPet"
end
function MsgType.Request_User_BuyPet:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.petId and 0 ~= self.petId then
        tb.c = self.petId
    end
    if nil ~= self.costType and 0 ~= self.costType then
        tb.d = self.costType
    end
    return tb
end

function MsgType.Request_User_BuyPet:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_BuyPet:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_BuyPet = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    petInfoList = {} -- array of MsgType.OneUserPetInfo
}
MsgType.Response_User_BuyPet.__index = MsgType.Response_User_BuyPet

function MsgType.Response_User_BuyPet:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.petInfoList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_BuyPet:GetCmd()
    return MsgTypeCmd.Response_User_BuyPet_Cmd
end
function MsgType.Response_User_BuyPet:GetUrl()
    return "Response_User_BuyPet"
end
function MsgType.Response_User_BuyPet:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpPetInfoListObj = MsgType.OneUserPetInfo:New()
            tmpPetInfoListObj:Decode(data.f[i])
            self.petInfoList[i] = tmpPetInfoListObj
        end
    end
    return self
end


MsgType.Request_User_SetPetSlot = {
    msgSeq = 0,
    petUid = 0,
    petId = 0,
    petName = ""
}
MsgType.Request_User_SetPetSlot.__index = MsgType.Request_User_SetPetSlot

function MsgType.Request_User_SetPetSlot:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_SetPetSlot:GetCmd()
    return MsgTypeCmd.Request_User_SetPetSlot_Cmd
end
function MsgType.Request_User_SetPetSlot:GetUrl()
    return "Request_User_SetPetSlot"
end
function MsgType.Request_User_SetPetSlot:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.petUid and 0 ~= self.petUid then
        tb.c = self.petUid
    end
    if nil ~= self.petId and 0 ~= self.petId then
        tb.d = self.petId
    end
    if nil ~= self.petName and string.len(self.petName) > 0 then
        tb.e = self.petName
    end
    return tb
end

function MsgType.Request_User_SetPetSlot:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_SetPetSlot:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_SetPetSlot = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    petInfo = {},
    furnitureInfo = {},
    createFlag = 0
}
MsgType.Response_User_SetPetSlot.__index = MsgType.Response_User_SetPetSlot
setmetatable(MsgType.Response_User_SetPetSlot.petInfo, MsgType.OnePetInfo)
setmetatable(MsgType.Response_User_SetPetSlot.furnitureInfo, MsgType.OneFurniture)

function MsgType.Response_User_SetPetSlot:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.petInfo = MsgType.OnePetInfo:New()
    tb.furnitureInfo = MsgType.OneFurniture:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_SetPetSlot:GetCmd()
    return MsgTypeCmd.Response_User_SetPetSlot_Cmd
end
function MsgType.Response_User_SetPetSlot:GetUrl()
    return "Response_User_SetPetSlot"
end
function MsgType.Response_User_SetPetSlot:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.petInfo:Decode(data.f)
    end
    if nil ~= data.g then
        self.furnitureInfo:Decode(data.g)
    end
    if nil ~= data.h then
        self.createFlag = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_User_PetChangeName = {
    msgSeq = 0,
    petUid = 0,
    petName = ""
}
MsgType.Request_User_PetChangeName.__index = MsgType.Request_User_PetChangeName

function MsgType.Request_User_PetChangeName:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_PetChangeName:GetCmd()
    return MsgTypeCmd.Request_User_PetChangeName_Cmd
end
function MsgType.Request_User_PetChangeName:GetUrl()
    return "Request_User_PetChangeName"
end
function MsgType.Request_User_PetChangeName:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.petUid and 0 ~= self.petUid then
        tb.c = self.petUid
    end
    if nil ~= self.petName and string.len(self.petName) > 0 then
        tb.d = self.petName
    end
    return tb
end

function MsgType.Request_User_PetChangeName:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_PetChangeName:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_PetChangeName = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    petInfo = {}
}
MsgType.Response_User_PetChangeName.__index = MsgType.Response_User_PetChangeName
setmetatable(MsgType.Response_User_PetChangeName.petInfo, MsgType.OnePetInfo)

function MsgType.Response_User_PetChangeName:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.petInfo = MsgType.OnePetInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_PetChangeName:GetCmd()
    return MsgTypeCmd.Response_User_PetChangeName_Cmd
end
function MsgType.Response_User_PetChangeName:GetUrl()
    return "Response_User_PetChangeName"
end
function MsgType.Response_User_PetChangeName:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.petInfo:Decode(data.f)
    end
    return self
end


MsgType.Request_User_PetFeed = {
    msgSeq = 0,
    petUid = 0,
    petFeedType = 0 --enum EPetFeedType
}
MsgType.Request_User_PetFeed.__index = MsgType.Request_User_PetFeed

function MsgType.Request_User_PetFeed:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_PetFeed:GetCmd()
    return MsgTypeCmd.Request_User_PetFeed_Cmd
end
function MsgType.Request_User_PetFeed:GetUrl()
    return "Request_User_PetFeed"
end
function MsgType.Request_User_PetFeed:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.petUid and 0 ~= self.petUid then
        tb.c = self.petUid
    end
    if nil ~= self.petFeedType and 0 ~= self.petFeedType then
        tb.d = self.petFeedType
    end
    return tb
end

function MsgType.Request_User_PetFeed:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_PetFeed:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_PetFeed = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    petInfo = {}
}
MsgType.Response_User_PetFeed.__index = MsgType.Response_User_PetFeed
setmetatable(MsgType.Response_User_PetFeed.petInfo, MsgType.OnePetInfo)

function MsgType.Response_User_PetFeed:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.petInfo = MsgType.OnePetInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_PetFeed:GetCmd()
    return MsgTypeCmd.Response_User_PetFeed_Cmd
end
function MsgType.Response_User_PetFeed:GetUrl()
    return "Response_User_PetFeed"
end
function MsgType.Response_User_PetFeed:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.petInfo:Decode(data.f)
    end
    return self
end


MsgType.Request_User_PetInfoUpdate = {
    msgSeq = 0,
    petUid = 0
}
MsgType.Request_User_PetInfoUpdate.__index = MsgType.Request_User_PetInfoUpdate

function MsgType.Request_User_PetInfoUpdate:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_PetInfoUpdate:GetCmd()
    return MsgTypeCmd.Request_User_PetInfoUpdate_Cmd
end
function MsgType.Request_User_PetInfoUpdate:GetUrl()
    return "Request_User_PetInfoUpdate"
end
function MsgType.Request_User_PetInfoUpdate:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.petUid and 0 ~= self.petUid then
        tb.c = self.petUid
    end
    return tb
end

function MsgType.Request_User_PetInfoUpdate:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_PetInfoUpdate:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_PetInfoUpdate = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    petInfo = {}
}
MsgType.Response_User_PetInfoUpdate.__index = MsgType.Response_User_PetInfoUpdate
setmetatable(MsgType.Response_User_PetInfoUpdate.petInfo, MsgType.OnePetInfo)

function MsgType.Response_User_PetInfoUpdate:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.petInfo = MsgType.OnePetInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_PetInfoUpdate:GetCmd()
    return MsgTypeCmd.Response_User_PetInfoUpdate_Cmd
end
function MsgType.Response_User_PetInfoUpdate:GetUrl()
    return "Response_User_PetInfoUpdate"
end
function MsgType.Response_User_PetInfoUpdate:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.petInfo:Decode(data.f)
    end
    return self
end


MsgType.Response_User_UserPetInfoUpdate = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userPetInfo = {}
}
MsgType.Response_User_UserPetInfoUpdate.__index = MsgType.Response_User_UserPetInfoUpdate
setmetatable(MsgType.Response_User_UserPetInfoUpdate.userPetInfo, MsgType.OneUserPetInfo)

function MsgType.Response_User_UserPetInfoUpdate:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userPetInfo = MsgType.OneUserPetInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_UserPetInfoUpdate:GetCmd()
    return MsgTypeCmd.Response_User_UserPetInfoUpdate_Cmd
end
function MsgType.Response_User_UserPetInfoUpdate:GetUrl()
    return "Response_User_UserPetInfoUpdate"
end
function MsgType.Response_User_UserPetInfoUpdate:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userPetInfo:Decode(data.f)
    end
    return self
end


MsgType.CounterData = {
    counterUid = 0,
    furnitureId = 0,
    counterLevel = 0,
    x = 0,
    y = 0,
    rotate = 0,
    state = 0, --enum EDesignState
    stateStartTime = 0,
    stateEndTime = 0,
    stateRemainTime = 0
}
MsgType.CounterData.__index = MsgType.CounterData

function MsgType.CounterData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.CounterData:Encode()
    local tb = {}
    if nil ~= self.counterUid and 0 ~= self.counterUid then
        tb.b = self.counterUid
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.c = self.furnitureId
    end
    if nil ~= self.counterLevel and 0 ~= self.counterLevel then
        tb.d = self.counterLevel
    end
    if nil ~= self.x and 0 ~= self.x then
        tb.e = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.f = self.y
    end
    if nil ~= self.rotate and 0 ~= self.rotate then
        tb.g = self.rotate
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.h = self.state
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.i = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.j = self.stateEndTime
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.k = self.stateRemainTime
    end
    return tb
end

function MsgType.CounterData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.counterUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.furnitureId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.counterLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.x = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.y = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.rotate = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.state = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.stateStartTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.stateEndTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.stateRemainTime = tonumber(data.k) or 0
    end
    return self
end

function MsgType.CounterData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.CounterData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.ShopData = {
    shopLevel = 0,
    state = 0, --enum EDesignState
    stateStartTime = 0,
    stateEndTime = 0,
    stateRemainTime = 0
}
MsgType.ShopData.__index = MsgType.ShopData

function MsgType.ShopData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ShopData:Encode()
    local tb = {}
    if nil ~= self.shopLevel and 0 ~= self.shopLevel then
        tb.b = self.shopLevel
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.c = self.state
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.d = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.e = self.stateEndTime
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.f = self.stateRemainTime
    end
    return tb
end

function MsgType.ShopData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.shopLevel = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.state = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.stateStartTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.stateEndTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.stateRemainTime = tonumber(data.f) or 0
    end
    return self
end

function MsgType.ShopData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ShopData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneStoreBasket = {
    storeUid = 0,
    furnitureId = 0,
    storeLevel = 0,
    x = 0,
    y = 0,
    rotate = 0,
    state = 0, --enum EDesignState
    stateStartTime = 0,
    stateEndTime = 0,
    stateRemainTime = 0
}
MsgType.OneStoreBasket.__index = MsgType.OneStoreBasket

function MsgType.OneStoreBasket:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneStoreBasket:Encode()
    local tb = {}
    if nil ~= self.storeUid and 0 ~= self.storeUid then
        tb.b = self.storeUid
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.c = self.furnitureId
    end
    if nil ~= self.storeLevel and 0 ~= self.storeLevel then
        tb.d = self.storeLevel
    end
    if nil ~= self.x and 0 ~= self.x then
        tb.e = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.f = self.y
    end
    if nil ~= self.rotate and 0 ~= self.rotate then
        tb.g = self.rotate
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.h = self.state
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.i = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.j = self.stateEndTime
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.k = self.stateRemainTime
    end
    return tb
end

function MsgType.OneStoreBasket:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.storeUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.furnitureId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.storeLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.x = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.y = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.rotate = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.state = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.stateStartTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.stateEndTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.stateRemainTime = tonumber(data.k) or 0
    end
    return self
end

function MsgType.OneStoreBasket:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneStoreBasket:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneResBasket = {
    resUid = 0,
    furnitureId = 0,
    resType = 0,
    resLevel = 0,
    x = 0,
    y = 0,
    rotate = 0,
    state = 0, --enum EDesignState
    stateStartTime = 0,
    stateEndTime = 0,
    stateRemainTime = 0
}
MsgType.OneResBasket.__index = MsgType.OneResBasket

function MsgType.OneResBasket:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneResBasket:Encode()
    local tb = {}
    if nil ~= self.resUid and 0 ~= self.resUid then
        tb.b = self.resUid
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.c = self.furnitureId
    end
    if nil ~= self.resType and 0 ~= self.resType then
        tb.d = self.resType
    end
    if nil ~= self.resLevel and 0 ~= self.resLevel then
        tb.e = self.resLevel
    end
    if nil ~= self.x and 0 ~= self.x then
        tb.f = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.g = self.y
    end
    if nil ~= self.rotate and 0 ~= self.rotate then
        tb.h = self.rotate
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.i = self.state
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.j = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.k = self.stateEndTime
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.l = self.stateRemainTime
    end
    return tb
end

function MsgType.OneResBasket:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.resUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.furnitureId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.resType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.resLevel = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.x = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.y = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.rotate = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.state = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.stateStartTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.stateEndTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.stateRemainTime = tonumber(data.l) or 0
    end
    return self
end

function MsgType.OneResBasket:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneResBasket:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.ShelfEquip = {
    fieldId = 0,
    equipUid = "",
    equipId = 0,
    equipQuality = 0
}
MsgType.ShelfEquip.__index = MsgType.ShelfEquip

function MsgType.ShelfEquip:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ShelfEquip:Encode()
    local tb = {}
    if nil ~= self.fieldId and 0 ~= self.fieldId then
        tb.b = self.fieldId
    end
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.c = self.equipUid
    end
    if nil ~= self.equipId and 0 ~= self.equipId then
        tb.d = self.equipId
    end
    if nil ~= self.equipQuality and 0 ~= self.equipQuality then
        tb.e = self.equipQuality
    end
    return tb
end

function MsgType.ShelfEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.fieldId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.equipUid = tostring(data.c)
    end
    if nil ~= data.d then
        self.equipId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.equipQuality = tonumber(data.e) or 0
    end
    return self
end

function MsgType.ShelfEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ShelfEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneShelf = {
    shelfUid = 0,
    furnitureId = 0,
    shelfType = 0,
    shelfLevel = 0,
    x = 0,
    y = 0,
    rotate = 0,
    state = 0, --enum EDesignState
    stateStartTime = 0,
    stateEndTime = 0,
    stateRemainTime = 0,
    equipList = {} -- array of MsgType.ShelfEquip
}
MsgType.OneShelf.__index = MsgType.OneShelf

function MsgType.OneShelf:New()
    local tb = {}
    setmetatable(tb, self)
    tb.equipList = {}
    return tb
end

function MsgType.OneShelf:_equipListEncode()
    local tb = {}
    for i=1, #self.equipList do
        tb[i] = self.equipList[i]:Encode()
    end
    return tb
end
function MsgType.OneShelf:Encode()
    local tb = {}
    if nil ~= self.shelfUid and 0 ~= self.shelfUid then
        tb.b = self.shelfUid
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.c = self.furnitureId
    end
    if nil ~= self.shelfType and 0 ~= self.shelfType then
        tb.d = self.shelfType
    end
    if nil ~= self.shelfLevel and 0 ~= self.shelfLevel then
        tb.e = self.shelfLevel
    end
    if nil ~= self.x and 0 ~= self.x then
        tb.f = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.g = self.y
    end
    if nil ~= self.rotate and 0 ~= self.rotate then
        tb.h = self.rotate
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.i = self.state
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.j = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.k = self.stateEndTime
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.l = self.stateRemainTime
    end
    tb.m = self:_equipListEncode()
    return tb
end

function MsgType.OneShelf:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.shelfUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.furnitureId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.shelfType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.shelfLevel = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.x = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.y = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.rotate = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.state = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.stateStartTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.stateEndTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.stateRemainTime = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        for i=1, #data.m do
            local tmpEquipListObj = MsgType.ShelfEquip:New()
            tmpEquipListObj:Decode(data.m[i])
            self.equipList[i] = tmpEquipListObj
        end
    end
    return self
end

function MsgType.OneShelf:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneShelf:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneFurniture = {
    furnitureUid = 0,
    furnitureId = 0,
    level = 0,
    x = 0,
    y = 0,
    rotate = 0,
    stateStartTime = 0,
    stateEndTime = 0,
    stateRemainTime = 0,
    state = 0, --enum EDesignState
    equipList = {} -- array of MsgType.ShelfEquip
}
MsgType.OneFurniture.__index = MsgType.OneFurniture

function MsgType.OneFurniture:New()
    local tb = {}
    setmetatable(tb, self)
    tb.equipList = {}
    return tb
end

function MsgType.OneFurniture:_equipListEncode()
    local tb = {}
    for i=1, #self.equipList do
        tb[i] = self.equipList[i]:Encode()
    end
    return tb
end
function MsgType.OneFurniture:Encode()
    local tb = {}
    if nil ~= self.furnitureUid and 0 ~= self.furnitureUid then
        tb.b = self.furnitureUid
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.c = self.furnitureId
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.d = self.level
    end
    if nil ~= self.x and 0 ~= self.x then
        tb.e = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.f = self.y
    end
    if nil ~= self.rotate and 0 ~= self.rotate then
        tb.g = self.rotate
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.h = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.i = self.stateEndTime
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.j = self.stateRemainTime
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.k = self.state
    end
    tb.l = self:_equipListEncode()
    return tb
end

function MsgType.OneFurniture:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.furnitureUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.furnitureId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.level = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.x = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.y = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.rotate = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.stateStartTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.stateEndTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.stateRemainTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.state = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        for i=1, #data.l do
            local tmpEquipListObj = MsgType.ShelfEquip:New()
            tmpEquipListObj:Decode(data.l[i])
            self.equipList[i] = tmpEquipListObj
        end
    end
    return self
end

function MsgType.OneFurniture:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneFurniture:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneFloor = {
    x = 0,
    y = 0,
    furnitureId = 0
}
MsgType.OneFloor.__index = MsgType.OneFloor

function MsgType.OneFloor:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneFloor:Encode()
    local tb = {}
    if nil ~= self.x and 0 ~= self.x then
        tb.b = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.c = self.y
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.d = self.furnitureId
    end
    return tb
end

function MsgType.OneFloor:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.x = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.y = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.furnitureId = tonumber(data.d) or 0
    end
    return self
end

function MsgType.OneFloor:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneFloor:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.FloorData = {
    ownedFloorList = {}, -- array of number
    floorList = {} -- array of MsgType.OneFloor
}
MsgType.FloorData.__index = MsgType.FloorData

function MsgType.FloorData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.ownedFloorList = {}
    tb.floorList = {}
    return tb
end

function MsgType.FloorData:_floorListEncode()
    local tb = {}
    for i=1, #self.floorList do
        tb[i] = self.floorList[i]:Encode()
    end
    return tb
end
function MsgType.FloorData:Encode()
    local tb = {}
    if nil ~= self.ownedFloorList and #self.ownedFloorList > 0 then
        for i=1, #self.ownedFloorList do
            tb.e[i] = tonumber(self.ownedFloorList[i])
        end
    end
    tb.c = self:_floorListEncode()
    return tb
end

function MsgType.FloorData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b and #data.b > 0 then
        for i=1, #data.b do
            self.ownedFloorList[i] = tonumber(data.b[i])
        end
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpFloorListObj = MsgType.OneFloor:New()
            tmpFloorListObj:Decode(data.c[i])
            self.floorList[i] = tmpFloorListObj
        end
    end
    return self
end

function MsgType.FloorData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.FloorData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneWall = {
    x = 0,
    y = 0,
    furnitureId = 0,
    index = 0
}
MsgType.OneWall.__index = MsgType.OneWall

function MsgType.OneWall:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneWall:Encode()
    local tb = {}
    if nil ~= self.x and 0 ~= self.x then
        tb.b = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.c = self.y
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.d = self.furnitureId
    end
    if nil ~= self.index and 0 ~= self.index then
        tb.e = self.index
    end
    return tb
end

function MsgType.OneWall:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.x = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.y = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.furnitureId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.index = tonumber(data.e) or 0
    end
    return self
end

function MsgType.OneWall:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneWall:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.WallData = {
    ownedWallList = {}, -- array of number
    wallList = {} -- array of MsgType.OneWall
}
MsgType.WallData.__index = MsgType.WallData

function MsgType.WallData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.ownedWallList = {}
    tb.wallList = {}
    return tb
end

function MsgType.WallData:_wallListEncode()
    local tb = {}
    for i=1, #self.wallList do
        tb[i] = self.wallList[i]:Encode()
    end
    return tb
end
function MsgType.WallData:Encode()
    local tb = {}
    if nil ~= self.ownedWallList and #self.ownedWallList > 0 then
        for i=1, #self.ownedWallList do
            tb.e[i] = tonumber(self.ownedWallList[i])
        end
    end
    tb.c = self:_wallListEncode()
    return tb
end

function MsgType.WallData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b and #data.b > 0 then
        for i=1, #data.b do
            self.ownedWallList[i] = tonumber(data.b[i])
        end
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpWallListObj = MsgType.OneWall:New()
            tmpWallListObj:Decode(data.c[i])
            self.wallList[i] = tmpWallListObj
        end
    end
    return self
end

function MsgType.WallData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.WallData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OwnedFurniture = {
    uid = 0,
    designType = 0, --enum EDesignType
    furnitureId = 0,
    level = 0
}
MsgType.OwnedFurniture.__index = MsgType.OwnedFurniture

function MsgType.OwnedFurniture:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OwnedFurniture:Encode()
    local tb = {}
    if nil ~= self.uid and 0 ~= self.uid then
        tb.b = self.uid
    end
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.d = self.furnitureId
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.e = self.level
    end
    return tb
end

function MsgType.OwnedFurniture:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.uid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.designType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.furnitureId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.level = tonumber(data.e) or 0
    end
    return self
end

function MsgType.OwnedFurniture:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OwnedFurniture:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Design_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Design_Data.__index = MsgType.Request_Design_Data

function MsgType.Request_Design_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_Data:GetCmd()
    return MsgTypeCmd.Request_Design_Data_Cmd
end
function MsgType.Request_Design_Data:GetUrl()
    return "Request_Design_Data"
end
function MsgType.Request_Design_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Design_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopData = {},
    floorData = {},
    wallData = {},
    furnitureList = {} -- array of MsgType.OneFurniture
}
MsgType.Response_Design_Data.__index = MsgType.Response_Design_Data
setmetatable(MsgType.Response_Design_Data.shopData, MsgType.ShopData)
setmetatable(MsgType.Response_Design_Data.floorData, MsgType.FloorData)
setmetatable(MsgType.Response_Design_Data.wallData, MsgType.WallData)

function MsgType.Response_Design_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shopData = MsgType.ShopData:New()
    tb.floorData = MsgType.FloorData:New()
    tb.wallData = MsgType.WallData:New()
    tb.furnitureList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_Data:GetCmd()
    return MsgTypeCmd.Response_Design_Data_Cmd
end
function MsgType.Response_Design_Data:GetUrl()
    return "Response_Design_Data"
end
function MsgType.Response_Design_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopData:Decode(data.f)
    end
    if nil ~= data.g then
        self.floorData:Decode(data.g)
    end
    if nil ~= data.h then
        self.wallData:Decode(data.h)
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpFurnitureListObj = MsgType.OneFurniture:New()
            tmpFurnitureListObj:Decode(data.i[i])
            self.furnitureList[i] = tmpFurnitureListObj
        end
    end
    return self
end


MsgType.Request_Design_ShopUpgrade = {
    msgSeq = 0,
    useGem = 0
}
MsgType.Request_Design_ShopUpgrade.__index = MsgType.Request_Design_ShopUpgrade

function MsgType.Request_Design_ShopUpgrade:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_ShopUpgrade:GetCmd()
    return MsgTypeCmd.Request_Design_ShopUpgrade_Cmd
end
function MsgType.Request_Design_ShopUpgrade:GetUrl()
    return "Request_Design_ShopUpgrade"
end
function MsgType.Request_Design_ShopUpgrade:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.c = self.useGem
    end
    return tb
end

function MsgType.Request_Design_ShopUpgrade:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_ShopUpgrade:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_ShopUpgrade = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopData = {}
}
MsgType.Response_Design_ShopUpgrade.__index = MsgType.Response_Design_ShopUpgrade
setmetatable(MsgType.Response_Design_ShopUpgrade.shopData, MsgType.ShopData)

function MsgType.Response_Design_ShopUpgrade:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shopData = MsgType.ShopData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_ShopUpgrade:GetCmd()
    return MsgTypeCmd.Response_Design_ShopUpgrade_Cmd
end
function MsgType.Response_Design_ShopUpgrade:GetUrl()
    return "Response_Design_ShopUpgrade"
end
function MsgType.Response_Design_ShopUpgrade:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopData:Decode(data.f)
    end
    return self
end


MsgType.Request_Design_ShopRefresh = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Design_ShopRefresh.__index = MsgType.Request_Design_ShopRefresh

function MsgType.Request_Design_ShopRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_ShopRefresh:GetCmd()
    return MsgTypeCmd.Request_Design_ShopRefresh_Cmd
end
function MsgType.Request_Design_ShopRefresh:GetUrl()
    return "Request_Design_ShopRefresh"
end
function MsgType.Request_Design_ShopRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Design_ShopRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_ShopRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_ShopRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopData = {}
}
MsgType.Response_Design_ShopRefresh.__index = MsgType.Response_Design_ShopRefresh
setmetatable(MsgType.Response_Design_ShopRefresh.shopData, MsgType.ShopData)

function MsgType.Response_Design_ShopRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shopData = MsgType.ShopData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_ShopRefresh:GetCmd()
    return MsgTypeCmd.Response_Design_ShopRefresh_Cmd
end
function MsgType.Response_Design_ShopRefresh:GetUrl()
    return "Response_Design_ShopRefresh"
end
function MsgType.Response_Design_ShopRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopData:Decode(data.f)
    end
    return self
end


MsgType.Request_Design_ShopFinish = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Design_ShopFinish.__index = MsgType.Request_Design_ShopFinish

function MsgType.Request_Design_ShopFinish:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_ShopFinish:GetCmd()
    return MsgTypeCmd.Request_Design_ShopFinish_Cmd
end
function MsgType.Request_Design_ShopFinish:GetUrl()
    return "Request_Design_ShopFinish"
end
function MsgType.Request_Design_ShopFinish:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Design_ShopFinish:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_ShopFinish:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_ShopFinish = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopData = {}
}
MsgType.Response_Design_ShopFinish.__index = MsgType.Response_Design_ShopFinish
setmetatable(MsgType.Response_Design_ShopFinish.shopData, MsgType.ShopData)

function MsgType.Response_Design_ShopFinish:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shopData = MsgType.ShopData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_ShopFinish:GetCmd()
    return MsgTypeCmd.Response_Design_ShopFinish_Cmd
end
function MsgType.Response_Design_ShopFinish:GetUrl()
    return "Response_Design_ShopFinish"
end
function MsgType.Response_Design_ShopFinish:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopData:Decode(data.f)
    end
    return self
end


MsgType.Request_Design_ShopImmediately = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Design_ShopImmediately.__index = MsgType.Request_Design_ShopImmediately

function MsgType.Request_Design_ShopImmediately:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_ShopImmediately:GetCmd()
    return MsgTypeCmd.Request_Design_ShopImmediately_Cmd
end
function MsgType.Request_Design_ShopImmediately:GetUrl()
    return "Request_Design_ShopImmediately"
end
function MsgType.Request_Design_ShopImmediately:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Design_ShopImmediately:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_ShopImmediately:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_ShopImmediately = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopData = {}
}
MsgType.Response_Design_ShopImmediately.__index = MsgType.Response_Design_ShopImmediately
setmetatable(MsgType.Response_Design_ShopImmediately.shopData, MsgType.ShopData)

function MsgType.Response_Design_ShopImmediately:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shopData = MsgType.ShopData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_ShopImmediately:GetCmd()
    return MsgTypeCmd.Response_Design_ShopImmediately_Cmd
end
function MsgType.Response_Design_ShopImmediately:GetUrl()
    return "Response_Design_ShopImmediately"
end
function MsgType.Response_Design_ShopImmediately:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopData:Decode(data.f)
    end
    return self
end


MsgType.Request_Design_Buy = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    furnitureId = 0,
    x = 0,
    y = 0,
    rotate = 0
}
MsgType.Request_Design_Buy.__index = MsgType.Request_Design_Buy

function MsgType.Request_Design_Buy:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_Buy:GetCmd()
    return MsgTypeCmd.Request_Design_Buy_Cmd
end
function MsgType.Request_Design_Buy:GetUrl()
    return "Request_Design_Buy"
end
function MsgType.Request_Design_Buy:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.d = self.furnitureId
    end
    if nil ~= self.x and 0 ~= self.x then
        tb.e = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.f = self.y
    end
    if nil ~= self.rotate and 0 ~= self.rotate then
        tb.g = self.rotate
    end
    return tb
end

function MsgType.Request_Design_Buy:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_Buy:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_Buy = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    furnitureId = 0,
    x = 0,
    y = 0,
    rotate = 0
}
MsgType.Response_Design_Buy.__index = MsgType.Response_Design_Buy

function MsgType.Response_Design_Buy:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_Buy:GetCmd()
    return MsgTypeCmd.Response_Design_Buy_Cmd
end
function MsgType.Response_Design_Buy:GetUrl()
    return "Response_Design_Buy"
end
function MsgType.Response_Design_Buy:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.furnitureId = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.x = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.y = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.rotate = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_Design_Move = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    uid = 0,
    x = 0,
    y = 0,
    rotate = 0
}
MsgType.Request_Design_Move.__index = MsgType.Request_Design_Move

function MsgType.Request_Design_Move:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_Move:GetCmd()
    return MsgTypeCmd.Request_Design_Move_Cmd
end
function MsgType.Request_Design_Move:GetUrl()
    return "Request_Design_Move"
end
function MsgType.Request_Design_Move:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.uid and 0 ~= self.uid then
        tb.d = self.uid
    end
    if nil ~= self.x and 0 ~= self.x then
        tb.e = self.x
    end
    if nil ~= self.y and 0 ~= self.y then
        tb.f = self.y
    end
    if nil ~= self.rotate and 0 ~= self.rotate then
        tb.g = self.rotate
    end
    return tb
end

function MsgType.Request_Design_Move:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_Move:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_Move = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Design_Move.__index = MsgType.Response_Design_Move

function MsgType.Response_Design_Move:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_Move:GetCmd()
    return MsgTypeCmd.Response_Design_Move_Cmd
end
function MsgType.Response_Design_Move:GetUrl()
    return "Response_Design_Move"
end
function MsgType.Response_Design_Move:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Design_Upgrade = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    uid = 0,
    useGem = 0
}
MsgType.Request_Design_Upgrade.__index = MsgType.Request_Design_Upgrade

function MsgType.Request_Design_Upgrade:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_Upgrade:GetCmd()
    return MsgTypeCmd.Request_Design_Upgrade_Cmd
end
function MsgType.Request_Design_Upgrade:GetUrl()
    return "Request_Design_Upgrade"
end
function MsgType.Request_Design_Upgrade:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.uid and 0 ~= self.uid then
        tb.d = self.uid
    end
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.e = self.useGem
    end
    return tb
end

function MsgType.Request_Design_Upgrade:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_Upgrade:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_Upgrade = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Design_Upgrade.__index = MsgType.Response_Design_Upgrade

function MsgType.Response_Design_Upgrade:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_Upgrade:GetCmd()
    return MsgTypeCmd.Response_Design_Upgrade_Cmd
end
function MsgType.Response_Design_Upgrade:GetUrl()
    return "Response_Design_Upgrade"
end
function MsgType.Response_Design_Upgrade:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Design_Refresh = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    uid = 0
}
MsgType.Request_Design_Refresh.__index = MsgType.Request_Design_Refresh

function MsgType.Request_Design_Refresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_Refresh:GetCmd()
    return MsgTypeCmd.Request_Design_Refresh_Cmd
end
function MsgType.Request_Design_Refresh:GetUrl()
    return "Request_Design_Refresh"
end
function MsgType.Request_Design_Refresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.uid and 0 ~= self.uid then
        tb.d = self.uid
    end
    return tb
end

function MsgType.Request_Design_Refresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_Refresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_Refresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Design_Refresh.__index = MsgType.Response_Design_Refresh

function MsgType.Response_Design_Refresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_Refresh:GetCmd()
    return MsgTypeCmd.Response_Design_Refresh_Cmd
end
function MsgType.Response_Design_Refresh:GetUrl()
    return "Response_Design_Refresh"
end
function MsgType.Response_Design_Refresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Design_Finish = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    uid = 0
}
MsgType.Request_Design_Finish.__index = MsgType.Request_Design_Finish

function MsgType.Request_Design_Finish:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_Finish:GetCmd()
    return MsgTypeCmd.Request_Design_Finish_Cmd
end
function MsgType.Request_Design_Finish:GetUrl()
    return "Request_Design_Finish"
end
function MsgType.Request_Design_Finish:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.uid and 0 ~= self.uid then
        tb.d = self.uid
    end
    return tb
end

function MsgType.Request_Design_Finish:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_Finish:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_Finish = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    designType = 0, --enum EDesignType
    uid = 0
}
MsgType.Response_Design_Finish.__index = MsgType.Response_Design_Finish

function MsgType.Response_Design_Finish:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_Finish:GetCmd()
    return MsgTypeCmd.Response_Design_Finish_Cmd
end
function MsgType.Response_Design_Finish:GetUrl()
    return "Response_Design_Finish"
end
function MsgType.Response_Design_Finish:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.designType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.uid = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Design_Immediately = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    uid = 0
}
MsgType.Request_Design_Immediately.__index = MsgType.Request_Design_Immediately

function MsgType.Request_Design_Immediately:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_Immediately:GetCmd()
    return MsgTypeCmd.Request_Design_Immediately_Cmd
end
function MsgType.Request_Design_Immediately:GetUrl()
    return "Request_Design_Immediately"
end
function MsgType.Request_Design_Immediately:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.uid and 0 ~= self.uid then
        tb.d = self.uid
    end
    return tb
end

function MsgType.Request_Design_Immediately:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_Immediately:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_Immediately = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    designType = 0, --enum EDesignType
    uid = 0
}
MsgType.Response_Design_Immediately.__index = MsgType.Response_Design_Immediately

function MsgType.Response_Design_Immediately:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_Immediately:GetCmd()
    return MsgTypeCmd.Response_Design_Immediately_Cmd
end
function MsgType.Response_Design_Immediately:GetUrl()
    return "Response_Design_Immediately"
end
function MsgType.Response_Design_Immediately:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.designType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.uid = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Design_InStore = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    uid = 0
}
MsgType.Request_Design_InStore.__index = MsgType.Request_Design_InStore

function MsgType.Request_Design_InStore:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_InStore:GetCmd()
    return MsgTypeCmd.Request_Design_InStore_Cmd
end
function MsgType.Request_Design_InStore:GetUrl()
    return "Request_Design_InStore"
end
function MsgType.Request_Design_InStore:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.uid and 0 ~= self.uid then
        tb.d = self.uid
    end
    return tb
end

function MsgType.Request_Design_InStore:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_InStore:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_InStore = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    designType = 0, --enum EDesignType
    uid = 0
}
MsgType.Response_Design_InStore.__index = MsgType.Response_Design_InStore

function MsgType.Response_Design_InStore:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_InStore:GetCmd()
    return MsgTypeCmd.Response_Design_InStore_Cmd
end
function MsgType.Response_Design_InStore:GetUrl()
    return "Response_Design_InStore"
end
function MsgType.Response_Design_InStore:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.designType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.uid = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Design_SetFloor = {
    msgSeq = 0,
    buyFloorId = 0,
    floorList = {} -- array of MsgType.OneFloor
}
MsgType.Request_Design_SetFloor.__index = MsgType.Request_Design_SetFloor

function MsgType.Request_Design_SetFloor:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.floorList = {}
    return tb
end

function MsgType.Request_Design_SetFloor:GetCmd()
    return MsgTypeCmd.Request_Design_SetFloor_Cmd
end
function MsgType.Request_Design_SetFloor:GetUrl()
    return "Request_Design_SetFloor"
end
function MsgType.Request_Design_SetFloor:_floorListEncode()
    local tb = {}
    for i=1, #self.floorList do
        tb[i] = self.floorList[i]:Encode()
    end
    return tb
end
function MsgType.Request_Design_SetFloor:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buyFloorId and 0 ~= self.buyFloorId then
        tb.c = self.buyFloorId
    end
    tb.d = self:_floorListEncode()
    return tb
end

function MsgType.Request_Design_SetFloor:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_SetFloor:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_SetFloor = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    floorData = {}
}
MsgType.Response_Design_SetFloor.__index = MsgType.Response_Design_SetFloor
setmetatable(MsgType.Response_Design_SetFloor.floorData, MsgType.FloorData)

function MsgType.Response_Design_SetFloor:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.floorData = MsgType.FloorData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_SetFloor:GetCmd()
    return MsgTypeCmd.Response_Design_SetFloor_Cmd
end
function MsgType.Response_Design_SetFloor:GetUrl()
    return "Response_Design_SetFloor"
end
function MsgType.Response_Design_SetFloor:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.floorData:Decode(data.f)
    end
    return self
end


MsgType.Request_Design_SetWall = {
    msgSeq = 0,
    buyWallId = 0,
    wallList = {} -- array of MsgType.OneWall
}
MsgType.Request_Design_SetWall.__index = MsgType.Request_Design_SetWall

function MsgType.Request_Design_SetWall:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.wallList = {}
    return tb
end

function MsgType.Request_Design_SetWall:GetCmd()
    return MsgTypeCmd.Request_Design_SetWall_Cmd
end
function MsgType.Request_Design_SetWall:GetUrl()
    return "Request_Design_SetWall"
end
function MsgType.Request_Design_SetWall:_wallListEncode()
    local tb = {}
    for i=1, #self.wallList do
        tb[i] = self.wallList[i]:Encode()
    end
    return tb
end
function MsgType.Request_Design_SetWall:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buyWallId and 0 ~= self.buyWallId then
        tb.c = self.buyWallId
    end
    tb.d = self:_wallListEncode()
    return tb
end

function MsgType.Request_Design_SetWall:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_SetWall:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_SetWall = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    wallData = {}
}
MsgType.Response_Design_SetWall.__index = MsgType.Response_Design_SetWall
setmetatable(MsgType.Response_Design_SetWall.wallData, MsgType.WallData)

function MsgType.Response_Design_SetWall:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.wallData = MsgType.WallData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_SetWall:GetCmd()
    return MsgTypeCmd.Response_Design_SetWall_Cmd
end
function MsgType.Response_Design_SetWall:GetUrl()
    return "Response_Design_SetWall"
end
function MsgType.Response_Design_SetWall:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.wallData:Decode(data.f)
    end
    return self
end


MsgType.Response_Design_CounterChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    counterData = {}
}
MsgType.Response_Design_CounterChange.__index = MsgType.Response_Design_CounterChange
setmetatable(MsgType.Response_Design_CounterChange.counterData, MsgType.CounterData)

function MsgType.Response_Design_CounterChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.counterData = MsgType.CounterData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_CounterChange:GetCmd()
    return MsgTypeCmd.Response_Design_CounterChange_Cmd
end
function MsgType.Response_Design_CounterChange:GetUrl()
    return "Response_Design_CounterChange"
end
function MsgType.Response_Design_CounterChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.counterData:Decode(data.f)
    end
    return self
end


MsgType.Response_Design_FloorChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    floorData = {}
}
MsgType.Response_Design_FloorChange.__index = MsgType.Response_Design_FloorChange
setmetatable(MsgType.Response_Design_FloorChange.floorData, MsgType.FloorData)

function MsgType.Response_Design_FloorChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.floorData = MsgType.FloorData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_FloorChange:GetCmd()
    return MsgTypeCmd.Response_Design_FloorChange_Cmd
end
function MsgType.Response_Design_FloorChange:GetUrl()
    return "Response_Design_FloorChange"
end
function MsgType.Response_Design_FloorChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.floorData:Decode(data.f)
    end
    return self
end


MsgType.Response_Design_StoreBasketChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    storeBasket = {}
}
MsgType.Response_Design_StoreBasketChange.__index = MsgType.Response_Design_StoreBasketChange
setmetatable(MsgType.Response_Design_StoreBasketChange.storeBasket, MsgType.OneStoreBasket)

function MsgType.Response_Design_StoreBasketChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.storeBasket = MsgType.OneStoreBasket:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_StoreBasketChange:GetCmd()
    return MsgTypeCmd.Response_Design_StoreBasketChange_Cmd
end
function MsgType.Response_Design_StoreBasketChange:GetUrl()
    return "Response_Design_StoreBasketChange"
end
function MsgType.Response_Design_StoreBasketChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.storeBasket:Decode(data.f)
    end
    return self
end


MsgType.Response_Design_ResBasketChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    resBasket = {}
}
MsgType.Response_Design_ResBasketChange.__index = MsgType.Response_Design_ResBasketChange
setmetatable(MsgType.Response_Design_ResBasketChange.resBasket, MsgType.OneResBasket)

function MsgType.Response_Design_ResBasketChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.resBasket = MsgType.OneResBasket:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_ResBasketChange:GetCmd()
    return MsgTypeCmd.Response_Design_ResBasketChange_Cmd
end
function MsgType.Response_Design_ResBasketChange:GetUrl()
    return "Response_Design_ResBasketChange"
end
function MsgType.Response_Design_ResBasketChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.resBasket:Decode(data.f)
    end
    return self
end


MsgType.Response_Design_ShelfChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shelf = {}
}
MsgType.Response_Design_ShelfChange.__index = MsgType.Response_Design_ShelfChange
setmetatable(MsgType.Response_Design_ShelfChange.shelf, MsgType.OneShelf)

function MsgType.Response_Design_ShelfChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shelf = MsgType.OneShelf:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_ShelfChange:GetCmd()
    return MsgTypeCmd.Response_Design_ShelfChange_Cmd
end
function MsgType.Response_Design_ShelfChange:GetUrl()
    return "Response_Design_ShelfChange"
end
function MsgType.Response_Design_ShelfChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shelf:Decode(data.f)
    end
    return self
end


MsgType.Response_Design_FurnitureChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    furniture = {}
}
MsgType.Response_Design_FurnitureChange.__index = MsgType.Response_Design_FurnitureChange
setmetatable(MsgType.Response_Design_FurnitureChange.furniture, MsgType.OneFurniture)

function MsgType.Response_Design_FurnitureChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.furniture = MsgType.OneFurniture:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_FurnitureChange:GetCmd()
    return MsgTypeCmd.Response_Design_FurnitureChange_Cmd
end
function MsgType.Response_Design_FurnitureChange:GetUrl()
    return "Response_Design_FurnitureChange"
end
function MsgType.Response_Design_FurnitureChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.furniture:Decode(data.f)
    end
    return self
end


MsgType.Request_Design_OnShelf = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    shelfUid = 0,
    fieldId = 0,
    equipUid = ""
}
MsgType.Request_Design_OnShelf.__index = MsgType.Request_Design_OnShelf

function MsgType.Request_Design_OnShelf:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_OnShelf:GetCmd()
    return MsgTypeCmd.Request_Design_OnShelf_Cmd
end
function MsgType.Request_Design_OnShelf:GetUrl()
    return "Request_Design_OnShelf"
end
function MsgType.Request_Design_OnShelf:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.shelfUid and 0 ~= self.shelfUid then
        tb.d = self.shelfUid
    end
    if nil ~= self.fieldId and 0 ~= self.fieldId then
        tb.e = self.fieldId
    end
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.f = self.equipUid
    end
    return tb
end

function MsgType.Request_Design_OnShelf:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_OnShelf:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_OnShelf = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Design_OnShelf.__index = MsgType.Response_Design_OnShelf

function MsgType.Response_Design_OnShelf:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_OnShelf:GetCmd()
    return MsgTypeCmd.Response_Design_OnShelf_Cmd
end
function MsgType.Response_Design_OnShelf:GetUrl()
    return "Response_Design_OnShelf"
end
function MsgType.Response_Design_OnShelf:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Design_OffShelf = {
    msgSeq = 0,
    designType = 0, --enum EDesignType
    shelfUid = 0,
    fieldId = 0,
    equipUid = ""
}
MsgType.Request_Design_OffShelf.__index = MsgType.Request_Design_OffShelf

function MsgType.Request_Design_OffShelf:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Design_OffShelf:GetCmd()
    return MsgTypeCmd.Request_Design_OffShelf_Cmd
end
function MsgType.Request_Design_OffShelf:GetUrl()
    return "Request_Design_OffShelf"
end
function MsgType.Request_Design_OffShelf:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.designType and 0 ~= self.designType then
        tb.c = self.designType
    end
    if nil ~= self.shelfUid and 0 ~= self.shelfUid then
        tb.d = self.shelfUid
    end
    if nil ~= self.fieldId and 0 ~= self.fieldId then
        tb.e = self.fieldId
    end
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.f = self.equipUid
    end
    return tb
end

function MsgType.Request_Design_OffShelf:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Design_OffShelf:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Design_OffShelf = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Design_OffShelf.__index = MsgType.Response_Design_OffShelf

function MsgType.Response_Design_OffShelf:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_OffShelf:GetCmd()
    return MsgTypeCmd.Response_Design_OffShelf_Cmd
end
function MsgType.Response_Design_OffShelf:GetUrl()
    return "Response_Design_OffShelf"
end
function MsgType.Response_Design_OffShelf:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.EShelfEquipChangeType = {
    Off = 0,
    On = 1
}

MsgType.EShelfEquipChangeFrom = {
    Slot = 0,
    StoreBasket = 1
}

MsgType.Response_Design_ShelfEquipChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    isAuto = 0,
    shelfUid = 0,
    furnitureId = 0,
    onOrOff = 0,
    shelfEquip = {},
    isFromSlotOrBox = 0
}
MsgType.Response_Design_ShelfEquipChange.__index = MsgType.Response_Design_ShelfEquipChange
setmetatable(MsgType.Response_Design_ShelfEquipChange.shelfEquip, MsgType.ShelfEquip)

function MsgType.Response_Design_ShelfEquipChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shelfEquip = MsgType.ShelfEquip:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Design_ShelfEquipChange:GetCmd()
    return MsgTypeCmd.Response_Design_ShelfEquipChange_Cmd
end
function MsgType.Response_Design_ShelfEquipChange:GetUrl()
    return "Response_Design_ShelfEquipChange"
end
function MsgType.Response_Design_ShelfEquipChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.isAuto = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.shelfUid = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.furnitureId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.onOrOff = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.shelfEquip:Decode(data.j)
    end
    if nil ~= data.k then
        self.isFromSlotOrBox = tonumber(data.k) or 0
    end
    return self
end


MsgType.BagResource = {
    itemId = 0,
    count = 0,
    rarity = 0
}
MsgType.BagResource.__index = MsgType.BagResource

function MsgType.BagResource:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BagResource:Encode()
    local tb = {}
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.b = self.itemId
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    if nil ~= self.rarity and 0 ~= self.rarity then
        tb.d = self.rarity
    end
    return tb
end

function MsgType.BagResource:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.itemId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rarity = tonumber(data.d) or 0
    end
    return self
end

function MsgType.BagResource:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.BagResource:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.BagEquip = {
    equipUid = "",
    equipId = 0,
    count = 0,
    getTime = 0,
    isLock = 0,
    onShelfCount = 0
}
MsgType.BagEquip.__index = MsgType.BagEquip

function MsgType.BagEquip:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BagEquip:Encode()
    local tb = {}
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.b = self.equipUid
    end
    if nil ~= self.equipId and 0 ~= self.equipId then
        tb.c = self.equipId
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.d = self.count
    end
    if nil ~= self.getTime and 0 ~= self.getTime then
        tb.e = self.getTime
    end
    if nil ~= self.isLock and 0 ~= self.isLock then
        tb.f = self.isLock
    end
    if nil ~= self.onShelfCount and 0 ~= self.onShelfCount then
        tb.g = self.onShelfCount
    end
    return tb
end

function MsgType.BagEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.equipUid = tostring(data.b)
    end
    if nil ~= data.c then
        self.equipId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.count = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.getTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.isLock = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.onShelfCount = tonumber(data.g) or 0
    end
    return self
end

function MsgType.BagEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.BagEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.ResourceLimit = {
    itemId = 0,
    limitCount = 0
}
MsgType.ResourceLimit.__index = MsgType.ResourceLimit

function MsgType.ResourceLimit:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ResourceLimit:Encode()
    local tb = {}
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.b = self.itemId
    end
    if nil ~= self.limitCount and 0 ~= self.limitCount then
        tb.c = self.limitCount
    end
    return tb
end

function MsgType.ResourceLimit:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.itemId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.limitCount = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ResourceLimit:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ResourceLimit:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Bag_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Bag_Data.__index = MsgType.Request_Bag_Data

function MsgType.Request_Bag_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Bag_Data:GetCmd()
    return MsgTypeCmd.Request_Bag_Data_Cmd
end
function MsgType.Request_Bag_Data:GetUrl()
    return "Request_Bag_Data"
end
function MsgType.Request_Bag_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Bag_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Bag_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Bag_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    bagLimit = 0,
    resourceLimitList = {}, -- array of MsgType.ResourceLimit
    bagResourceList = {}, -- array of MsgType.BagResource
    bagEquipList = {} -- array of MsgType.BagEquip
}
MsgType.Response_Bag_Data.__index = MsgType.Response_Bag_Data

function MsgType.Response_Bag_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.resourceLimitList = {}
    tb.bagResourceList = {}
    tb.bagEquipList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Bag_Data:GetCmd()
    return MsgTypeCmd.Response_Bag_Data_Cmd
end
function MsgType.Response_Bag_Data:GetUrl()
    return "Response_Bag_Data"
end
function MsgType.Response_Bag_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.bagLimit = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpResourceLimitListObj = MsgType.ResourceLimit:New()
            tmpResourceLimitListObj:Decode(data.g[i])
            self.resourceLimitList[i] = tmpResourceLimitListObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpBagResourceListObj = MsgType.BagResource:New()
            tmpBagResourceListObj:Decode(data.h[i])
            self.bagResourceList[i] = tmpBagResourceListObj
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpBagEquipListObj = MsgType.BagEquip:New()
            tmpBagEquipListObj:Decode(data.i[i])
            self.bagEquipList[i] = tmpBagEquipListObj
        end
    end
    return self
end


MsgType.Response_Bag_ResourceChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    resource = {}
}
MsgType.Response_Bag_ResourceChange.__index = MsgType.Response_Bag_ResourceChange
setmetatable(MsgType.Response_Bag_ResourceChange.resource, MsgType.BagResource)

function MsgType.Response_Bag_ResourceChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.resource = MsgType.BagResource:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Bag_ResourceChange:GetCmd()
    return MsgTypeCmd.Response_Bag_ResourceChange_Cmd
end
function MsgType.Response_Bag_ResourceChange:GetUrl()
    return "Response_Bag_ResourceChange"
end
function MsgType.Response_Bag_ResourceChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.resource:Decode(data.f)
    end
    return self
end


MsgType.Request_Bag_Del = {
    msgSeq = 0,
    delType = 0,
    itemId = 0,
    equipUid = "",
    delCount = 0
}
MsgType.Request_Bag_Del.__index = MsgType.Request_Bag_Del

function MsgType.Request_Bag_Del:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Bag_Del:GetCmd()
    return MsgTypeCmd.Request_Bag_Del_Cmd
end
function MsgType.Request_Bag_Del:GetUrl()
    return "Request_Bag_Del"
end
function MsgType.Request_Bag_Del:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.delType and 0 ~= self.delType then
        tb.c = self.delType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.d = self.itemId
    end
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.e = self.equipUid
    end
    if nil ~= self.delCount and 0 ~= self.delCount then
        tb.f = self.delCount
    end
    return tb
end

function MsgType.Request_Bag_Del:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Bag_Del:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Bag_Del = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Bag_Del.__index = MsgType.Response_Bag_Del

function MsgType.Response_Bag_Del:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Bag_Del:GetCmd()
    return MsgTypeCmd.Response_Bag_Del_Cmd
end
function MsgType.Response_Bag_Del:GetUrl()
    return "Response_Bag_Del"
end
function MsgType.Response_Bag_Del:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Bag_LockEquip = {
    msgSeq = 0,
    equipUid = "",
    lockOrUnlock = 0
}
MsgType.Request_Bag_LockEquip.__index = MsgType.Request_Bag_LockEquip

function MsgType.Request_Bag_LockEquip:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Bag_LockEquip:GetCmd()
    return MsgTypeCmd.Request_Bag_LockEquip_Cmd
end
function MsgType.Request_Bag_LockEquip:GetUrl()
    return "Request_Bag_LockEquip"
end
function MsgType.Request_Bag_LockEquip:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.c = self.equipUid
    end
    if nil ~= self.lockOrUnlock and 0 ~= self.lockOrUnlock then
        tb.d = self.lockOrUnlock
    end
    return tb
end

function MsgType.Request_Bag_LockEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Bag_LockEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Bag_LockEquip = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Bag_LockEquip.__index = MsgType.Response_Bag_LockEquip

function MsgType.Response_Bag_LockEquip:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Bag_LockEquip:GetCmd()
    return MsgTypeCmd.Response_Bag_LockEquip_Cmd
end
function MsgType.Response_Bag_LockEquip:GetUrl()
    return "Response_Bag_LockEquip"
end
function MsgType.Response_Bag_LockEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.OneProduction = {
    itemId = 0,
    count = 0,
    lastCollectTime = 0,
    nextCollectTime = 0,
    collectSpeedTime = 0,
    countLimit = 0,
    lastBuyTime = 0,
    dailyBuyLimit = 0
}
MsgType.OneProduction.__index = MsgType.OneProduction

function MsgType.OneProduction:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneProduction:Encode()
    local tb = {}
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.b = self.itemId
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    if nil ~= self.lastCollectTime and 0 ~= self.lastCollectTime then
        tb.d = self.lastCollectTime
    end
    if nil ~= self.nextCollectTime and 0 ~= self.nextCollectTime then
        tb.e = self.nextCollectTime
    end
    if nil ~= self.collectSpeedTime and 0 ~= self.collectSpeedTime then
        tb.f = self.collectSpeedTime
    end
    if nil ~= self.countLimit and 0 ~= self.countLimit then
        tb.g = self.countLimit
    end
    if nil ~= self.lastBuyTime and 0 ~= self.lastBuyTime then
        tb.h = self.lastBuyTime
    end
    if nil ~= self.dailyBuyLimit and 0 ~= self.dailyBuyLimit then
        tb.i = self.dailyBuyLimit
    end
    return tb
end

function MsgType.OneProduction:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.itemId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.lastCollectTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.nextCollectTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.collectSpeedTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.countLimit = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.lastBuyTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.dailyBuyLimit = tonumber(data.i) or 0
    end
    return self
end

function MsgType.OneProduction:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneProduction:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Resource_ProductionList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Resource_ProductionList.__index = MsgType.Request_Resource_ProductionList

function MsgType.Request_Resource_ProductionList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Resource_ProductionList:GetCmd()
    return MsgTypeCmd.Request_Resource_ProductionList_Cmd
end
function MsgType.Request_Resource_ProductionList:GetUrl()
    return "Request_Resource_ProductionList"
end
function MsgType.Request_Resource_ProductionList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Resource_ProductionList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Resource_ProductionList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Resource_ProductionList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    productionList = {} -- array of MsgType.OneProduction
}
MsgType.Response_Resource_ProductionList.__index = MsgType.Response_Resource_ProductionList

function MsgType.Response_Resource_ProductionList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.productionList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Resource_ProductionList:GetCmd()
    return MsgTypeCmd.Response_Resource_ProductionList_Cmd
end
function MsgType.Response_Resource_ProductionList:GetUrl()
    return "Response_Resource_ProductionList"
end
function MsgType.Response_Resource_ProductionList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpProductionListObj = MsgType.OneProduction:New()
            tmpProductionListObj:Decode(data.f[i])
            self.productionList[i] = tmpProductionListObj
        end
    end
    return self
end


MsgType.Request_Resource_ProductionRefresh = {
    msgSeq = 0,
    itemId = 0
}
MsgType.Request_Resource_ProductionRefresh.__index = MsgType.Request_Resource_ProductionRefresh

function MsgType.Request_Resource_ProductionRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Resource_ProductionRefresh:GetCmd()
    return MsgTypeCmd.Request_Resource_ProductionRefresh_Cmd
end
function MsgType.Request_Resource_ProductionRefresh:GetUrl()
    return "Request_Resource_ProductionRefresh"
end
function MsgType.Request_Resource_ProductionRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    return tb
end

function MsgType.Request_Resource_ProductionRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Resource_ProductionRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Resource_ProductionRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    resource = {},
    production = {}
}
MsgType.Response_Resource_ProductionRefresh.__index = MsgType.Response_Resource_ProductionRefresh
setmetatable(MsgType.Response_Resource_ProductionRefresh.resource, MsgType.BagResource)
setmetatable(MsgType.Response_Resource_ProductionRefresh.production, MsgType.OneProduction)

function MsgType.Response_Resource_ProductionRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.resource = MsgType.BagResource:New()
    tb.production = MsgType.OneProduction:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Resource_ProductionRefresh:GetCmd()
    return MsgTypeCmd.Response_Resource_ProductionRefresh_Cmd
end
function MsgType.Response_Resource_ProductionRefresh:GetUrl()
    return "Response_Resource_ProductionRefresh"
end
function MsgType.Response_Resource_ProductionRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.resource:Decode(data.f)
    end
    if nil ~= data.g then
        self.production:Decode(data.g)
    end
    return self
end


MsgType.Request_Resource_BuyProduction = {
    msgSeq = 0,
    itemId = 0
}
MsgType.Request_Resource_BuyProduction.__index = MsgType.Request_Resource_BuyProduction

function MsgType.Request_Resource_BuyProduction:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Resource_BuyProduction:GetCmd()
    return MsgTypeCmd.Request_Resource_BuyProduction_Cmd
end
function MsgType.Request_Resource_BuyProduction:GetUrl()
    return "Request_Resource_BuyProduction"
end
function MsgType.Request_Resource_BuyProduction:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    return tb
end

function MsgType.Request_Resource_BuyProduction:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Resource_BuyProduction:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Resource_BuyProduction = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    resource = {}
}
MsgType.Response_Resource_BuyProduction.__index = MsgType.Response_Resource_BuyProduction
setmetatable(MsgType.Response_Resource_BuyProduction.resource, MsgType.BagResource)

function MsgType.Response_Resource_BuyProduction:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.resource = MsgType.BagResource:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Resource_BuyProduction:GetCmd()
    return MsgTypeCmd.Response_Resource_BuyProduction_Cmd
end
function MsgType.Response_Resource_BuyProduction:GetUrl()
    return "Response_Resource_BuyProduction"
end
function MsgType.Response_Resource_BuyProduction:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.resource:Decode(data.f)
    end
    return self
end


MsgType.Request_Resource_BuyProductionDaily = {
    msgSeq = 0,
    itemId = 0
}
MsgType.Request_Resource_BuyProductionDaily.__index = MsgType.Request_Resource_BuyProductionDaily

function MsgType.Request_Resource_BuyProductionDaily:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Resource_BuyProductionDaily:GetCmd()
    return MsgTypeCmd.Request_Resource_BuyProductionDaily_Cmd
end
function MsgType.Request_Resource_BuyProductionDaily:GetUrl()
    return "Request_Resource_BuyProductionDaily"
end
function MsgType.Request_Resource_BuyProductionDaily:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    return tb
end

function MsgType.Request_Resource_BuyProductionDaily:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Resource_BuyProductionDaily:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Resource_BuyProductionDaily = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    resource = {}
}
MsgType.Response_Resource_BuyProductionDaily.__index = MsgType.Response_Resource_BuyProductionDaily
setmetatable(MsgType.Response_Resource_BuyProductionDaily.resource, MsgType.BagResource)

function MsgType.Response_Resource_BuyProductionDaily:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.resource = MsgType.BagResource:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Resource_BuyProductionDaily:GetCmd()
    return MsgTypeCmd.Response_Resource_BuyProductionDaily_Cmd
end
function MsgType.Response_Resource_BuyProductionDaily:GetUrl()
    return "Response_Resource_BuyProductionDaily"
end
function MsgType.Response_Resource_BuyProductionDaily:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.resource:Decode(data.f)
    end
    return self
end


MsgType.Response_Resource_ProductionChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    production = {}
}
MsgType.Response_Resource_ProductionChange.__index = MsgType.Response_Resource_ProductionChange
setmetatable(MsgType.Response_Resource_ProductionChange.production, MsgType.OneProduction)

function MsgType.Response_Resource_ProductionChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.production = MsgType.OneProduction:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Resource_ProductionChange:GetCmd()
    return MsgTypeCmd.Response_Resource_ProductionChange_Cmd
end
function MsgType.Response_Resource_ProductionChange:GetUrl()
    return "Response_Resource_ProductionChange"
end
function MsgType.Response_Resource_ProductionChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.production:Decode(data.f)
    end
    return self
end


MsgType.EEquipInfoState = {
    NotUnlock = 0,
    UnlockNotActivate = 1,
    Activated = 2
}

MsgType.EquipInfo = {
    equipDrawingId = 0,
    equipState = 0, --enum EEquipInfoState
    beenMake = 0,
    progressLevel = 0,
    lastMakeTime = 0,
    activateTime = 0,
    unlockTime = 0,
    isFavorite = 0,
    makeNeedTime = 0,
    starLevel = 0
}
MsgType.EquipInfo.__index = MsgType.EquipInfo

function MsgType.EquipInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.EquipInfo:Encode()
    local tb = {}
    if nil ~= self.equipDrawingId and 0 ~= self.equipDrawingId then
        tb.b = self.equipDrawingId
    end
    if nil ~= self.equipState and 0 ~= self.equipState then
        tb.c = self.equipState
    end
    if nil ~= self.beenMake and 0 ~= self.beenMake then
        tb.d = self.beenMake
    end
    if nil ~= self.progressLevel and 0 ~= self.progressLevel then
        tb.e = self.progressLevel
    end
    if nil ~= self.lastMakeTime and 0 ~= self.lastMakeTime then
        tb.f = self.lastMakeTime
    end
    if nil ~= self.activateTime and 0 ~= self.activateTime then
        tb.g = self.activateTime
    end
    if nil ~= self.unlockTime and 0 ~= self.unlockTime then
        tb.h = self.unlockTime
    end
    if nil ~= self.isFavorite and 0 ~= self.isFavorite then
        tb.i = self.isFavorite
    end
    if nil ~= self.makeNeedTime and 0 ~= self.makeNeedTime then
        tb.j = self.makeNeedTime
    end
    if nil ~= self.starLevel and 0 ~= self.starLevel then
        tb.k = self.starLevel
    end
    return tb
end

function MsgType.EquipInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.equipDrawingId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.equipState = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.beenMake = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.progressLevel = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.lastMakeTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.activateTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unlockTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.isFavorite = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.makeNeedTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.starLevel = tonumber(data.k) or 0
    end
    return self
end

function MsgType.EquipInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.EquipInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.EMakingState = {
    Idle = 0,
    Making = 1,
    Finish = 2
}

MsgType.MakingSlot = {
    slotId = 0,
    equipDrawingId = 0,
    startTime = 0,
    endTime = 0,
    remainTime = 0,
    makingState = 0 --enum EMakingState
}
MsgType.MakingSlot.__index = MsgType.MakingSlot

function MsgType.MakingSlot:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MakingSlot:Encode()
    local tb = {}
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.b = self.slotId
    end
    if nil ~= self.equipDrawingId and 0 ~= self.equipDrawingId then
        tb.c = self.equipDrawingId
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.d = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.e = self.endTime
    end
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.f = self.remainTime
    end
    if nil ~= self.makingState and 0 ~= self.makingState then
        tb.g = self.makingState
    end
    return tb
end

function MsgType.MakingSlot:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.slotId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.equipDrawingId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.startTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.endTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.remainTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.makingState = tonumber(data.g) or 0
    end
    return self
end

function MsgType.MakingSlot:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.MakingSlot:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Equip_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Equip_Data.__index = MsgType.Request_Equip_Data

function MsgType.Request_Equip_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_Data:GetCmd()
    return MsgTypeCmd.Request_Equip_Data_Cmd
end
function MsgType.Request_Equip_Data:GetUrl()
    return "Request_Equip_Data"
end
function MsgType.Request_Equip_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Equip_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    equipList = {}, -- array of MsgType.EquipInfo
    makingList = {} -- array of MsgType.MakingSlot
}
MsgType.Response_Equip_Data.__index = MsgType.Response_Equip_Data

function MsgType.Response_Equip_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.equipList = {}
    tb.makingList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_Data:GetCmd()
    return MsgTypeCmd.Response_Equip_Data_Cmd
end
function MsgType.Response_Equip_Data:GetUrl()
    return "Response_Equip_Data"
end
function MsgType.Response_Equip_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpEquipListObj = MsgType.EquipInfo:New()
            tmpEquipListObj:Decode(data.f[i])
            self.equipList[i] = tmpEquipListObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpMakingListObj = MsgType.MakingSlot:New()
            tmpMakingListObj:Decode(data.g[i])
            self.makingList[i] = tmpMakingListObj
        end
    end
    return self
end


MsgType.Response_Equip_BagEquipChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    bagEquip = {}
}
MsgType.Response_Equip_BagEquipChange.__index = MsgType.Response_Equip_BagEquipChange
setmetatable(MsgType.Response_Equip_BagEquipChange.bagEquip, MsgType.BagEquip)

function MsgType.Response_Equip_BagEquipChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.bagEquip = MsgType.BagEquip:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_BagEquipChange:GetCmd()
    return MsgTypeCmd.Response_Equip_BagEquipChange_Cmd
end
function MsgType.Response_Equip_BagEquipChange:GetUrl()
    return "Response_Equip_BagEquipChange"
end
function MsgType.Response_Equip_BagEquipChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.bagEquip:Decode(data.f)
    end
    return self
end


MsgType.Response_Equip_EquipInfoChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    equipInfo = {},
    quiet = 0
}
MsgType.Response_Equip_EquipInfoChange.__index = MsgType.Response_Equip_EquipInfoChange
setmetatable(MsgType.Response_Equip_EquipInfoChange.equipInfo, MsgType.EquipInfo)

function MsgType.Response_Equip_EquipInfoChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.equipInfo = MsgType.EquipInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_EquipInfoChange:GetCmd()
    return MsgTypeCmd.Response_Equip_EquipInfoChange_Cmd
end
function MsgType.Response_Equip_EquipInfoChange:GetUrl()
    return "Response_Equip_EquipInfoChange"
end
function MsgType.Response_Equip_EquipInfoChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.equipInfo:Decode(data.f)
    end
    if nil ~= data.g then
        self.quiet = tonumber(data.g) or 0
    end
    return self
end


MsgType.MakeStartSlot = {
    slotId = 0,
    equipDrawingId = 0,
    startTime = 0
}
MsgType.MakeStartSlot.__index = MsgType.MakeStartSlot

function MsgType.MakeStartSlot:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.MakeStartSlot:Encode()
    local tb = {}
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.b = self.slotId
    end
    if nil ~= self.equipDrawingId and 0 ~= self.equipDrawingId then
        tb.c = self.equipDrawingId
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.d = self.startTime
    end
    return tb
end

function MsgType.MakeStartSlot:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.slotId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.equipDrawingId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.startTime = tonumber(data.d) or 0
    end
    return self
end

function MsgType.MakeStartSlot:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.MakeStartSlot:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Equip_MakeStart = {
    msgSeq = 0,
    makeStartList = {} -- array of MsgType.MakeStartSlot
}
MsgType.Request_Equip_MakeStart.__index = MsgType.Request_Equip_MakeStart

function MsgType.Request_Equip_MakeStart:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.makeStartList = {}
    return tb
end

function MsgType.Request_Equip_MakeStart:GetCmd()
    return MsgTypeCmd.Request_Equip_MakeStart_Cmd
end
function MsgType.Request_Equip_MakeStart:GetUrl()
    return "Request_Equip_MakeStart"
end
function MsgType.Request_Equip_MakeStart:_makeStartListEncode()
    local tb = {}
    for i=1, #self.makeStartList do
        tb[i] = self.makeStartList[i]:Encode()
    end
    return tb
end
function MsgType.Request_Equip_MakeStart:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    tb.c = self:_makeStartListEncode()
    return tb
end

function MsgType.Request_Equip_MakeStart:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_MakeStart:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_MakeStart = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    makingList = {} -- array of MsgType.MakingSlot
}
MsgType.Response_Equip_MakeStart.__index = MsgType.Response_Equip_MakeStart

function MsgType.Response_Equip_MakeStart:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.makingList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_MakeStart:GetCmd()
    return MsgTypeCmd.Response_Equip_MakeStart_Cmd
end
function MsgType.Response_Equip_MakeStart:GetUrl()
    return "Response_Equip_MakeStart"
end
function MsgType.Response_Equip_MakeStart:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpMakingListObj = MsgType.MakingSlot:New()
            tmpMakingListObj:Decode(data.f[i])
            self.makingList[i] = tmpMakingListObj
        end
    end
    return self
end


MsgType.Request_Equip_MakeRefresh = {
    msgSeq = 0,
    slotId = 0
}
MsgType.Request_Equip_MakeRefresh.__index = MsgType.Request_Equip_MakeRefresh

function MsgType.Request_Equip_MakeRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_MakeRefresh:GetCmd()
    return MsgTypeCmd.Request_Equip_MakeRefresh_Cmd
end
function MsgType.Request_Equip_MakeRefresh:GetUrl()
    return "Request_Equip_MakeRefresh"
end
function MsgType.Request_Equip_MakeRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.c = self.slotId
    end
    return tb
end

function MsgType.Request_Equip_MakeRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_MakeRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_MakeRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    makingSlot = {}
}
MsgType.Response_Equip_MakeRefresh.__index = MsgType.Response_Equip_MakeRefresh
setmetatable(MsgType.Response_Equip_MakeRefresh.makingSlot, MsgType.MakingSlot)

function MsgType.Response_Equip_MakeRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.makingSlot = MsgType.MakingSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_MakeRefresh:GetCmd()
    return MsgTypeCmd.Response_Equip_MakeRefresh_Cmd
end
function MsgType.Response_Equip_MakeRefresh:GetUrl()
    return "Response_Equip_MakeRefresh"
end
function MsgType.Response_Equip_MakeRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.makingSlot:Decode(data.f)
    end
    return self
end


MsgType.EMakingStarEffectType = {
    None = 0,
    Return = 1,
    Double = 2,
    Upgrade = 3
}

MsgType.Request_Equip_MakeEnd = {
    msgSeq = 0,
    slotId = 0
}
MsgType.Request_Equip_MakeEnd.__index = MsgType.Request_Equip_MakeEnd

function MsgType.Request_Equip_MakeEnd:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_MakeEnd:GetCmd()
    return MsgTypeCmd.Request_Equip_MakeEnd_Cmd
end
function MsgType.Request_Equip_MakeEnd:GetUrl()
    return "Request_Equip_MakeEnd"
end
function MsgType.Request_Equip_MakeEnd:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.c = self.slotId
    end
    return tb
end

function MsgType.Request_Equip_MakeEnd:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_MakeEnd:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_MakeEnd = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    makingSlot = {},
    bagEquip = {},
    rewardPiece = 0,
    equipInfo = {},
    makeExp = 0,
    toStoreBasket = 0,
    starEffectType = 0 --enum EMakingStarEffectType
}
MsgType.Response_Equip_MakeEnd.__index = MsgType.Response_Equip_MakeEnd
setmetatable(MsgType.Response_Equip_MakeEnd.makingSlot, MsgType.MakingSlot)
setmetatable(MsgType.Response_Equip_MakeEnd.bagEquip, MsgType.BagEquip)
setmetatable(MsgType.Response_Equip_MakeEnd.equipInfo, MsgType.EquipInfo)

function MsgType.Response_Equip_MakeEnd:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.makingSlot = MsgType.MakingSlot:New()
    tb.bagEquip = MsgType.BagEquip:New()
    tb.equipInfo = MsgType.EquipInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_MakeEnd:GetCmd()
    return MsgTypeCmd.Response_Equip_MakeEnd_Cmd
end
function MsgType.Response_Equip_MakeEnd:GetUrl()
    return "Response_Equip_MakeEnd"
end
function MsgType.Response_Equip_MakeEnd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.makingSlot:Decode(data.f)
    end
    if nil ~= data.g then
        self.bagEquip:Decode(data.g)
    end
    if nil ~= data.h then
        self.rewardPiece = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.equipInfo:Decode(data.i)
    end
    if nil ~= data.j then
        self.makeExp = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.toStoreBasket = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.starEffectType = tonumber(data.l) or 0
    end
    return self
end


MsgType.Request_Equip_MakeFaster = {
    msgSeq = 0,
    slotId = 0,
    useGem = 0
}
MsgType.Request_Equip_MakeFaster.__index = MsgType.Request_Equip_MakeFaster

function MsgType.Request_Equip_MakeFaster:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_MakeFaster:GetCmd()
    return MsgTypeCmd.Request_Equip_MakeFaster_Cmd
end
function MsgType.Request_Equip_MakeFaster:GetUrl()
    return "Request_Equip_MakeFaster"
end
function MsgType.Request_Equip_MakeFaster:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.c = self.slotId
    end
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.d = self.useGem
    end
    return tb
end

function MsgType.Request_Equip_MakeFaster:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_MakeFaster:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_MakeFaster = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    makingSlot = {}
}
MsgType.Response_Equip_MakeFaster.__index = MsgType.Response_Equip_MakeFaster
setmetatable(MsgType.Response_Equip_MakeFaster.makingSlot, MsgType.MakingSlot)

function MsgType.Response_Equip_MakeFaster:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.makingSlot = MsgType.MakingSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_MakeFaster:GetCmd()
    return MsgTypeCmd.Response_Equip_MakeFaster_Cmd
end
function MsgType.Response_Equip_MakeFaster:GetUrl()
    return "Response_Equip_MakeFaster"
end
function MsgType.Response_Equip_MakeFaster:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.makingSlot:Decode(data.f)
    end
    return self
end


MsgType.Request_Equip_MakeImprove = {
    msgSeq = 0,
    equipUid = ""
}
MsgType.Request_Equip_MakeImprove.__index = MsgType.Request_Equip_MakeImprove

function MsgType.Request_Equip_MakeImprove:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_MakeImprove:GetCmd()
    return MsgTypeCmd.Request_Equip_MakeImprove_Cmd
end
function MsgType.Request_Equip_MakeImprove:GetUrl()
    return "Request_Equip_MakeImprove"
end
function MsgType.Request_Equip_MakeImprove:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.c = self.equipUid
    end
    return tb
end

function MsgType.Request_Equip_MakeImprove:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_MakeImprove:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_MakeImprove = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    bagEquip = {}
}
MsgType.Response_Equip_MakeImprove.__index = MsgType.Response_Equip_MakeImprove
setmetatable(MsgType.Response_Equip_MakeImprove.bagEquip, MsgType.BagEquip)

function MsgType.Response_Equip_MakeImprove:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.bagEquip = MsgType.BagEquip:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_MakeImprove:GetCmd()
    return MsgTypeCmd.Response_Equip_MakeImprove_Cmd
end
function MsgType.Response_Equip_MakeImprove:GetUrl()
    return "Response_Equip_MakeImprove"
end
function MsgType.Response_Equip_MakeImprove:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.bagEquip:Decode(data.f)
    end
    return self
end


MsgType.Request_Equip_BuySlot = {
    msgSeq = 0,
    useGem = 0
}
MsgType.Request_Equip_BuySlot.__index = MsgType.Request_Equip_BuySlot

function MsgType.Request_Equip_BuySlot:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_BuySlot:GetCmd()
    return MsgTypeCmd.Request_Equip_BuySlot_Cmd
end
function MsgType.Request_Equip_BuySlot:GetUrl()
    return "Request_Equip_BuySlot"
end
function MsgType.Request_Equip_BuySlot:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.c = self.useGem
    end
    return tb
end

function MsgType.Request_Equip_BuySlot:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_BuySlot:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_BuySlot = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    makingSlot = {}
}
MsgType.Response_Equip_BuySlot.__index = MsgType.Response_Equip_BuySlot
setmetatable(MsgType.Response_Equip_BuySlot.makingSlot, MsgType.MakingSlot)

function MsgType.Response_Equip_BuySlot:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.makingSlot = MsgType.MakingSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_BuySlot:GetCmd()
    return MsgTypeCmd.Response_Equip_BuySlot_Cmd
end
function MsgType.Response_Equip_BuySlot:GetUrl()
    return "Response_Equip_BuySlot"
end
function MsgType.Response_Equip_BuySlot:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.makingSlot:Decode(data.f)
    end
    return self
end


MsgType.Request_Equip_Activate = {
    msgSeq = 0,
    equipDrawingId = 0
}
MsgType.Request_Equip_Activate.__index = MsgType.Request_Equip_Activate

function MsgType.Request_Equip_Activate:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_Activate:GetCmd()
    return MsgTypeCmd.Request_Equip_Activate_Cmd
end
function MsgType.Request_Equip_Activate:GetUrl()
    return "Request_Equip_Activate"
end
function MsgType.Request_Equip_Activate:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.equipDrawingId and 0 ~= self.equipDrawingId then
        tb.c = self.equipDrawingId
    end
    return tb
end

function MsgType.Request_Equip_Activate:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_Activate:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_Activate = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    equipInfo = {}
}
MsgType.Response_Equip_Activate.__index = MsgType.Response_Equip_Activate
setmetatable(MsgType.Response_Equip_Activate.equipInfo, MsgType.EquipInfo)

function MsgType.Response_Equip_Activate:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.equipInfo = MsgType.EquipInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_Activate:GetCmd()
    return MsgTypeCmd.Response_Equip_Activate_Cmd
end
function MsgType.Response_Equip_Activate:GetUrl()
    return "Response_Equip_Activate"
end
function MsgType.Response_Equip_Activate:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.equipInfo:Decode(data.f)
    end
    return self
end


MsgType.Request_Equip_FavoriteEquip = {
    msgSeq = 0,
    equipDrawingId = 0,
    favorite = 0
}
MsgType.Request_Equip_FavoriteEquip.__index = MsgType.Request_Equip_FavoriteEquip

function MsgType.Request_Equip_FavoriteEquip:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Equip_FavoriteEquip:GetCmd()
    return MsgTypeCmd.Request_Equip_FavoriteEquip_Cmd
end
function MsgType.Request_Equip_FavoriteEquip:GetUrl()
    return "Request_Equip_FavoriteEquip"
end
function MsgType.Request_Equip_FavoriteEquip:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.equipDrawingId and 0 ~= self.equipDrawingId then
        tb.c = self.equipDrawingId
    end
    if nil ~= self.favorite and 0 ~= self.favorite then
        tb.d = self.favorite
    end
    return tb
end

function MsgType.Request_Equip_FavoriteEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Equip_FavoriteEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Equip_FavoriteEquip = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Equip_FavoriteEquip.__index = MsgType.Response_Equip_FavoriteEquip

function MsgType.Response_Equip_FavoriteEquip:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_FavoriteEquip:GetCmd()
    return MsgTypeCmd.Response_Equip_FavoriteEquip_Cmd
end
function MsgType.Response_Equip_FavoriteEquip:GetUrl()
    return "Response_Equip_FavoriteEquip"
end
function MsgType.Response_Equip_FavoriteEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Response_Equip_MakingList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    makingList = {} -- array of MsgType.MakingSlot
}
MsgType.Response_Equip_MakingList.__index = MsgType.Response_Equip_MakingList

function MsgType.Response_Equip_MakingList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.makingList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Equip_MakingList:GetCmd()
    return MsgTypeCmd.Response_Equip_MakingList_Cmd
end
function MsgType.Response_Equip_MakingList:GetUrl()
    return "Response_Equip_MakingList"
end
function MsgType.Response_Equip_MakingList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpMakingListObj = MsgType.MakingSlot:New()
            tmpMakingListObj:Decode(data.f[i])
            self.makingList[i] = tmpMakingListObj
        end
    end
    return self
end


MsgType.EDailyTaskType = {
    SellItem = 1,
    MakeItem = 2,
    Double = 3,
    Discount = 4,
    Chat = 5,
    Promote = 6,
    SellAmount = 7,
    ExploreItem = 8,
    MarketSellGold = 9,
    MarketSellEquip = 10,
    ExploreHero = 11,
    RefreshBar = 12,
    BuildCost = 13,
    ScienceCost = 14,
    Gacha = 15
}

MsgType.EDailyTaskState = {
    Doing = 0,
    Reached = 1
}

MsgType.OneDailyTask = {
    taskId = 0,
    taskType = 0, --enum EDailyTaskType
    taskState = 0, --enum EDailyTaskState
    taskTarget = 0,
    taskCondition = 0,
    taskProgress = 0,
    rewardId = 0,
    rewardNumber = 0
}
MsgType.OneDailyTask.__index = MsgType.OneDailyTask

function MsgType.OneDailyTask:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneDailyTask:Encode()
    local tb = {}
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.b = self.taskId
    end
    if nil ~= self.taskType and 0 ~= self.taskType then
        tb.c = self.taskType
    end
    if nil ~= self.taskState and 0 ~= self.taskState then
        tb.d = self.taskState
    end
    if nil ~= self.taskTarget and 0 ~= self.taskTarget then
        tb.e = self.taskTarget
    end
    if nil ~= self.taskCondition and 0 ~= self.taskCondition then
        tb.f = self.taskCondition
    end
    if nil ~= self.taskProgress and 0 ~= self.taskProgress then
        tb.g = self.taskProgress
    end
    if nil ~= self.rewardId and 0 ~= self.rewardId then
        tb.h = self.rewardId
    end
    if nil ~= self.rewardNumber and 0 ~= self.rewardNumber then
        tb.i = self.rewardNumber
    end
    return tb
end

function MsgType.OneDailyTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.taskId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskState = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.taskTarget = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.taskCondition = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.taskProgress = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.rewardId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.rewardNumber = tonumber(data.i) or 0
    end
    return self
end

function MsgType.OneDailyTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneDailyTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneActiveRewarditem = {
    id = 0,
    count = 0,
    chance = 0
}
MsgType.OneActiveRewarditem.__index = MsgType.OneActiveRewarditem

function MsgType.OneActiveRewarditem:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneActiveRewarditem:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.c = self.count
    end
    if nil ~= self.chance and 0 ~= self.chance then
        tb.d = self.chance
    end
    return tb
end

function MsgType.OneActiveRewarditem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.count = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.chance = tonumber(data.d) or 0
    end
    return self
end

function MsgType.OneActiveRewarditem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneActiveRewarditem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneActiveReward = {
    activeRewardId = 0,
    activeRewardState = 0,
    activeRewardItemLimit = 0,
    activeRewardItem = {},
    activeRewardItemList = {} -- array of MsgType.OneActiveRewarditem
}
MsgType.OneActiveReward.__index = MsgType.OneActiveReward
setmetatable(MsgType.OneActiveReward.activeRewardItem, MsgType.OneActiveRewarditem)

function MsgType.OneActiveReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.activeRewardItem = MsgType.OneActiveRewarditem:New()
    tb.activeRewardItemList = {}
    return tb
end

function MsgType.OneActiveReward:_activeRewardItemListEncode()
    local tb = {}
    for i=1, #self.activeRewardItemList do
        tb[i] = self.activeRewardItemList[i]:Encode()
    end
    return tb
end
function MsgType.OneActiveReward:Encode()
    local tb = {}
    if nil ~= self.activeRewardId and 0 ~= self.activeRewardId then
        tb.b = self.activeRewardId
    end
    if nil ~= self.activeRewardState and 0 ~= self.activeRewardState then
        tb.c = self.activeRewardState
    end
    if nil ~= self.activeRewardItemLimit and 0 ~= self.activeRewardItemLimit then
        tb.d = self.activeRewardItemLimit
    end
    tb.e = self.activeRewardItem:Encode()
    tb.f = self:_activeRewardItemListEncode()
    return tb
end

function MsgType.OneActiveReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.activeRewardId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.activeRewardState = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.activeRewardItemLimit = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.activeRewardItem:Decode(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpActiveRewardItemListObj = MsgType.OneActiveRewarditem:New()
            tmpActiveRewardItemListObj:Decode(data.f[i])
            self.activeRewardItemList[i] = tmpActiveRewardItemListObj
        end
    end
    return self
end

function MsgType.OneActiveReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneActiveReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_DailyTask_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_DailyTask_Data.__index = MsgType.Request_DailyTask_Data

function MsgType.Request_DailyTask_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_DailyTask_Data:GetCmd()
    return MsgTypeCmd.Request_DailyTask_Data_Cmd
end
function MsgType.Request_DailyTask_Data:GetUrl()
    return "Request_DailyTask_Data"
end
function MsgType.Request_DailyTask_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_DailyTask_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_DailyTask_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_DailyTask_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneDailyTask
    nextTime = 0,
    refreshTime = 0,
    refreshNumber = 0,
    activeRewardTime = 0,
    activePoint = 0,
    activeRewardList = {}, -- array of MsgType.OneActiveReward
    activeRefreshTime = 0
}
MsgType.Response_DailyTask_Data.__index = MsgType.Response_DailyTask_Data

function MsgType.Response_DailyTask_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.activeRewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_DailyTask_Data:GetCmd()
    return MsgTypeCmd.Response_DailyTask_Data_Cmd
end
function MsgType.Response_DailyTask_Data:GetUrl()
    return "Response_DailyTask_Data"
end
function MsgType.Response_DailyTask_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneDailyTask:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.nextTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.refreshTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.refreshNumber = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.activeRewardTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.activePoint = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        for i=1, #data.l do
            local tmpActiveRewardListObj = MsgType.OneActiveReward:New()
            tmpActiveRewardListObj:Decode(data.l[i])
            self.activeRewardList[i] = tmpActiveRewardListObj
        end
    end
    if nil ~= data.m then
        self.activeRefreshTime = tonumber(data.m) or 0
    end
    return self
end


MsgType.Request_DailyTask_Reward = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_DailyTask_Reward.__index = MsgType.Request_DailyTask_Reward

function MsgType.Request_DailyTask_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_DailyTask_Reward:GetCmd()
    return MsgTypeCmd.Request_DailyTask_Reward_Cmd
end
function MsgType.Request_DailyTask_Reward:GetUrl()
    return "Request_DailyTask_Reward"
end
function MsgType.Request_DailyTask_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_DailyTask_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_DailyTask_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_DailyTask_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneDailyTask
    nextTime = 0,
    refreshTime = 0,
    refreshNumber = 0,
    itemList = {}, -- array of MsgType.OneRewardItem
    activeRewardTime = 0,
    activePoint = 0,
    activeRewardList = {}, -- array of MsgType.OneActiveReward
    taskId = 0
}
MsgType.Response_DailyTask_Reward.__index = MsgType.Response_DailyTask_Reward

function MsgType.Response_DailyTask_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.itemList = {}
    tb.activeRewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_DailyTask_Reward:GetCmd()
    return MsgTypeCmd.Response_DailyTask_Reward_Cmd
end
function MsgType.Response_DailyTask_Reward:GetUrl()
    return "Response_DailyTask_Reward"
end
function MsgType.Response_DailyTask_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneDailyTask:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.nextTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.refreshTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.refreshNumber = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.j[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.k then
        self.activeRewardTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.activePoint = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        for i=1, #data.m do
            local tmpActiveRewardListObj = MsgType.OneActiveReward:New()
            tmpActiveRewardListObj:Decode(data.m[i])
            self.activeRewardList[i] = tmpActiveRewardListObj
        end
    end
    if nil ~= data.n then
        self.taskId = tonumber(data.n) or 0
    end
    return self
end


MsgType.Request_Active_Reward = {
    msgSeq = 0,
    activeRewardId = 0
}
MsgType.Request_Active_Reward.__index = MsgType.Request_Active_Reward

function MsgType.Request_Active_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Active_Reward:GetCmd()
    return MsgTypeCmd.Request_Active_Reward_Cmd
end
function MsgType.Request_Active_Reward:GetUrl()
    return "Request_Active_Reward"
end
function MsgType.Request_Active_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.activeRewardId and 0 ~= self.activeRewardId then
        tb.c = self.activeRewardId
    end
    return tb
end

function MsgType.Request_Active_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Active_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Active_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneDailyTask
    nextTime = 0,
    refreshTime = 0,
    refreshNumber = 0,
    itemList = {}, -- array of MsgType.OneRewardItem
    activeRewardTime = 0,
    activePoint = 0,
    activeRewardList = {} -- array of MsgType.OneActiveReward
}
MsgType.Response_Active_Reward.__index = MsgType.Response_Active_Reward

function MsgType.Response_Active_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.itemList = {}
    tb.activeRewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Active_Reward:GetCmd()
    return MsgTypeCmd.Response_Active_Reward_Cmd
end
function MsgType.Response_Active_Reward:GetUrl()
    return "Response_Active_Reward"
end
function MsgType.Response_Active_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneDailyTask:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.nextTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.refreshTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.refreshNumber = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.j[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.k then
        self.activeRewardTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.activePoint = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        for i=1, #data.m do
            local tmpActiveRewardListObj = MsgType.OneActiveReward:New()
            tmpActiveRewardListObj:Decode(data.m[i])
            self.activeRewardList[i] = tmpActiveRewardListObj
        end
    end
    return self
end


MsgType.Request_DailyTask_Refresh = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_DailyTask_Refresh.__index = MsgType.Request_DailyTask_Refresh

function MsgType.Request_DailyTask_Refresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_DailyTask_Refresh:GetCmd()
    return MsgTypeCmd.Request_DailyTask_Refresh_Cmd
end
function MsgType.Request_DailyTask_Refresh:GetUrl()
    return "Request_DailyTask_Refresh"
end
function MsgType.Request_DailyTask_Refresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_DailyTask_Refresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_DailyTask_Refresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_DailyTask_Refresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneDailyTask
    nextTime = 0,
    refreshTime = 0,
    refreshNumber = 0,
    activeRewardTime = 0,
    activePoint = 0,
    activeRewardList = {} -- array of MsgType.OneActiveReward
}
MsgType.Response_DailyTask_Refresh.__index = MsgType.Response_DailyTask_Refresh

function MsgType.Response_DailyTask_Refresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.activeRewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_DailyTask_Refresh:GetCmd()
    return MsgTypeCmd.Response_DailyTask_Refresh_Cmd
end
function MsgType.Response_DailyTask_Refresh:GetUrl()
    return "Response_DailyTask_Refresh"
end
function MsgType.Response_DailyTask_Refresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneDailyTask:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.nextTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.refreshTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.refreshNumber = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.activeRewardTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.activePoint = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        for i=1, #data.l do
            local tmpActiveRewardListObj = MsgType.OneActiveReward:New()
            tmpActiveRewardListObj:Decode(data.l[i])
            self.activeRewardList[i] = tmpActiveRewardListObj
        end
    end
    return self
end


MsgType.Response_DailyTask_Change = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    task = {}
}
MsgType.Response_DailyTask_Change.__index = MsgType.Response_DailyTask_Change
setmetatable(MsgType.Response_DailyTask_Change.task, MsgType.OneDailyTask)

function MsgType.Response_DailyTask_Change:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.task = MsgType.OneDailyTask:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_DailyTask_Change:GetCmd()
    return MsgTypeCmd.Response_DailyTask_Change_Cmd
end
function MsgType.Response_DailyTask_Change:GetUrl()
    return "Response_DailyTask_Change"
end
function MsgType.Response_DailyTask_Change:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.task:Decode(data.f)
    end
    return self
end


MsgType.ETriggerGuideEffectType = {
    AddEquip = 1,
    AddItem = 2,
    BuyFreeFurniture = 3,
    UpgradeFurniture = 4,
    FinishFurniture = 5,
    RarePrize = 6
}

MsgType.EAchievementType = {
    BaseLevel = 1,
    SellItem = 2,
    MakeItem = 3,
    DungeonClear = 4,
    HelpNum = 5,
    SellAmountNumOnce = 6,
    GachaRankHero = 7,
    GachaNum = 8,
    HeroLevel = 9,
    HeroChangeJob = 10,
    UnlockWorker = 11,
    Furniture1Level = 121,
    Furniture2Level = 122,
    Furniture3Level = 123,
    UseNormalRes = 13,
    UseRareRes = 14,
    UseSRareRes = 15,
    DungeonDropRes = 16,
    DefeatDungeonBoss = 17,
    ItemStarRaise = 18,
    MasterNum = 19,
    ShopLevel = 20,
    HighEnchant = 21,
    UnlockItem = 22,
    FinishGuide = 23,
    TreasureChestOpened = 24,
    AttackDamageOnce = 25,
    EarnGoldNum = 26,
    MakeItemFirstSuccess = 27,
    DungeonFirstClear = 28,
    BuildCost = 29,
    GemCost = 31
}

MsgType.EAchievementState = {
    NotDoable = 0,
    Doing = 1,
    Done = 2,
    Rewarded = 3
}

MsgType.EAchievementRoadState = {
    Disable = 0,
    CheckReward = 1,
    Finish = 2
}

MsgType.EAchievementRoadRewardState = {
    Disable = 0,
    CanReward = 1,
    Rewarded = 2
}

MsgType.EAchievementFurnitureType = {
    Counter = 1,
    ShelfHot = 2,
    ShelfCold = 3,
    ShelfArmor = 4,
    Other = 5
}

MsgType.OneAchievement = {
    id = 0,
    states = 0, --enum EAchievementState
    process = 0
}
MsgType.OneAchievement.__index = MsgType.OneAchievement

function MsgType.OneAchievement:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneAchievement:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.states and 0 ~= self.states then
        tb.c = self.states
    end
    if nil ~= self.process and 0 ~= self.process then
        tb.d = self.process
    end
    return tb
end

function MsgType.OneAchievement:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.states = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.process = tonumber(data.d) or 0
    end
    return self
end

function MsgType.OneAchievement:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneAchievement:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneAchievementRoad = {
    achievementRoadId = 0,
    achievementRoadState = 0 --enum EAchievementRoadRewardState
}
MsgType.OneAchievementRoad.__index = MsgType.OneAchievementRoad

function MsgType.OneAchievementRoad:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneAchievementRoad:Encode()
    local tb = {}
    if nil ~= self.achievementRoadId and 0 ~= self.achievementRoadId then
        tb.b = self.achievementRoadId
    end
    if nil ~= self.achievementRoadState and 0 ~= self.achievementRoadState then
        tb.c = self.achievementRoadState
    end
    return tb
end

function MsgType.OneAchievementRoad:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.achievementRoadId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.achievementRoadState = tonumber(data.c) or 0
    end
    return self
end

function MsgType.OneAchievementRoad:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneAchievementRoad:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Achievement_Check = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Achievement_Check.__index = MsgType.Request_Achievement_Check

function MsgType.Request_Achievement_Check:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Achievement_Check:GetCmd()
    return MsgTypeCmd.Request_Achievement_Check_Cmd
end
function MsgType.Request_Achievement_Check:GetUrl()
    return "Request_Achievement_Check"
end
function MsgType.Request_Achievement_Check:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Achievement_Check:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Achievement_Check:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Achievement_Check = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    achievementList = {}, -- array of MsgType.OneAchievement
    achievementRoadList = {}, -- array of MsgType.OneAchievementRoad
    achievementRoadId = 0,
    achievementRoadState = 0, --enum EAchievementRoadState
    achievementRoadPoint = 0,
    achievementRoadPointLimit = 0
}
MsgType.Response_Achievement_Check.__index = MsgType.Response_Achievement_Check

function MsgType.Response_Achievement_Check:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.achievementList = {}
    tb.achievementRoadList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Achievement_Check:GetCmd()
    return MsgTypeCmd.Response_Achievement_Check_Cmd
end
function MsgType.Response_Achievement_Check:GetUrl()
    return "Response_Achievement_Check"
end
function MsgType.Response_Achievement_Check:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpAchievementListObj = MsgType.OneAchievement:New()
            tmpAchievementListObj:Decode(data.f[i])
            self.achievementList[i] = tmpAchievementListObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpAchievementRoadListObj = MsgType.OneAchievementRoad:New()
            tmpAchievementRoadListObj:Decode(data.g[i])
            self.achievementRoadList[i] = tmpAchievementRoadListObj
        end
    end
    if nil ~= data.h then
        self.achievementRoadId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.achievementRoadState = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.achievementRoadPoint = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.achievementRoadPointLimit = tonumber(data.k) or 0
    end
    return self
end


MsgType.EAchievementChangeType = {
    Done = 0,
    Change = 1
}

MsgType.OneAchievementChange = {
    type = 0, --enum EAchievementChangeType
    achievement = {},
    paramBefore = 0
}
MsgType.OneAchievementChange.__index = MsgType.OneAchievementChange
setmetatable(MsgType.OneAchievementChange.achievement, MsgType.OneAchievement)

function MsgType.OneAchievementChange:New()
    local tb = {}
    setmetatable(tb, self)
    tb.achievement = MsgType.OneAchievement:New()
    return tb
end

function MsgType.OneAchievementChange:Encode()
    local tb = {}
    if nil ~= self.type and 0 ~= self.type then
        tb.b = self.type
    end
    tb.c = self.achievement:Encode()
    if nil ~= self.paramBefore and 0 ~= self.paramBefore then
        tb.d = self.paramBefore
    end
    return tb
end

function MsgType.OneAchievementChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.type = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.achievement:Decode(data.c)
    end
    if nil ~= data.d then
        self.paramBefore = tonumber(data.d) or 0
    end
    return self
end

function MsgType.OneAchievementChange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneAchievementChange:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Achievement_Change = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    achievementChangeList = {} -- array of MsgType.OneAchievementChange
}
MsgType.Response_Achievement_Change.__index = MsgType.Response_Achievement_Change

function MsgType.Response_Achievement_Change:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.achievementChangeList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Achievement_Change:GetCmd()
    return MsgTypeCmd.Response_Achievement_Change_Cmd
end
function MsgType.Response_Achievement_Change:GetUrl()
    return "Response_Achievement_Change"
end
function MsgType.Response_Achievement_Change:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpAchievementChangeListObj = MsgType.OneAchievementChange:New()
            tmpAchievementChangeListObj:Decode(data.f[i])
            self.achievementChangeList[i] = tmpAchievementChangeListObj
        end
    end
    return self
end


MsgType.Request_Achievement_Reward = {
    msgSeq = 0,
    achievementId = 0
}
MsgType.Request_Achievement_Reward.__index = MsgType.Request_Achievement_Reward

function MsgType.Request_Achievement_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Achievement_Reward:GetCmd()
    return MsgTypeCmd.Request_Achievement_Reward_Cmd
end
function MsgType.Request_Achievement_Reward:GetUrl()
    return "Request_Achievement_Reward"
end
function MsgType.Request_Achievement_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.achievementId and 0 ~= self.achievementId then
        tb.c = self.achievementId
    end
    return tb
end

function MsgType.Request_Achievement_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Achievement_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Achievement_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    reward = {}, -- array of MsgType.OneAchievement
    achievementRoadList = {}, -- array of MsgType.OneAchievementRoad
    achievementRoadId = 0,
    achievementRoadState = 0, --enum EAchievementRoadState
    achievementRoadPoint = 0,
    rewardItemList = {}, -- array of MsgType.OneRewardItem
    achievementId = 0
}
MsgType.Response_Achievement_Reward.__index = MsgType.Response_Achievement_Reward

function MsgType.Response_Achievement_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.reward = {}
    tb.achievementRoadList = {}
    tb.rewardItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Achievement_Reward:GetCmd()
    return MsgTypeCmd.Response_Achievement_Reward_Cmd
end
function MsgType.Response_Achievement_Reward:GetUrl()
    return "Response_Achievement_Reward"
end
function MsgType.Response_Achievement_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardObj = MsgType.OneAchievement:New()
            tmpRewardObj:Decode(data.f[i])
            self.reward[i] = tmpRewardObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpAchievementRoadListObj = MsgType.OneAchievementRoad:New()
            tmpAchievementRoadListObj:Decode(data.g[i])
            self.achievementRoadList[i] = tmpAchievementRoadListObj
        end
    end
    if nil ~= data.h then
        self.achievementRoadId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.achievementRoadState = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.achievementRoadPoint = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpRewardItemListObj = MsgType.OneRewardItem:New()
            tmpRewardItemListObj:Decode(data.k[i])
            self.rewardItemList[i] = tmpRewardItemListObj
        end
    end
    if nil ~= data.l then
        self.achievementId = tonumber(data.l) or 0
    end
    return self
end


MsgType.Request_AchievementRoad_Reward = {
    msgSeq = 0,
    achievementRoadId = 0
}
MsgType.Request_AchievementRoad_Reward.__index = MsgType.Request_AchievementRoad_Reward

function MsgType.Request_AchievementRoad_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_AchievementRoad_Reward:GetCmd()
    return MsgTypeCmd.Request_AchievementRoad_Reward_Cmd
end
function MsgType.Request_AchievementRoad_Reward:GetUrl()
    return "Request_AchievementRoad_Reward"
end
function MsgType.Request_AchievementRoad_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.achievementRoadId and 0 ~= self.achievementRoadId then
        tb.c = self.achievementRoadId
    end
    return tb
end

function MsgType.Request_AchievementRoad_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_AchievementRoad_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_AchievementRoad_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    achievementRoadList = {}, -- array of MsgType.OneAchievementRoad
    achievementRoadId = 0,
    achievementRoadState = 0, --enum EAchievementRoadState
    achievementRoadPoint = 0,
    achievementRoadPointLimit = 0,
    rewardItemList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_AchievementRoad_Reward.__index = MsgType.Response_AchievementRoad_Reward

function MsgType.Response_AchievementRoad_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.achievementRoadList = {}
    tb.rewardItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_AchievementRoad_Reward:GetCmd()
    return MsgTypeCmd.Response_AchievementRoad_Reward_Cmd
end
function MsgType.Response_AchievementRoad_Reward:GetUrl()
    return "Response_AchievementRoad_Reward"
end
function MsgType.Response_AchievementRoad_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpAchievementRoadListObj = MsgType.OneAchievementRoad:New()
            tmpAchievementRoadListObj:Decode(data.f[i])
            self.achievementRoadList[i] = tmpAchievementRoadListObj
        end
    end
    if nil ~= data.g then
        self.achievementRoadId = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.achievementRoadState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.achievementRoadPoint = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.achievementRoadPointLimit = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpRewardItemListObj = MsgType.OneRewardItem:New()
            tmpRewardItemListObj:Decode(data.k[i])
            self.rewardItemList[i] = tmpRewardItemListObj
        end
    end
    return self
end


MsgType.ERoleState = {
    Idle = 0,
    Resting = 1,
    Fighting = 2,
    CantFight = 3
}

MsgType.EHeroRarity = {
    N = 1,
    R = 2,
    SR = 3,
    SSR = 4
}

MsgType.HeroEquip = {
    equipId = 0,
    equipPosId = 0
}
MsgType.HeroEquip.__index = MsgType.HeroEquip

function MsgType.HeroEquip:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.HeroEquip:Encode()
    local tb = {}
    if nil ~= self.equipId and 0 ~= self.equipId then
        tb.b = self.equipId
    end
    if nil ~= self.equipPosId and 0 ~= self.equipPosId then
        tb.c = self.equipPosId
    end
    return tb
end

function MsgType.HeroEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.equipId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.equipPosId = tonumber(data.c) or 0
    end
    return self
end

function MsgType.HeroEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.HeroEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.HeroBrokenEquip = {
    heroUid = 0,
    equipId = 0,
    equipPositionId = 0
}
MsgType.HeroBrokenEquip.__index = MsgType.HeroBrokenEquip

function MsgType.HeroBrokenEquip:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.HeroBrokenEquip:Encode()
    local tb = {}
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.b = self.heroUid
    end
    if nil ~= self.equipId and 0 ~= self.equipId then
        tb.c = self.equipId
    end
    if nil ~= self.equipPositionId and 0 ~= self.equipPositionId then
        tb.d = self.equipPositionId
    end
    return tb
end

function MsgType.HeroBrokenEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.heroUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.equipId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.equipPositionId = tonumber(data.d) or 0
    end
    return self
end

function MsgType.HeroBrokenEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.HeroBrokenEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.HeroInfo = {
    heroUid = 0,
    heroId = 0,
    nickName = "",
    aptitude = 0,
    talentId = 0,
    level = 0,
    exp = 0,
    currentState = 0, --enum ERoleState
    stateStartTime = 0,
    stateEndTime = 0,
    stateRemainTime = 0,
    createTime = 0,
    equip1 = {},
    equip2 = {},
    equip3 = {},
    equip4 = {},
    equip5 = {},
    equip6 = {},
    gender = 0, --enum EGender
    roleDress = {},
    brokenEquip = {},
    fightPoint = 0,
    remainHp = 0,
    hpAdd = 0,
    atkAdd = 0,
    defAdd = 0
}
MsgType.HeroInfo.__index = MsgType.HeroInfo
setmetatable(MsgType.HeroInfo.equip1, MsgType.HeroEquip)
setmetatable(MsgType.HeroInfo.equip2, MsgType.HeroEquip)
setmetatable(MsgType.HeroInfo.equip3, MsgType.HeroEquip)
setmetatable(MsgType.HeroInfo.equip4, MsgType.HeroEquip)
setmetatable(MsgType.HeroInfo.equip5, MsgType.HeroEquip)
setmetatable(MsgType.HeroInfo.equip6, MsgType.HeroEquip)
setmetatable(MsgType.HeroInfo.roleDress, MsgType.RoleDress)
setmetatable(MsgType.HeroInfo.brokenEquip, MsgType.HeroBrokenEquip)

function MsgType.HeroInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.equip1 = MsgType.HeroEquip:New()
    tb.equip2 = MsgType.HeroEquip:New()
    tb.equip3 = MsgType.HeroEquip:New()
    tb.equip4 = MsgType.HeroEquip:New()
    tb.equip5 = MsgType.HeroEquip:New()
    tb.equip6 = MsgType.HeroEquip:New()
    tb.roleDress = MsgType.RoleDress:New()
    tb.brokenEquip = MsgType.HeroBrokenEquip:New()
    return tb
end

function MsgType.HeroInfo:Encode()
    local tb = {}
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.b = self.heroUid
    end
    if nil ~= self.heroId and 0 ~= self.heroId then
        tb.c = self.heroId
    end
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.d = self.nickName
    end
    if nil ~= self.aptitude and 0 ~= self.aptitude then
        tb.e = self.aptitude
    end
    if nil ~= self.talentId and 0 ~= self.talentId then
        tb.f = self.talentId
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.g = self.level
    end
    if nil ~= self.exp and 0 ~= self.exp then
        tb.h = self.exp
    end
    if nil ~= self.currentState and 0 ~= self.currentState then
        tb.i = self.currentState
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.j = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.k = self.stateEndTime
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.l = self.stateRemainTime
    end
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.m = self.createTime
    end
    tb.n = self.equip1:Encode()
    tb.o = self.equip2:Encode()
    tb.p = self.equip3:Encode()
    tb.q = self.equip4:Encode()
    tb.r = self.equip5:Encode()
    tb.s = self.equip6:Encode()
    if nil ~= self.gender and 0 ~= self.gender then
        tb.t = self.gender
    end
    tb.u = self.roleDress:Encode()
    tb.v = self.brokenEquip:Encode()
    if nil ~= self.fightPoint and 0 ~= self.fightPoint then
        tb.w = self.fightPoint
    end
    if nil ~= self.remainHp and 0 ~= self.remainHp then
        tb.x = self.remainHp
    end
    if nil ~= self.hpAdd and 0 ~= self.hpAdd then
        tb.y = self.hpAdd
    end
    if nil ~= self.atkAdd and 0 ~= self.atkAdd then
        tb.z = self.atkAdd
    end
    if nil ~= self.defAdd and 0 ~= self.defAdd then
        tb.a1 = self.defAdd
    end
    return tb
end

function MsgType.HeroInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.heroUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.heroId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.nickName = tostring(data.d)
    end
    if nil ~= data.e then
        self.aptitude = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.talentId = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.level = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.exp = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.currentState = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.stateStartTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.stateEndTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.stateRemainTime = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.createTime = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.equip1:Decode(data.n)
    end
    if nil ~= data.o then
        self.equip2:Decode(data.o)
    end
    if nil ~= data.p then
        self.equip3:Decode(data.p)
    end
    if nil ~= data.q then
        self.equip4:Decode(data.q)
    end
    if nil ~= data.r then
        self.equip5:Decode(data.r)
    end
    if nil ~= data.s then
        self.equip6:Decode(data.s)
    end
    if nil ~= data.t then
        self.gender = tonumber(data.t) or 0
    end
    if nil ~= data.u then
        self.roleDress:Decode(data.u)
    end
    if nil ~= data.v then
        self.brokenEquip:Decode(data.v)
    end
    if nil ~= data.w then
        self.fightPoint = tonumber(data.w) or 0
    end
    if nil ~= data.x then
        self.remainHp = tonumber(data.x) or 0
    end
    if nil ~= data.y then
        self.hpAdd = tonumber(data.y) or 0
    end
    if nil ~= data.z then
        self.atkAdd = tonumber(data.z) or 0
    end
    if nil ~= data.a1 then
        self.defAdd = tonumber(data.a1) or 0
    end
    return self
end

function MsgType.HeroInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.HeroInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.WarriorInfo = {
    warriorUid = 0,
    warriorId = 0,
    level = 0,
    exp = 0,
    rank = 0,
    currentState = 0, --enum ERoleState
    stateStartTime = 0,
    stateEndTime = 0,
    createTime = 0
}
MsgType.WarriorInfo.__index = MsgType.WarriorInfo

function MsgType.WarriorInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WarriorInfo:Encode()
    local tb = {}
    if nil ~= self.warriorUid and 0 ~= self.warriorUid then
        tb.b = self.warriorUid
    end
    if nil ~= self.warriorId and 0 ~= self.warriorId then
        tb.c = self.warriorId
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.d = self.level
    end
    if nil ~= self.exp and 0 ~= self.exp then
        tb.e = self.exp
    end
    if nil ~= self.rank and 0 ~= self.rank then
        tb.f = self.rank
    end
    if nil ~= self.currentState and 0 ~= self.currentState then
        tb.g = self.currentState
    end
    if nil ~= self.stateStartTime and 0 ~= self.stateStartTime then
        tb.h = self.stateStartTime
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.i = self.stateEndTime
    end
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.j = self.createTime
    end
    return tb
end

function MsgType.WarriorInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.warriorUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.warriorId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.level = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.exp = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rank = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.currentState = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.stateStartTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.stateEndTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.createTime = tonumber(data.j) or 0
    end
    return self
end

function MsgType.WarriorInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.WarriorInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.EWorkerState = {
    Locked = 0,
    CanUnlock = 1,
    Unlock = 2
}

MsgType.WorkerInfo = {
    workerUid = 0,
    workerId = 0,
    workerState = 0, --enum EWorkerState
    exp = 0,
    workerLevel = 0
}
MsgType.WorkerInfo.__index = MsgType.WorkerInfo

function MsgType.WorkerInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WorkerInfo:Encode()
    local tb = {}
    if nil ~= self.workerUid and 0 ~= self.workerUid then
        tb.b = self.workerUid
    end
    if nil ~= self.workerId and 0 ~= self.workerId then
        tb.c = self.workerId
    end
    if nil ~= self.workerState and 0 ~= self.workerState then
        tb.d = self.workerState
    end
    if nil ~= self.exp and 0 ~= self.exp then
        tb.e = self.exp
    end
    if nil ~= self.workerLevel and 0 ~= self.workerLevel then
        tb.f = self.workerLevel
    end
    return tb
end

function MsgType.WorkerInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.workerUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.workerId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.workerState = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.exp = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.workerLevel = tonumber(data.f) or 0
    end
    return self
end

function MsgType.WorkerInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.WorkerInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Hero_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Hero_Data.__index = MsgType.Request_Hero_Data

function MsgType.Request_Hero_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Data:GetCmd()
    return MsgTypeCmd.Request_Hero_Data_Cmd
end
function MsgType.Request_Hero_Data:GetUrl()
    return "Request_Hero_Data"
end
function MsgType.Request_Hero_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Hero_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroFieldLimit = 0,
    heroList = {}, -- array of MsgType.HeroInfo
    warriorList = {}, -- array of MsgType.WarriorInfo
    workerList = {} -- array of MsgType.WorkerInfo
}
MsgType.Response_Hero_Data.__index = MsgType.Response_Hero_Data

function MsgType.Response_Hero_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroList = {}
    tb.warriorList = {}
    tb.workerList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Data:GetCmd()
    return MsgTypeCmd.Response_Hero_Data_Cmd
end
function MsgType.Response_Hero_Data:GetUrl()
    return "Response_Hero_Data"
end
function MsgType.Response_Hero_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.heroFieldLimit = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpHeroListObj = MsgType.HeroInfo:New()
            tmpHeroListObj:Decode(data.g[i])
            self.heroList[i] = tmpHeroListObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpWarriorListObj = MsgType.WarriorInfo:New()
            tmpWarriorListObj:Decode(data.h[i])
            self.warriorList[i] = tmpWarriorListObj
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpWorkerListObj = MsgType.WorkerInfo:New()
            tmpWorkerListObj:Decode(data.i[i])
            self.workerList[i] = tmpWorkerListObj
        end
    end
    return self
end


MsgType.Request_Hero_FieldUnlock = {
    msgSeq = 0,
    useGem = 0
}
MsgType.Request_Hero_FieldUnlock.__index = MsgType.Request_Hero_FieldUnlock

function MsgType.Request_Hero_FieldUnlock:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_FieldUnlock:GetCmd()
    return MsgTypeCmd.Request_Hero_FieldUnlock_Cmd
end
function MsgType.Request_Hero_FieldUnlock:GetUrl()
    return "Request_Hero_FieldUnlock"
end
function MsgType.Request_Hero_FieldUnlock:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.c = self.useGem
    end
    return tb
end

function MsgType.Request_Hero_FieldUnlock:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_FieldUnlock:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_FieldUnlock = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroFieldLimit = 0
}
MsgType.Response_Hero_FieldUnlock.__index = MsgType.Response_Hero_FieldUnlock

function MsgType.Response_Hero_FieldUnlock:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_FieldUnlock:GetCmd()
    return MsgTypeCmd.Response_Hero_FieldUnlock_Cmd
end
function MsgType.Response_Hero_FieldUnlock:GetUrl()
    return "Response_Hero_FieldUnlock"
end
function MsgType.Response_Hero_FieldUnlock:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.heroFieldLimit = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_Hero_BuyList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Hero_BuyList.__index = MsgType.Request_Hero_BuyList

function MsgType.Request_Hero_BuyList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_BuyList:GetCmd()
    return MsgTypeCmd.Request_Hero_BuyList_Cmd
end
function MsgType.Request_Hero_BuyList:GetUrl()
    return "Request_Hero_BuyList"
end
function MsgType.Request_Hero_BuyList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Hero_BuyList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_BuyList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.ERecruitState = {
    NotRecruited = 0,
    Recruited = 1
}

MsgType.EnlistHeroInfo = {
    heroIndex = 0,
    heroId = 0,
    aptitude = 0,
    recruitCostGold = 0,
    recruitCostGem = 0,
    recruitState = 0, --enum ERecruitState
    equip1 = {},
    equip2 = {},
    equip3 = {},
    equip4 = {},
    equip5 = {},
    equip6 = {},
    gender = 0, --enum EGender
    roleDress = {}
}
MsgType.EnlistHeroInfo.__index = MsgType.EnlistHeroInfo
setmetatable(MsgType.EnlistHeroInfo.equip1, MsgType.HeroEquip)
setmetatable(MsgType.EnlistHeroInfo.equip2, MsgType.HeroEquip)
setmetatable(MsgType.EnlistHeroInfo.equip3, MsgType.HeroEquip)
setmetatable(MsgType.EnlistHeroInfo.equip4, MsgType.HeroEquip)
setmetatable(MsgType.EnlistHeroInfo.equip5, MsgType.HeroEquip)
setmetatable(MsgType.EnlistHeroInfo.equip6, MsgType.HeroEquip)
setmetatable(MsgType.EnlistHeroInfo.roleDress, MsgType.RoleDress)

function MsgType.EnlistHeroInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.equip1 = MsgType.HeroEquip:New()
    tb.equip2 = MsgType.HeroEquip:New()
    tb.equip3 = MsgType.HeroEquip:New()
    tb.equip4 = MsgType.HeroEquip:New()
    tb.equip5 = MsgType.HeroEquip:New()
    tb.equip6 = MsgType.HeroEquip:New()
    tb.roleDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.EnlistHeroInfo:Encode()
    local tb = {}
    if nil ~= self.heroIndex and 0 ~= self.heroIndex then
        tb.b = self.heroIndex
    end
    if nil ~= self.heroId and 0 ~= self.heroId then
        tb.c = self.heroId
    end
    if nil ~= self.aptitude and 0 ~= self.aptitude then
        tb.d = self.aptitude
    end
    if nil ~= self.recruitCostGold and 0 ~= self.recruitCostGold then
        tb.e = self.recruitCostGold
    end
    if nil ~= self.recruitCostGem and 0 ~= self.recruitCostGem then
        tb.f = self.recruitCostGem
    end
    if nil ~= self.recruitState and 0 ~= self.recruitState then
        tb.g = self.recruitState
    end
    tb.h = self.equip1:Encode()
    tb.i = self.equip2:Encode()
    tb.j = self.equip3:Encode()
    tb.k = self.equip4:Encode()
    tb.l = self.equip5:Encode()
    tb.m = self.equip6:Encode()
    if nil ~= self.gender and 0 ~= self.gender then
        tb.n = self.gender
    end
    tb.o = self.roleDress:Encode()
    return tb
end

function MsgType.EnlistHeroInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.heroIndex = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.heroId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.aptitude = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.recruitCostGold = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.recruitCostGem = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.recruitState = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.equip1:Decode(data.h)
    end
    if nil ~= data.i then
        self.equip2:Decode(data.i)
    end
    if nil ~= data.j then
        self.equip3:Decode(data.j)
    end
    if nil ~= data.k then
        self.equip4:Decode(data.k)
    end
    if nil ~= data.l then
        self.equip5:Decode(data.l)
    end
    if nil ~= data.m then
        self.equip6:Decode(data.m)
    end
    if nil ~= data.n then
        self.gender = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.roleDress:Decode(data.o)
    end
    return self
end

function MsgType.EnlistHeroInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.EnlistHeroInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_BuyList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    nextRefreshTime = 0,
    refreshCostType = 0, --enum EGoldOrGem
    refreshCostValue = 0,
    enlistHeroList = {}, -- array of MsgType.EnlistHeroInfo
    recruitRefreshCount = 0
}
MsgType.Response_Hero_BuyList.__index = MsgType.Response_Hero_BuyList

function MsgType.Response_Hero_BuyList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.enlistHeroList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_BuyList:GetCmd()
    return MsgTypeCmd.Response_Hero_BuyList_Cmd
end
function MsgType.Response_Hero_BuyList:GetUrl()
    return "Response_Hero_BuyList"
end
function MsgType.Response_Hero_BuyList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.nextRefreshTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.refreshCostType = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.refreshCostValue = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpEnlistHeroListObj = MsgType.EnlistHeroInfo:New()
            tmpEnlistHeroListObj:Decode(data.i[i])
            self.enlistHeroList[i] = tmpEnlistHeroListObj
        end
    end
    if nil ~= data.j then
        self.recruitRefreshCount = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_Hero_BuyListRefresh = {
    msgSeq = 0,
    refreshCostType = 0 --enum EGoldOrGem
}
MsgType.Request_Hero_BuyListRefresh.__index = MsgType.Request_Hero_BuyListRefresh

function MsgType.Request_Hero_BuyListRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_BuyListRefresh:GetCmd()
    return MsgTypeCmd.Request_Hero_BuyListRefresh_Cmd
end
function MsgType.Request_Hero_BuyListRefresh:GetUrl()
    return "Request_Hero_BuyListRefresh"
end
function MsgType.Request_Hero_BuyListRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.refreshCostType and 0 ~= self.refreshCostType then
        tb.c = self.refreshCostType
    end
    return tb
end

function MsgType.Request_Hero_BuyListRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_BuyListRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_BuyListRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Hero_BuyListRefresh.__index = MsgType.Response_Hero_BuyListRefresh

function MsgType.Response_Hero_BuyListRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_BuyListRefresh:GetCmd()
    return MsgTypeCmd.Response_Hero_BuyListRefresh_Cmd
end
function MsgType.Response_Hero_BuyListRefresh:GetUrl()
    return "Response_Hero_BuyListRefresh"
end
function MsgType.Response_Hero_BuyListRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Hero_Buy = {
    msgSeq = 0,
    heroIndex = 0,
    costType = 0 --enum EGoldOrGem
}
MsgType.Request_Hero_Buy.__index = MsgType.Request_Hero_Buy

function MsgType.Request_Hero_Buy:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Buy:GetCmd()
    return MsgTypeCmd.Request_Hero_Buy_Cmd
end
function MsgType.Request_Hero_Buy:GetUrl()
    return "Request_Hero_Buy"
end
function MsgType.Request_Hero_Buy:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroIndex and 0 ~= self.heroIndex then
        tb.c = self.heroIndex
    end
    if nil ~= self.costType and 0 ~= self.costType then
        tb.d = self.costType
    end
    return tb
end

function MsgType.Request_Hero_Buy:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Buy:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Buy = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    newHero = {}
}
MsgType.Response_Hero_Buy.__index = MsgType.Response_Hero_Buy
setmetatable(MsgType.Response_Hero_Buy.newHero, MsgType.HeroInfo)

function MsgType.Response_Hero_Buy:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.newHero = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Buy:GetCmd()
    return MsgTypeCmd.Response_Hero_Buy_Cmd
end
function MsgType.Response_Hero_Buy:GetUrl()
    return "Response_Hero_Buy"
end
function MsgType.Response_Hero_Buy:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.newHero:Decode(data.f)
    end
    return self
end


MsgType.Request_Hero_Equip = {
    msgSeq = 0,
    heroUid = 0,
    equipField = 0,
    onOrOff = 0,
    equipUid = ""
}
MsgType.Request_Hero_Equip.__index = MsgType.Request_Hero_Equip

function MsgType.Request_Hero_Equip:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Equip:GetCmd()
    return MsgTypeCmd.Request_Hero_Equip_Cmd
end
function MsgType.Request_Hero_Equip:GetUrl()
    return "Request_Hero_Equip"
end
function MsgType.Request_Hero_Equip:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    if nil ~= self.equipField and 0 ~= self.equipField then
        tb.d = self.equipField
    end
    if nil ~= self.onOrOff and 0 ~= self.onOrOff then
        tb.e = self.onOrOff
    end
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.f = self.equipUid
    end
    return tb
end

function MsgType.Request_Hero_Equip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Equip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Equip = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroUid = 0,
    equipField = 0,
    onOrOff = 0,
    equip = {}
}
MsgType.Response_Hero_Equip.__index = MsgType.Response_Hero_Equip
setmetatable(MsgType.Response_Hero_Equip.equip, MsgType.HeroEquip)

function MsgType.Response_Hero_Equip:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.equip = MsgType.HeroEquip:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Equip:GetCmd()
    return MsgTypeCmd.Response_Hero_Equip_Cmd
end
function MsgType.Response_Hero_Equip:GetUrl()
    return "Response_Hero_Equip"
end
function MsgType.Response_Hero_Equip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.heroUid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.equipField = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.onOrOff = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.equip:Decode(data.i)
    end
    return self
end


MsgType.HeroEquipAuto = {
    equipId = "",
    equipPosId = 0
}
MsgType.HeroEquipAuto.__index = MsgType.HeroEquipAuto

function MsgType.HeroEquipAuto:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.HeroEquipAuto:Encode()
    local tb = {}
    if nil ~= self.equipId and string.len(self.equipId) > 0 then
        tb.b = self.equipId
    end
    if nil ~= self.equipPosId and 0 ~= self.equipPosId then
        tb.c = self.equipPosId
    end
    return tb
end

function MsgType.HeroEquipAuto:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.equipId = tostring(data.b)
    end
    if nil ~= data.c then
        self.equipPosId = tonumber(data.c) or 0
    end
    return self
end

function MsgType.HeroEquipAuto:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.HeroEquipAuto:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Hero_EquipAuto = {
    msgSeq = 0,
    heroUid = 0,
    equip = {} -- array of MsgType.HeroEquipAuto
}
MsgType.Request_Hero_EquipAuto.__index = MsgType.Request_Hero_EquipAuto

function MsgType.Request_Hero_EquipAuto:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.equip = {}
    return tb
end

function MsgType.Request_Hero_EquipAuto:GetCmd()
    return MsgTypeCmd.Request_Hero_EquipAuto_Cmd
end
function MsgType.Request_Hero_EquipAuto:GetUrl()
    return "Request_Hero_EquipAuto"
end
function MsgType.Request_Hero_EquipAuto:_equipEncode()
    local tb = {}
    for i=1, #self.equip do
        tb[i] = self.equip[i]:Encode()
    end
    return tb
end
function MsgType.Request_Hero_EquipAuto:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    tb.d = self:_equipEncode()
    return tb
end

function MsgType.Request_Hero_EquipAuto:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_EquipAuto:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_EquipAuto = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroUid = 0,
    equip = {} -- array of MsgType.HeroEquip
}
MsgType.Response_Hero_EquipAuto.__index = MsgType.Response_Hero_EquipAuto

function MsgType.Response_Hero_EquipAuto:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.equip = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_EquipAuto:GetCmd()
    return MsgTypeCmd.Response_Hero_EquipAuto_Cmd
end
function MsgType.Response_Hero_EquipAuto:GetUrl()
    return "Response_Hero_EquipAuto"
end
function MsgType.Response_Hero_EquipAuto:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.heroUid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpEquipObj = MsgType.HeroEquip:New()
            tmpEquipObj:Decode(data.g[i])
            self.equip[i] = tmpEquipObj
        end
    end
    return self
end


MsgType.Request_Hero_WarriorRankUp = {
    msgSeq = 0,
    warriorId = 0
}
MsgType.Request_Hero_WarriorRankUp.__index = MsgType.Request_Hero_WarriorRankUp

function MsgType.Request_Hero_WarriorRankUp:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_WarriorRankUp:GetCmd()
    return MsgTypeCmd.Request_Hero_WarriorRankUp_Cmd
end
function MsgType.Request_Hero_WarriorRankUp:GetUrl()
    return "Request_Hero_WarriorRankUp"
end
function MsgType.Request_Hero_WarriorRankUp:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.warriorId and 0 ~= self.warriorId then
        tb.c = self.warriorId
    end
    return tb
end

function MsgType.Request_Hero_WarriorRankUp:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_WarriorRankUp:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_WarriorRankUp = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    warriorInfo = {}
}
MsgType.Response_Hero_WarriorRankUp.__index = MsgType.Response_Hero_WarriorRankUp
setmetatable(MsgType.Response_Hero_WarriorRankUp.warriorInfo, MsgType.WarriorInfo)

function MsgType.Response_Hero_WarriorRankUp:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.warriorInfo = MsgType.WarriorInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_WarriorRankUp:GetCmd()
    return MsgTypeCmd.Response_Hero_WarriorRankUp_Cmd
end
function MsgType.Response_Hero_WarriorRankUp:GetUrl()
    return "Response_Hero_WarriorRankUp"
end
function MsgType.Response_Hero_WarriorRankUp:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.warriorInfo:Decode(data.f)
    end
    return self
end


MsgType.Request_Hero_Setting = {
    msgSeq = 0,
    heroUid = 0,
    nickName = ""
}
MsgType.Request_Hero_Setting.__index = MsgType.Request_Hero_Setting

function MsgType.Request_Hero_Setting:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Setting:GetCmd()
    return MsgTypeCmd.Request_Hero_Setting_Cmd
end
function MsgType.Request_Hero_Setting:GetUrl()
    return "Request_Hero_Setting"
end
function MsgType.Request_Hero_Setting:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.d = self.nickName
    end
    return tb
end

function MsgType.Request_Hero_Setting:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Setting:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Setting = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    hero = {}
}
MsgType.Response_Hero_Setting.__index = MsgType.Response_Hero_Setting
setmetatable(MsgType.Response_Hero_Setting.hero, MsgType.HeroInfo)

function MsgType.Response_Hero_Setting:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.hero = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Setting:GetCmd()
    return MsgTypeCmd.Response_Hero_Setting_Cmd
end
function MsgType.Response_Hero_Setting:GetUrl()
    return "Response_Hero_Setting"
end
function MsgType.Response_Hero_Setting:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.hero:Decode(data.f)
    end
    return self
end


MsgType.Request_Hero_Fire = {
    msgSeq = 0,
    heroUid = 0
}
MsgType.Request_Hero_Fire.__index = MsgType.Request_Hero_Fire

function MsgType.Request_Hero_Fire:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Fire:GetCmd()
    return MsgTypeCmd.Request_Hero_Fire_Cmd
end
function MsgType.Request_Hero_Fire:GetUrl()
    return "Request_Hero_Fire"
end
function MsgType.Request_Hero_Fire:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    return tb
end

function MsgType.Request_Hero_Fire:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Fire:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Fire = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    hero = {}
}
MsgType.Response_Hero_Fire.__index = MsgType.Response_Hero_Fire
setmetatable(MsgType.Response_Hero_Fire.hero, MsgType.HeroInfo)

function MsgType.Response_Hero_Fire:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.hero = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Fire:GetCmd()
    return MsgTypeCmd.Response_Hero_Fire_Cmd
end
function MsgType.Response_Hero_Fire:GetUrl()
    return "Response_Hero_Fire"
end
function MsgType.Response_Hero_Fire:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.hero:Decode(data.f)
    end
    return self
end


MsgType.Request_Hero_Transfer = {
    msgSeq = 0,
    heroUid = 0,
    targetHeroId = 0
}
MsgType.Request_Hero_Transfer.__index = MsgType.Request_Hero_Transfer

function MsgType.Request_Hero_Transfer:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Transfer:GetCmd()
    return MsgTypeCmd.Request_Hero_Transfer_Cmd
end
function MsgType.Request_Hero_Transfer:GetUrl()
    return "Request_Hero_Transfer"
end
function MsgType.Request_Hero_Transfer:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    if nil ~= self.targetHeroId and 0 ~= self.targetHeroId then
        tb.d = self.targetHeroId
    end
    return tb
end

function MsgType.Request_Hero_Transfer:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Transfer:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Transfer = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    hero = {}
}
MsgType.Response_Hero_Transfer.__index = MsgType.Response_Hero_Transfer
setmetatable(MsgType.Response_Hero_Transfer.hero, MsgType.HeroInfo)

function MsgType.Response_Hero_Transfer:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.hero = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Transfer:GetCmd()
    return MsgTypeCmd.Response_Hero_Transfer_Cmd
end
function MsgType.Response_Hero_Transfer:GetUrl()
    return "Response_Hero_Transfer"
end
function MsgType.Response_Hero_Transfer:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.hero:Decode(data.f)
    end
    return self
end


MsgType.Request_Hero_DataRefresh = {
    msgSeq = 0,
    heroUid = 0
}
MsgType.Request_Hero_DataRefresh.__index = MsgType.Request_Hero_DataRefresh

function MsgType.Request_Hero_DataRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_DataRefresh:GetCmd()
    return MsgTypeCmd.Request_Hero_DataRefresh_Cmd
end
function MsgType.Request_Hero_DataRefresh:GetUrl()
    return "Request_Hero_DataRefresh"
end
function MsgType.Request_Hero_DataRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    return tb
end

function MsgType.Request_Hero_DataRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_DataRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_DataRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    hero = {}
}
MsgType.Response_Hero_DataRefresh.__index = MsgType.Response_Hero_DataRefresh
setmetatable(MsgType.Response_Hero_DataRefresh.hero, MsgType.HeroInfo)

function MsgType.Response_Hero_DataRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.hero = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_DataRefresh:GetCmd()
    return MsgTypeCmd.Response_Hero_DataRefresh_Cmd
end
function MsgType.Response_Hero_DataRefresh:GetUrl()
    return "Response_Hero_DataRefresh"
end
function MsgType.Response_Hero_DataRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.hero:Decode(data.f)
    end
    return self
end


MsgType.ERecoverCostType = {
    Item = 1,
    Gem = 10002
}

MsgType.Request_Hero_Recover = {
    msgSeq = 0,
    heroUid = 0,
    costType = 0 --enum ERecoverCostType
}
MsgType.Request_Hero_Recover.__index = MsgType.Request_Hero_Recover

function MsgType.Request_Hero_Recover:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Recover:GetCmd()
    return MsgTypeCmd.Request_Hero_Recover_Cmd
end
function MsgType.Request_Hero_Recover:GetUrl()
    return "Request_Hero_Recover"
end
function MsgType.Request_Hero_Recover:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    if nil ~= self.costType and 0 ~= self.costType then
        tb.d = self.costType
    end
    return tb
end

function MsgType.Request_Hero_Recover:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Recover:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Recover = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Hero_Recover.__index = MsgType.Response_Hero_Recover

function MsgType.Response_Hero_Recover:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Recover:GetCmd()
    return MsgTypeCmd.Response_Hero_Recover_Cmd
end
function MsgType.Response_Hero_Recover:GetUrl()
    return "Response_Hero_Recover"
end
function MsgType.Response_Hero_Recover:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Hero_FixBrokenEquip = {
    msgSeq = 0,
    heroUid = 0,
    costType = 0 --enum EItemType
}
MsgType.Request_Hero_FixBrokenEquip.__index = MsgType.Request_Hero_FixBrokenEquip

function MsgType.Request_Hero_FixBrokenEquip:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_FixBrokenEquip:GetCmd()
    return MsgTypeCmd.Request_Hero_FixBrokenEquip_Cmd
end
function MsgType.Request_Hero_FixBrokenEquip:GetUrl()
    return "Request_Hero_FixBrokenEquip"
end
function MsgType.Request_Hero_FixBrokenEquip:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    if nil ~= self.costType and 0 ~= self.costType then
        tb.d = self.costType
    end
    return tb
end

function MsgType.Request_Hero_FixBrokenEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_FixBrokenEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_FixBrokenEquip = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroInfo = {}
}
MsgType.Response_Hero_FixBrokenEquip.__index = MsgType.Response_Hero_FixBrokenEquip
setmetatable(MsgType.Response_Hero_FixBrokenEquip.heroInfo, MsgType.HeroInfo)

function MsgType.Response_Hero_FixBrokenEquip:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroInfo = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_FixBrokenEquip:GetCmd()
    return MsgTypeCmd.Response_Hero_FixBrokenEquip_Cmd
end
function MsgType.Response_Hero_FixBrokenEquip:GetUrl()
    return "Response_Hero_FixBrokenEquip"
end
function MsgType.Response_Hero_FixBrokenEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.heroInfo:Decode(data.f)
    end
    return self
end


MsgType.Response_Hero_Change = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroList = {} -- array of MsgType.HeroInfo
}
MsgType.Response_Hero_Change.__index = MsgType.Response_Hero_Change

function MsgType.Response_Hero_Change:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Change:GetCmd()
    return MsgTypeCmd.Response_Hero_Change_Cmd
end
function MsgType.Response_Hero_Change:GetUrl()
    return "Response_Hero_Change"
end
function MsgType.Response_Hero_Change:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpHeroListObj = MsgType.HeroInfo:New()
            tmpHeroListObj:Decode(data.f[i])
            self.heroList[i] = tmpHeroListObj
        end
    end
    return self
end


MsgType.EHeroExchangeState = {
    Lock = 1,
    Idle = 2,
    Unlock = 3
}

MsgType.ExchangeHeroInfo = {
    id = 0,
    heroInfo = {},
    unlockLevel = 0,
    unlockCost = 0,
    exchangeState = 0 --enum EHeroExchangeState
}
MsgType.ExchangeHeroInfo.__index = MsgType.ExchangeHeroInfo
setmetatable(MsgType.ExchangeHeroInfo.heroInfo, MsgType.HeroInfo)

function MsgType.ExchangeHeroInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.heroInfo = MsgType.HeroInfo:New()
    return tb
end

function MsgType.ExchangeHeroInfo:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    tb.c = self.heroInfo:Encode()
    if nil ~= self.unlockLevel and 0 ~= self.unlockLevel then
        tb.d = self.unlockLevel
    end
    if nil ~= self.unlockCost and 0 ~= self.unlockCost then
        tb.e = self.unlockCost
    end
    if nil ~= self.exchangeState and 0 ~= self.exchangeState then
        tb.f = self.exchangeState
    end
    return tb
end

function MsgType.ExchangeHeroInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.heroInfo:Decode(data.c)
    end
    if nil ~= data.d then
        self.unlockLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.unlockCost = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.exchangeState = tonumber(data.f) or 0
    end
    return self
end

function MsgType.ExchangeHeroInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ExchangeHeroInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Hero_ExchangeList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Hero_ExchangeList.__index = MsgType.Request_Hero_ExchangeList

function MsgType.Request_Hero_ExchangeList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_ExchangeList:GetCmd()
    return MsgTypeCmd.Request_Hero_ExchangeList_Cmd
end
function MsgType.Request_Hero_ExchangeList:GetUrl()
    return "Request_Hero_ExchangeList"
end
function MsgType.Request_Hero_ExchangeList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Hero_ExchangeList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_ExchangeList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_ExchangeList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exchangeHeroList = {} -- array of MsgType.ExchangeHeroInfo
}
MsgType.Response_Hero_ExchangeList.__index = MsgType.Response_Hero_ExchangeList

function MsgType.Response_Hero_ExchangeList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchangeHeroList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_ExchangeList:GetCmd()
    return MsgTypeCmd.Response_Hero_ExchangeList_Cmd
end
function MsgType.Response_Hero_ExchangeList:GetUrl()
    return "Response_Hero_ExchangeList"
end
function MsgType.Response_Hero_ExchangeList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpExchangeHeroListObj = MsgType.ExchangeHeroInfo:New()
            tmpExchangeHeroListObj:Decode(data.f[i])
            self.exchangeHeroList[i] = tmpExchangeHeroListObj
        end
    end
    return self
end


MsgType.Request_Hero_Exchange = {
    msgSeq = 0,
    id = 0
}
MsgType.Request_Hero_Exchange.__index = MsgType.Request_Hero_Exchange

function MsgType.Request_Hero_Exchange:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_Exchange:GetCmd()
    return MsgTypeCmd.Request_Hero_Exchange_Cmd
end
function MsgType.Request_Hero_Exchange:GetUrl()
    return "Request_Hero_Exchange"
end
function MsgType.Request_Hero_Exchange:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.id and 0 ~= self.id then
        tb.c = self.id
    end
    return tb
end

function MsgType.Request_Hero_Exchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_Exchange:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_Exchange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exchangeHeroList = {} -- array of MsgType.ExchangeHeroInfo
}
MsgType.Response_Hero_Exchange.__index = MsgType.Response_Hero_Exchange

function MsgType.Response_Hero_Exchange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchangeHeroList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_Exchange:GetCmd()
    return MsgTypeCmd.Response_Hero_Exchange_Cmd
end
function MsgType.Response_Hero_Exchange:GetUrl()
    return "Response_Hero_Exchange"
end
function MsgType.Response_Hero_Exchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpExchangeHeroListObj = MsgType.ExchangeHeroInfo:New()
            tmpExchangeHeroListObj:Decode(data.f[i])
            self.exchangeHeroList[i] = tmpExchangeHeroListObj
        end
    end
    return self
end


MsgType.WorkerMakeExp = {
    makeExpCount = 0,
    makeLevelWorker = 0,
    makeSpeed = 0,
    makeWorkerId = 0
}
MsgType.WorkerMakeExp.__index = MsgType.WorkerMakeExp

function MsgType.WorkerMakeExp:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.WorkerMakeExp:Encode()
    local tb = {}
    if nil ~= self.makeExpCount and 0 ~= self.makeExpCount then
        tb.b = self.makeExpCount
    end
    if nil ~= self.makeLevelWorker and 0 ~= self.makeLevelWorker then
        tb.c = self.makeLevelWorker
    end
    if nil ~= self.makeSpeed and 0 ~= self.makeSpeed then
        tb.d = self.makeSpeed
    end
    if nil ~= self.makeWorkerId and 0 ~= self.makeWorkerId then
        tb.e = self.makeWorkerId
    end
    return tb
end

function MsgType.WorkerMakeExp:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.makeExpCount = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.makeLevelWorker = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.makeSpeed = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.makeWorkerId = tonumber(data.e) or 0
    end
    return self
end

function MsgType.WorkerMakeExp:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.WorkerMakeExp:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Worker_MakeExp = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    workerMakeExpList = {} -- array of MsgType.WorkerMakeExp
}
MsgType.Response_Worker_MakeExp.__index = MsgType.Response_Worker_MakeExp

function MsgType.Response_Worker_MakeExp:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.workerMakeExpList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Worker_MakeExp:GetCmd()
    return MsgTypeCmd.Response_Worker_MakeExp_Cmd
end
function MsgType.Response_Worker_MakeExp:GetUrl()
    return "Response_Worker_MakeExp"
end
function MsgType.Response_Worker_MakeExp:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpWorkerMakeExpListObj = MsgType.WorkerMakeExp:New()
            tmpWorkerMakeExpListObj:Decode(data.f[i])
            self.workerMakeExpList[i] = tmpWorkerMakeExpListObj
        end
    end
    return self
end


MsgType.Response_Hero_WorkerChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    worker = {},
    reason = 0 --enum EItemLogReason
}
MsgType.Response_Hero_WorkerChange.__index = MsgType.Response_Hero_WorkerChange
setmetatable(MsgType.Response_Hero_WorkerChange.worker, MsgType.WorkerInfo)

function MsgType.Response_Hero_WorkerChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.worker = MsgType.WorkerInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_WorkerChange:GetCmd()
    return MsgTypeCmd.Response_Hero_WorkerChange_Cmd
end
function MsgType.Response_Hero_WorkerChange:GetUrl()
    return "Response_Hero_WorkerChange"
end
function MsgType.Response_Hero_WorkerChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.worker:Decode(data.f)
    end
    if nil ~= data.g then
        self.reason = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Hero_WorkerUnlock = {
    msgSeq = 0,
    workerId = 0,
    unlockItemType = 0
}
MsgType.Request_Hero_WorkerUnlock.__index = MsgType.Request_Hero_WorkerUnlock

function MsgType.Request_Hero_WorkerUnlock:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_WorkerUnlock:GetCmd()
    return MsgTypeCmd.Request_Hero_WorkerUnlock_Cmd
end
function MsgType.Request_Hero_WorkerUnlock:GetUrl()
    return "Request_Hero_WorkerUnlock"
end
function MsgType.Request_Hero_WorkerUnlock:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.workerId and 0 ~= self.workerId then
        tb.c = self.workerId
    end
    if nil ~= self.unlockItemType and 0 ~= self.unlockItemType then
        tb.d = self.unlockItemType
    end
    return tb
end

function MsgType.Request_Hero_WorkerUnlock:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_WorkerUnlock:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_WorkerUnlock = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    workerList = {} -- array of MsgType.WorkerInfo
}
MsgType.Response_Hero_WorkerUnlock.__index = MsgType.Response_Hero_WorkerUnlock

function MsgType.Response_Hero_WorkerUnlock:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.workerList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_WorkerUnlock:GetCmd()
    return MsgTypeCmd.Response_Hero_WorkerUnlock_Cmd
end
function MsgType.Response_Hero_WorkerUnlock:GetUrl()
    return "Response_Hero_WorkerUnlock"
end
function MsgType.Response_Hero_WorkerUnlock:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpWorkerListObj = MsgType.WorkerInfo:New()
            tmpWorkerListObj:Decode(data.f[i])
            self.workerList[i] = tmpWorkerListObj
        end
    end
    return self
end


MsgType.EShopperType = {
    Buy = 0,
    Sell = 1,
    Warrior = 2,
    Worker = 3,
    HighPriceBuy = 4,
    SellCopyItem = 5,
    SellMultiple = 6
}

MsgType.EShopperComeType = {
    Normal = 0,
    GuideTask = 1
}

MsgType.EShopperAIType = {
    None = 0,
    Watch1 = 1001,
    Watch2 = 1002,
    Watch3 = 1003,
    Buy1 = 2001,
    Buy2 = 2002,
    Buy3 = 2003,
    NotBuy = 3001,
    Pet1 = 4001,
    Pet2 = 4002
}

MsgType.EShopperState = {
    Idle = 0,
    Walking = 1,
    Queuing = 99,
    Leaving = 100
}

MsgType.OneShopper = {
    shopperUid = 0,
    shopperType = 0, --enum EShopperType
    shopperState = 0, --enum EShopperState
    isGuide = 0,
    shopperId = 0,
    shopperLevel = 0,
    dressId = 0,
    targetEquipId = 0,
    targetEquipUid = "",
    targetItemId = 0,
    targetCount = 0,
    price = 0,
    energy = 0,
    hasChat = 0,
    hasDisCount = 0,
    hasDouble = 0,
    rewardItemId = 0,
    rewardItemCount = 0,
    equips = {}, -- array of MsgType.HeroEquip
    gender = 0, --enum EGender
    roleDress = {},
    energyTimes = 0,
    leaveTime = 0,
    param1 = 0,
    param2 = 0,
    param3 = 0,
    param4 = 0,
    param5 = 0,
    param6 = "",
    param7 = "",
    shopperComeType = 0, --enum EShopperComeType
    shopperAIType = 0, --enum EShopperAIType
    shopperGuideTaskId = 0
}
MsgType.OneShopper.__index = MsgType.OneShopper
setmetatable(MsgType.OneShopper.roleDress, MsgType.RoleDress)

function MsgType.OneShopper:New()
    local tb = {}
    setmetatable(tb, self)
    tb.equips = {}
    tb.roleDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.OneShopper:_equipsEncode()
    local tb = {}
    for i=1, #self.equips do
        tb[i] = self.equips[i]:Encode()
    end
    return tb
end
function MsgType.OneShopper:Encode()
    local tb = {}
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.b = self.shopperUid
    end
    if nil ~= self.shopperType and 0 ~= self.shopperType then
        tb.c = self.shopperType
    end
    if nil ~= self.shopperState and 0 ~= self.shopperState then
        tb.d = self.shopperState
    end
    if nil ~= self.isGuide and 0 ~= self.isGuide then
        tb.e = self.isGuide
    end
    if nil ~= self.shopperId and 0 ~= self.shopperId then
        tb.f = self.shopperId
    end
    if nil ~= self.shopperLevel and 0 ~= self.shopperLevel then
        tb.g = self.shopperLevel
    end
    if nil ~= self.dressId and 0 ~= self.dressId then
        tb.h = self.dressId
    end
    if nil ~= self.targetEquipId and 0 ~= self.targetEquipId then
        tb.i = self.targetEquipId
    end
    if nil ~= self.targetEquipUid and string.len(self.targetEquipUid) > 0 then
        tb.j = self.targetEquipUid
    end
    if nil ~= self.targetItemId and 0 ~= self.targetItemId then
        tb.k = self.targetItemId
    end
    if nil ~= self.targetCount and 0 ~= self.targetCount then
        tb.l = self.targetCount
    end
    if nil ~= self.price and 0 ~= self.price then
        tb.m = self.price
    end
    if nil ~= self.energy and 0 ~= self.energy then
        tb.n = self.energy
    end
    if nil ~= self.hasChat and 0 ~= self.hasChat then
        tb.o = self.hasChat
    end
    if nil ~= self.hasDisCount and 0 ~= self.hasDisCount then
        tb.p = self.hasDisCount
    end
    if nil ~= self.hasDouble and 0 ~= self.hasDouble then
        tb.q = self.hasDouble
    end
    if nil ~= self.rewardItemId and 0 ~= self.rewardItemId then
        tb.r = self.rewardItemId
    end
    if nil ~= self.rewardItemCount and 0 ~= self.rewardItemCount then
        tb.s = self.rewardItemCount
    end
    tb.t = self:_equipsEncode()
    if nil ~= self.gender and 0 ~= self.gender then
        tb.u = self.gender
    end
    tb.v = self.roleDress:Encode()
    if nil ~= self.energyTimes and 0 ~= self.energyTimes then
        tb.w = self.energyTimes
    end
    if nil ~= self.leaveTime and 0 ~= self.leaveTime then
        tb.x = self.leaveTime
    end
    if nil ~= self.param1 and 0 ~= self.param1 then
        tb.y = self.param1
    end
    if nil ~= self.param2 and 0 ~= self.param2 then
        tb.z = self.param2
    end
    if nil ~= self.param3 and 0 ~= self.param3 then
        tb.a1 = self.param3
    end
    if nil ~= self.param4 and 0 ~= self.param4 then
        tb.a2 = self.param4
    end
    if nil ~= self.param5 and 0 ~= self.param5 then
        tb.a3 = self.param5
    end
    if nil ~= self.param6 and string.len(self.param6) > 0 then
        tb.a4 = self.param6
    end
    if nil ~= self.param7 and string.len(self.param7) > 0 then
        tb.a5 = self.param7
    end
    if nil ~= self.shopperComeType and 0 ~= self.shopperComeType then
        tb.a6 = self.shopperComeType
    end
    if nil ~= self.shopperAIType and 0 ~= self.shopperAIType then
        tb.a7 = self.shopperAIType
    end
    if nil ~= self.shopperGuideTaskId and 0 ~= self.shopperGuideTaskId then
        tb.a8 = self.shopperGuideTaskId
    end
    return tb
end

function MsgType.OneShopper:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.shopperUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.shopperType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.shopperState = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.isGuide = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.shopperId = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.shopperLevel = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.dressId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.targetEquipId = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.targetEquipUid = tostring(data.j)
    end
    if nil ~= data.k then
        self.targetItemId = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.targetCount = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.price = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.energy = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.hasChat = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.hasDisCount = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        self.hasDouble = tonumber(data.q) or 0
    end
    if nil ~= data.r then
        self.rewardItemId = tonumber(data.r) or 0
    end
    if nil ~= data.s then
        self.rewardItemCount = tonumber(data.s) or 0
    end
    if nil ~= data.t then
        for i=1, #data.t do
            local tmpEquipsObj = MsgType.HeroEquip:New()
            tmpEquipsObj:Decode(data.t[i])
            self.equips[i] = tmpEquipsObj
        end
    end
    if nil ~= data.u then
        self.gender = tonumber(data.u) or 0
    end
    if nil ~= data.v then
        self.roleDress:Decode(data.v)
    end
    if nil ~= data.w then
        self.energyTimes = tonumber(data.w) or 0
    end
    if nil ~= data.x then
        self.leaveTime = tonumber(data.x) or 0
    end
    if nil ~= data.y then
        self.param1 = tonumber(data.y) or 0
    end
    if nil ~= data.z then
        self.param2 = tonumber(data.z) or 0
    end
    if nil ~= data.a1 then
        self.param3 = tonumber(data.a1) or 0
    end
    if nil ~= data.a2 then
        self.param4 = tonumber(data.a2) or 0
    end
    if nil ~= data.a3 then
        self.param5 = tonumber(data.a3) or 0
    end
    if nil ~= data.a4 then
        self.param6 = tostring(data.a4)
    end
    if nil ~= data.a5 then
        self.param7 = tostring(data.a5)
    end
    if nil ~= data.a6 then
        self.shopperComeType = tonumber(data.a6) or 0
    end
    if nil ~= data.a7 then
        self.shopperAIType = tonumber(data.a7) or 0
    end
    if nil ~= data.a8 then
        self.shopperGuideTaskId = tonumber(data.a8) or 0
    end
    return self
end

function MsgType.OneShopper:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneShopper:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Shopper_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Shopper_Data.__index = MsgType.Request_Shopper_Data

function MsgType.Request_Shopper_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Data:GetCmd()
    return MsgTypeCmd.Request_Shopper_Data_Cmd
end
function MsgType.Request_Shopper_Data:GetUrl()
    return "Request_Shopper_Data"
end
function MsgType.Request_Shopper_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Shopper_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopperList = {} -- array of MsgType.OneShopper
}
MsgType.Response_Shopper_Data.__index = MsgType.Response_Shopper_Data

function MsgType.Response_Shopper_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shopperList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Data:GetCmd()
    return MsgTypeCmd.Response_Shopper_Data_Cmd
end
function MsgType.Response_Shopper_Data:GetUrl()
    return "Response_Shopper_Data"
end
function MsgType.Response_Shopper_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpShopperListObj = MsgType.OneShopper:New()
            tmpShopperListObj:Decode(data.f[i])
            self.shopperList[i] = tmpShopperListObj
        end
    end
    return self
end


MsgType.Request_Shopper_Coming = {
    msgSeq = 0,
    shopperUidList = ""
}
MsgType.Request_Shopper_Coming.__index = MsgType.Request_Shopper_Coming

function MsgType.Request_Shopper_Coming:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Coming:GetCmd()
    return MsgTypeCmd.Request_Shopper_Coming_Cmd
end
function MsgType.Request_Shopper_Coming:GetUrl()
    return "Request_Shopper_Coming"
end
function MsgType.Request_Shopper_Coming:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUidList and string.len(self.shopperUidList) > 0 then
        tb.c = self.shopperUidList
    end
    return tb
end

function MsgType.Request_Shopper_Coming:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Coming:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Coming = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Shopper_Coming.__index = MsgType.Response_Shopper_Coming

function MsgType.Response_Shopper_Coming:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Coming:GetCmd()
    return MsgTypeCmd.Response_Shopper_Coming_Cmd
end
function MsgType.Response_Shopper_Coming:GetUrl()
    return "Response_Shopper_Coming"
end
function MsgType.Response_Shopper_Coming:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Response_Shopper_Change = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopper = {},
    flag = 0
}
MsgType.Response_Shopper_Change.__index = MsgType.Response_Shopper_Change
setmetatable(MsgType.Response_Shopper_Change.shopper, MsgType.OneShopper)

function MsgType.Response_Shopper_Change:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.shopper = MsgType.OneShopper:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Change:GetCmd()
    return MsgTypeCmd.Response_Shopper_Change_Cmd
end
function MsgType.Response_Shopper_Change:GetUrl()
    return "Response_Shopper_Change"
end
function MsgType.Response_Shopper_Change:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopper:Decode(data.f)
    end
    if nil ~= data.g then
        self.flag = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Shopper_Chat = {
    msgSeq = 0,
    shopperUid = 0
}
MsgType.Request_Shopper_Chat.__index = MsgType.Request_Shopper_Chat

function MsgType.Request_Shopper_Chat:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Chat:GetCmd()
    return MsgTypeCmd.Request_Shopper_Chat_Cmd
end
function MsgType.Request_Shopper_Chat:GetUrl()
    return "Request_Shopper_Chat"
end
function MsgType.Request_Shopper_Chat:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    return tb
end

function MsgType.Request_Shopper_Chat:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Chat:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Chat = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    chatSuccess = 0
}
MsgType.Response_Shopper_Chat.__index = MsgType.Response_Shopper_Chat

function MsgType.Response_Shopper_Chat:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Chat:GetCmd()
    return MsgTypeCmd.Response_Shopper_Chat_Cmd
end
function MsgType.Response_Shopper_Chat:GetUrl()
    return "Response_Shopper_Chat"
end
function MsgType.Response_Shopper_Chat:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.chatSuccess = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_Shopper_Discount = {
    msgSeq = 0,
    shopperUid = 0
}
MsgType.Request_Shopper_Discount.__index = MsgType.Request_Shopper_Discount

function MsgType.Request_Shopper_Discount:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Discount:GetCmd()
    return MsgTypeCmd.Request_Shopper_Discount_Cmd
end
function MsgType.Request_Shopper_Discount:GetUrl()
    return "Request_Shopper_Discount"
end
function MsgType.Request_Shopper_Discount:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    return tb
end

function MsgType.Request_Shopper_Discount:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Discount:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Discount = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Shopper_Discount.__index = MsgType.Response_Shopper_Discount

function MsgType.Response_Shopper_Discount:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Discount:GetCmd()
    return MsgTypeCmd.Response_Shopper_Discount_Cmd
end
function MsgType.Response_Shopper_Discount:GetUrl()
    return "Response_Shopper_Discount"
end
function MsgType.Response_Shopper_Discount:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Shopper_Double = {
    msgSeq = 0,
    shopperUid = 0
}
MsgType.Request_Shopper_Double.__index = MsgType.Request_Shopper_Double

function MsgType.Request_Shopper_Double:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Double:GetCmd()
    return MsgTypeCmd.Request_Shopper_Double_Cmd
end
function MsgType.Request_Shopper_Double:GetUrl()
    return "Request_Shopper_Double"
end
function MsgType.Request_Shopper_Double:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    return tb
end

function MsgType.Request_Shopper_Double:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Double:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Double = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Shopper_Double.__index = MsgType.Response_Shopper_Double

function MsgType.Response_Shopper_Double:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Double:GetCmd()
    return MsgTypeCmd.Response_Shopper_Double_Cmd
end
function MsgType.Response_Shopper_Double:GetUrl()
    return "Response_Shopper_Double"
end
function MsgType.Response_Shopper_Double:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Shopper_Refuse = {
    msgSeq = 0,
    shopperUid = 0
}
MsgType.Request_Shopper_Refuse.__index = MsgType.Request_Shopper_Refuse

function MsgType.Request_Shopper_Refuse:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Refuse:GetCmd()
    return MsgTypeCmd.Request_Shopper_Refuse_Cmd
end
function MsgType.Request_Shopper_Refuse:GetUrl()
    return "Request_Shopper_Refuse"
end
function MsgType.Request_Shopper_Refuse:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    return tb
end

function MsgType.Request_Shopper_Refuse:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Refuse:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Refuse = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Shopper_Refuse.__index = MsgType.Response_Shopper_Refuse

function MsgType.Response_Shopper_Refuse:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Refuse:GetCmd()
    return MsgTypeCmd.Response_Shopper_Refuse_Cmd
end
function MsgType.Response_Shopper_Refuse:GetUrl()
    return "Response_Shopper_Refuse"
end
function MsgType.Response_Shopper_Refuse:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Shopper_Checkout = {
    msgSeq = 0,
    shopperUid = 0
}
MsgType.Request_Shopper_Checkout.__index = MsgType.Request_Shopper_Checkout

function MsgType.Request_Shopper_Checkout:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Checkout:GetCmd()
    return MsgTypeCmd.Request_Shopper_Checkout_Cmd
end
function MsgType.Request_Shopper_Checkout:GetUrl()
    return "Request_Shopper_Checkout"
end
function MsgType.Request_Shopper_Checkout:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    return tb
end

function MsgType.Request_Shopper_Checkout:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Checkout:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Checkout = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopperUid = 0,
    shopperEquipId = 0,
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_Shopper_Checkout.__index = MsgType.Response_Shopper_Checkout

function MsgType.Response_Shopper_Checkout:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Checkout:GetCmd()
    return MsgTypeCmd.Response_Shopper_Checkout_Cmd
end
function MsgType.Response_Shopper_Checkout:GetUrl()
    return "Response_Shopper_Checkout"
end
function MsgType.Response_Shopper_Checkout:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopperUid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.shopperEquipId = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.h[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Request_Shopper_Recommend = {
    msgSeq = 0,
    shopperUid = 0,
    equipUid = ""
}
MsgType.Request_Shopper_Recommend.__index = MsgType.Request_Shopper_Recommend

function MsgType.Request_Shopper_Recommend:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Recommend:GetCmd()
    return MsgTypeCmd.Request_Shopper_Recommend_Cmd
end
function MsgType.Request_Shopper_Recommend:GetUrl()
    return "Request_Shopper_Recommend"
end
function MsgType.Request_Shopper_Recommend:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.d = self.equipUid
    end
    return tb
end

function MsgType.Request_Shopper_Recommend:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Recommend:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Recommend = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Shopper_Recommend.__index = MsgType.Response_Shopper_Recommend

function MsgType.Response_Shopper_Recommend:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Recommend:GetCmd()
    return MsgTypeCmd.Response_Shopper_Recommend_Cmd
end
function MsgType.Response_Shopper_Recommend:GetUrl()
    return "Response_Shopper_Recommend"
end
function MsgType.Response_Shopper_Recommend:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Shopper_Queue = {
    msgSeq = 0,
    shopperUid = 0,
    equipUid = "",
    equipId = 0
}
MsgType.Request_Shopper_Queue.__index = MsgType.Request_Shopper_Queue

function MsgType.Request_Shopper_Queue:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Queue:GetCmd()
    return MsgTypeCmd.Request_Shopper_Queue_Cmd
end
function MsgType.Request_Shopper_Queue:GetUrl()
    return "Request_Shopper_Queue"
end
function MsgType.Request_Shopper_Queue:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    if nil ~= self.equipUid and string.len(self.equipUid) > 0 then
        tb.d = self.equipUid
    end
    if nil ~= self.equipId and 0 ~= self.equipId then
        tb.e = self.equipId
    end
    return tb
end

function MsgType.Request_Shopper_Queue:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Queue:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Queue = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopperUid = 0,
    equipUid = "",
    equipId = 0
}
MsgType.Response_Shopper_Queue.__index = MsgType.Response_Shopper_Queue

function MsgType.Response_Shopper_Queue:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Queue:GetCmd()
    return MsgTypeCmd.Response_Shopper_Queue_Cmd
end
function MsgType.Response_Shopper_Queue:GetUrl()
    return "Response_Shopper_Queue"
end
function MsgType.Response_Shopper_Queue:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopperUid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.equipUid = tostring(data.g)
    end
    if nil ~= data.h then
        self.equipId = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_Shopper_Energy = {
    msgSeq = 0,
    shopperUid = 0,
    furnitureUid = 0,
    petUid = 0
}
MsgType.Request_Shopper_Energy.__index = MsgType.Request_Shopper_Energy

function MsgType.Request_Shopper_Energy:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Shopper_Energy:GetCmd()
    return MsgTypeCmd.Request_Shopper_Energy_Cmd
end
function MsgType.Request_Shopper_Energy:GetUrl()
    return "Request_Shopper_Energy"
end
function MsgType.Request_Shopper_Energy:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.shopperUid and 0 ~= self.shopperUid then
        tb.c = self.shopperUid
    end
    if nil ~= self.furnitureUid and 0 ~= self.furnitureUid then
        tb.d = self.furnitureUid
    end
    if nil ~= self.petUid and 0 ~= self.petUid then
        tb.e = self.petUid
    end
    return tb
end

function MsgType.Request_Shopper_Energy:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Shopper_Energy:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Shopper_Energy = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    shopperUid = 0,
    energy = 0
}
MsgType.Response_Shopper_Energy.__index = MsgType.Response_Shopper_Energy

function MsgType.Response_Shopper_Energy:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Shopper_Energy:GetCmd()
    return MsgTypeCmd.Response_Shopper_Energy_Cmd
end
function MsgType.Response_Shopper_Energy:GetUrl()
    return "Response_Shopper_Energy"
end
function MsgType.Response_Shopper_Energy:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.shopperUid = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.energy = tonumber(data.g) or 0
    end
    return self
end


MsgType.EPiggyBankState = {
    hasNotStarted = 0,
    Processing = 1,
    Pending = 2
}

MsgType.PiggyBankData = {
    Id = 0,
    currOrderIndex = 0,
    piggyBankState = 0, --enum EPiggyBankState
    stateCoolTime = 0,
    targetGoldCount = 0,
    hasBeenStored = 0,
    startMinLevel = 0
}
MsgType.PiggyBankData.__index = MsgType.PiggyBankData

function MsgType.PiggyBankData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PiggyBankData:Encode()
    local tb = {}
    if nil ~= self.Id and 0 ~= self.Id then
        tb.b = self.Id
    end
    if nil ~= self.currOrderIndex and 0 ~= self.currOrderIndex then
        tb.c = self.currOrderIndex
    end
    if nil ~= self.piggyBankState and 0 ~= self.piggyBankState then
        tb.d = self.piggyBankState
    end
    if nil ~= self.stateCoolTime and 0 ~= self.stateCoolTime then
        tb.e = self.stateCoolTime
    end
    if nil ~= self.targetGoldCount and 0 ~= self.targetGoldCount then
        tb.f = self.targetGoldCount
    end
    if nil ~= self.hasBeenStored and 0 ~= self.hasBeenStored then
        tb.g = self.hasBeenStored
    end
    if nil ~= self.startMinLevel and 0 ~= self.startMinLevel then
        tb.h = self.startMinLevel
    end
    return tb
end

function MsgType.PiggyBankData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.Id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.currOrderIndex = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.piggyBankState = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.stateCoolTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.targetGoldCount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.hasBeenStored = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.startMinLevel = tonumber(data.h) or 0
    end
    return self
end

function MsgType.PiggyBankData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.PiggyBankData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_PiggyBank_ClickData = {
    msgSeq = 0,
    level = 0
}
MsgType.Request_PiggyBank_ClickData.__index = MsgType.Request_PiggyBank_ClickData

function MsgType.Request_PiggyBank_ClickData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PiggyBank_ClickData:GetCmd()
    return MsgTypeCmd.Request_PiggyBank_ClickData_Cmd
end
function MsgType.Request_PiggyBank_ClickData:GetUrl()
    return "Request_PiggyBank_ClickData"
end
function MsgType.Request_PiggyBank_ClickData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.level and 0 ~= self.level then
        tb.c = self.level
    end
    return tb
end

function MsgType.Request_PiggyBank_ClickData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PiggyBank_ClickData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PiggyBank_BaseData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    piggyBankData = {}
}
MsgType.Response_PiggyBank_BaseData.__index = MsgType.Response_PiggyBank_BaseData
setmetatable(MsgType.Response_PiggyBank_BaseData.piggyBankData, MsgType.PiggyBankData)

function MsgType.Response_PiggyBank_BaseData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.piggyBankData = MsgType.PiggyBankData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PiggyBank_BaseData:GetCmd()
    return MsgTypeCmd.Response_PiggyBank_BaseData_Cmd
end
function MsgType.Response_PiggyBank_BaseData:GetUrl()
    return "Response_PiggyBank_BaseData"
end
function MsgType.Response_PiggyBank_BaseData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.piggyBankData:Decode(data.f)
    end
    return self
end


MsgType.Request_PiggyBank_Props = {
    msgSeq = 0,
    receive = 0
}
MsgType.Request_PiggyBank_Props.__index = MsgType.Request_PiggyBank_Props

function MsgType.Request_PiggyBank_Props:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PiggyBank_Props:GetCmd()
    return MsgTypeCmd.Request_PiggyBank_Props_Cmd
end
function MsgType.Request_PiggyBank_Props:GetUrl()
    return "Request_PiggyBank_Props"
end
function MsgType.Request_PiggyBank_Props:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.receive and 0 ~= self.receive then
        tb.c = self.receive
    end
    return tb
end

function MsgType.Request_PiggyBank_Props:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PiggyBank_Props:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PiggyBank_Props = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    piggyBankData = {},
    rewardType = 0,
    rewardId = 0,
    rewardNum = 0
}
MsgType.Response_PiggyBank_Props.__index = MsgType.Response_PiggyBank_Props
setmetatable(MsgType.Response_PiggyBank_Props.piggyBankData, MsgType.PiggyBankData)

function MsgType.Response_PiggyBank_Props:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.piggyBankData = MsgType.PiggyBankData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PiggyBank_Props:GetCmd()
    return MsgTypeCmd.Response_PiggyBank_Props_Cmd
end
function MsgType.Response_PiggyBank_Props:GetUrl()
    return "Response_PiggyBank_Props"
end
function MsgType.Response_PiggyBank_Props:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.piggyBankData:Decode(data.f)
    end
    if nil ~= data.g then
        self.rewardType = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.rewardId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.rewardNum = tonumber(data.i) or 0
    end
    return self
end


MsgType.EChatChannel = {
    World = 0,
    RaceLamp = 1,
    Union = 2,
    System = 3
}

MsgType.ESystemMsgType = {
    EnterUnion = 1,
    LeaveUnion = 2,
    UnionHelp = 3,
    UnionBuildCost = 4,
    UnionHighPriceSold = 5,
    UnionMakeMastered = 6
}

MsgType.ChatContent = {
    chatIndex = 0,
    chatTime = 0,
    userId = "",
    nickName = "",
    gender = 0, --enum EGender
    level = 0,
    roleDress = {},
    content = ""
}
MsgType.ChatContent.__index = MsgType.ChatContent
setmetatable(MsgType.ChatContent.roleDress, MsgType.RoleDress)

function MsgType.ChatContent:New()
    local tb = {}
    setmetatable(tb, self)
    tb.roleDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.ChatContent:Encode()
    local tb = {}
    if nil ~= self.chatIndex and 0 ~= self.chatIndex then
        tb.b = self.chatIndex
    end
    if nil ~= self.chatTime and 0 ~= self.chatTime then
        tb.c = self.chatTime
    end
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.d = self.userId
    end
    if nil ~= self.nickName and string.len(self.nickName) > 0 then
        tb.e = self.nickName
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.f = self.gender
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.g = self.level
    end
    tb.h = self.roleDress:Encode()
    if nil ~= self.content and string.len(self.content) > 0 then
        tb.i = self.content
    end
    return tb
end

function MsgType.ChatContent:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.chatIndex = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.chatTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.userId = tostring(data.d)
    end
    if nil ~= data.e then
        self.nickName = tostring(data.e)
    end
    if nil ~= data.f then
        self.gender = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.level = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.roleDress:Decode(data.h)
    end
    if nil ~= data.i then
        self.content = tostring(data.i)
    end
    return self
end

function MsgType.ChatContent:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ChatContent:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Chat_Data = {
    msgSeq = 0,
    chatChannel = 0, --enum EChatChannel
    chatIndex = 0,
    unionChatIndex = 0,
    unionId = "",
    systemMsgIndex = 0
}
MsgType.Request_Chat_Data.__index = MsgType.Request_Chat_Data

function MsgType.Request_Chat_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Chat_Data:GetCmd()
    return MsgTypeCmd.Request_Chat_Data_Cmd
end
function MsgType.Request_Chat_Data:GetUrl()
    return "Request_Chat_Data"
end
function MsgType.Request_Chat_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.chatChannel and 0 ~= self.chatChannel then
        tb.c = self.chatChannel
    end
    if nil ~= self.chatIndex and 0 ~= self.chatIndex then
        tb.d = self.chatIndex
    end
    if nil ~= self.unionChatIndex and 0 ~= self.unionChatIndex then
        tb.e = self.unionChatIndex
    end
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.f = self.unionId
    end
    if nil ~= self.systemMsgIndex and 0 ~= self.systemMsgIndex then
        tb.g = self.systemMsgIndex
    end
    return tb
end

function MsgType.Request_Chat_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Chat_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Chat_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    chatChannel = 0, --enum EChatChannel
    chatList = {} -- array of MsgType.ChatContent
}
MsgType.Response_Chat_Data.__index = MsgType.Response_Chat_Data

function MsgType.Response_Chat_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.chatList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Chat_Data:GetCmd()
    return MsgTypeCmd.Response_Chat_Data_Cmd
end
function MsgType.Response_Chat_Data:GetUrl()
    return "Response_Chat_Data"
end
function MsgType.Response_Chat_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.chatChannel = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpChatListObj = MsgType.ChatContent:New()
            tmpChatListObj:Decode(data.g[i])
            self.chatList[i] = tmpChatListObj
        end
    end
    return self
end


MsgType.Request_Chat_Send = {
    msgSeq = 0,
    chatChannel = 0, --enum EChatChannel
    content = ""
}
MsgType.Request_Chat_Send.__index = MsgType.Request_Chat_Send

function MsgType.Request_Chat_Send:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Chat_Send:GetCmd()
    return MsgTypeCmd.Request_Chat_Send_Cmd
end
function MsgType.Request_Chat_Send:GetUrl()
    return "Request_Chat_Send"
end
function MsgType.Request_Chat_Send:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.chatChannel and 0 ~= self.chatChannel then
        tb.c = self.chatChannel
    end
    if nil ~= self.content and string.len(self.content) > 0 then
        tb.d = self.content
    end
    return tb
end

function MsgType.Request_Chat_Send:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Chat_Send:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Chat_Send = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Chat_Send.__index = MsgType.Response_Chat_Send

function MsgType.Response_Chat_Send:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Chat_Send:GetCmd()
    return MsgTypeCmd.Response_Chat_Send_Cmd
end
function MsgType.Response_Chat_Send:GetUrl()
    return "Response_Chat_Send"
end
function MsgType.Response_Chat_Send:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Union_Data = {
    msgSeq = 0,
    unionId = ""
}
MsgType.Request_Union_Data.__index = MsgType.Request_Union_Data

function MsgType.Request_Union_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_Data:GetCmd()
    return MsgTypeCmd.Request_Union_Data_Cmd
end
function MsgType.Request_Union_Data:GetUrl()
    return "Request_Union_Data"
end
function MsgType.Request_Union_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.c = self.unionId
    end
    return tb
end

function MsgType.Request_Union_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionDetailData = {}
}
MsgType.Response_Union_Data.__index = MsgType.Response_Union_Data
setmetatable(MsgType.Response_Union_Data.unionDetailData, MsgType.UnionDetailData)

function MsgType.Response_Union_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionDetailData = MsgType.UnionDetailData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_Data:GetCmd()
    return MsgTypeCmd.Response_Union_Data_Cmd
end
function MsgType.Response_Union_Data:GetUrl()
    return "Response_Union_Data"
end
function MsgType.Response_Union_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.unionDetailData:Decode(data.f)
    end
    return self
end


MsgType.Request_Union_List = {
    msgSeq = 0,
    searchName = ""
}
MsgType.Request_Union_List.__index = MsgType.Request_Union_List

function MsgType.Request_Union_List:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_List:GetCmd()
    return MsgTypeCmd.Request_Union_List_Cmd
end
function MsgType.Request_Union_List:GetUrl()
    return "Request_Union_List"
end
function MsgType.Request_Union_List:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.searchName and string.len(self.searchName) > 0 then
        tb.c = self.searchName
    end
    return tb
end

function MsgType.Request_Union_List:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_List:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_List = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionList = {} -- array of MsgType.UnionSimpleData
}
MsgType.Response_Union_List.__index = MsgType.Response_Union_List

function MsgType.Response_Union_List:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_List:GetCmd()
    return MsgTypeCmd.Response_Union_List_Cmd
end
function MsgType.Response_Union_List:GetUrl()
    return "Response_Union_List"
end
function MsgType.Response_Union_List:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpUnionListObj = MsgType.UnionSimpleData:New()
            tmpUnionListObj:Decode(data.f[i])
            self.unionList[i] = tmpUnionListObj
        end
    end
    return self
end


MsgType.Request_Union_Create = {
    msgSeq = 0,
    unionName = "",
    enterSetting = 0, --enum EUnionEnter
    enterLevel = 0,
    useGem = 0,
    enterInvest = 0
}
MsgType.Request_Union_Create.__index = MsgType.Request_Union_Create

function MsgType.Request_Union_Create:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_Create:GetCmd()
    return MsgTypeCmd.Request_Union_Create_Cmd
end
function MsgType.Request_Union_Create:GetUrl()
    return "Request_Union_Create"
end
function MsgType.Request_Union_Create:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unionName and string.len(self.unionName) > 0 then
        tb.c = self.unionName
    end
    if nil ~= self.enterSetting and 0 ~= self.enterSetting then
        tb.d = self.enterSetting
    end
    if nil ~= self.enterLevel and 0 ~= self.enterLevel then
        tb.e = self.enterLevel
    end
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.f = self.useGem
    end
    if nil ~= self.enterInvest and 0 ~= self.enterInvest then
        tb.g = self.enterInvest
    end
    return tb
end

function MsgType.Request_Union_Create:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_Create:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_Create = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionData = {}
}
MsgType.Response_Union_Create.__index = MsgType.Response_Union_Create
setmetatable(MsgType.Response_Union_Create.unionData, MsgType.UnionData)

function MsgType.Response_Union_Create:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionData = MsgType.UnionData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_Create:GetCmd()
    return MsgTypeCmd.Response_Union_Create_Cmd
end
function MsgType.Response_Union_Create:GetUrl()
    return "Response_Union_Create"
end
function MsgType.Response_Union_Create:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.unionData:Decode(data.f)
    end
    return self
end


MsgType.Request_Union_Enter = {
    msgSeq = 0,
    unionId = ""
}
MsgType.Request_Union_Enter.__index = MsgType.Request_Union_Enter

function MsgType.Request_Union_Enter:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_Enter:GetCmd()
    return MsgTypeCmd.Request_Union_Enter_Cmd
end
function MsgType.Request_Union_Enter:GetUrl()
    return "Request_Union_Enter"
end
function MsgType.Request_Union_Enter:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.c = self.unionId
    end
    return tb
end

function MsgType.Request_Union_Enter:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_Enter:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_Enter = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionId = "",
    unionData = {}
}
MsgType.Response_Union_Enter.__index = MsgType.Response_Union_Enter
setmetatable(MsgType.Response_Union_Enter.unionData, MsgType.UnionData)

function MsgType.Response_Union_Enter:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionData = MsgType.UnionData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_Enter:GetCmd()
    return MsgTypeCmd.Response_Union_Enter_Cmd
end
function MsgType.Response_Union_Enter:GetUrl()
    return "Response_Union_Enter"
end
function MsgType.Response_Union_Enter:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.unionId = tostring(data.f)
    end
    if nil ~= data.g then
        self.unionData:Decode(data.g)
    end
    return self
end


MsgType.Request_Union_Leave = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Union_Leave.__index = MsgType.Request_Union_Leave

function MsgType.Request_Union_Leave:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_Leave:GetCmd()
    return MsgTypeCmd.Request_Union_Leave_Cmd
end
function MsgType.Request_Union_Leave:GetUrl()
    return "Request_Union_Leave"
end
function MsgType.Request_Union_Leave:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Union_Leave:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_Leave:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_Leave = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionData = {}
}
MsgType.Response_Union_Leave.__index = MsgType.Response_Union_Leave
setmetatable(MsgType.Response_Union_Leave.unionData, MsgType.UnionData)

function MsgType.Response_Union_Leave:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionData = MsgType.UnionData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_Leave:GetCmd()
    return MsgTypeCmd.Response_Union_Leave_Cmd
end
function MsgType.Response_Union_Leave:GetUrl()
    return "Response_Union_Leave"
end
function MsgType.Response_Union_Leave:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.unionData:Decode(data.f)
    end
    return self
end


MsgType.Request_Union_UserData = {
    msgSeq = 0,
    searchName = ""
}
MsgType.Request_Union_UserData.__index = MsgType.Request_Union_UserData

function MsgType.Request_Union_UserData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_UserData:GetCmd()
    return MsgTypeCmd.Request_Union_UserData_Cmd
end
function MsgType.Request_Union_UserData:GetUrl()
    return "Request_Union_UserData"
end
function MsgType.Request_Union_UserData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.searchName and string.len(self.searchName) > 0 then
        tb.c = self.searchName
    end
    return tb
end

function MsgType.Request_Union_UserData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_UserData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_UserData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionMemberList = {} -- array of MsgType.UnionMemberData
}
MsgType.Response_Union_UserData.__index = MsgType.Response_Union_UserData

function MsgType.Response_Union_UserData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionMemberList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_UserData:GetCmd()
    return MsgTypeCmd.Response_Union_UserData_Cmd
end
function MsgType.Response_Union_UserData:GetUrl()
    return "Response_Union_UserData"
end
function MsgType.Response_Union_UserData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpUnionMemberListObj = MsgType.UnionMemberData:New()
            tmpUnionMemberListObj:Decode(data.f[i])
            self.unionMemberList[i] = tmpUnionMemberListObj
        end
    end
    return self
end


MsgType.Request_Union_KickOut = {
    msgSeq = 0,
    targetId = ""
}
MsgType.Request_Union_KickOut.__index = MsgType.Request_Union_KickOut

function MsgType.Request_Union_KickOut:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_KickOut:GetCmd()
    return MsgTypeCmd.Request_Union_KickOut_Cmd
end
function MsgType.Request_Union_KickOut:GetUrl()
    return "Request_Union_KickOut"
end
function MsgType.Request_Union_KickOut:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.targetId and string.len(self.targetId) > 0 then
        tb.c = self.targetId
    end
    return tb
end

function MsgType.Request_Union_KickOut:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_KickOut:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_KickOut = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionDetailData = {}
}
MsgType.Response_Union_KickOut.__index = MsgType.Response_Union_KickOut
setmetatable(MsgType.Response_Union_KickOut.unionDetailData, MsgType.UnionDetailData)

function MsgType.Response_Union_KickOut:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionDetailData = MsgType.UnionDetailData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_KickOut:GetCmd()
    return MsgTypeCmd.Response_Union_KickOut_Cmd
end
function MsgType.Response_Union_KickOut:GetUrl()
    return "Response_Union_KickOut"
end
function MsgType.Response_Union_KickOut:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.unionDetailData:Decode(data.f)
    end
    return self
end


MsgType.Request_Union_SetInfo = {
    msgSeq = 0,
    enterSetting = 0, --enum EUnionEnter
    enterLevel = 0,
    unionName = "",
    enterInvest = 0
}
MsgType.Request_Union_SetInfo.__index = MsgType.Request_Union_SetInfo

function MsgType.Request_Union_SetInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_SetInfo:GetCmd()
    return MsgTypeCmd.Request_Union_SetInfo_Cmd
end
function MsgType.Request_Union_SetInfo:GetUrl()
    return "Request_Union_SetInfo"
end
function MsgType.Request_Union_SetInfo:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.enterSetting and 0 ~= self.enterSetting then
        tb.c = self.enterSetting
    end
    if nil ~= self.enterLevel and 0 ~= self.enterLevel then
        tb.d = self.enterLevel
    end
    if nil ~= self.unionName and string.len(self.unionName) > 0 then
        tb.e = self.unionName
    end
    if nil ~= self.enterInvest and 0 ~= self.enterInvest then
        tb.f = self.enterInvest
    end
    return tb
end

function MsgType.Request_Union_SetInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_SetInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_SetInfo = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionDetailData = {}
}
MsgType.Response_Union_SetInfo.__index = MsgType.Response_Union_SetInfo
setmetatable(MsgType.Response_Union_SetInfo.unionDetailData, MsgType.UnionDetailData)

function MsgType.Response_Union_SetInfo:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionDetailData = MsgType.UnionDetailData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_SetInfo:GetCmd()
    return MsgTypeCmd.Response_Union_SetInfo_Cmd
end
function MsgType.Response_Union_SetInfo:GetUrl()
    return "Response_Union_SetInfo"
end
function MsgType.Response_Union_SetInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.unionDetailData:Decode(data.f)
    end
    return self
end


MsgType.Request_Union_SetUserRole = {
    msgSeq = 0,
    targetId = "",
    unionJob = 0 --enum EUnionJob
}
MsgType.Request_Union_SetUserRole.__index = MsgType.Request_Union_SetUserRole

function MsgType.Request_Union_SetUserRole:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_SetUserRole:GetCmd()
    return MsgTypeCmd.Request_Union_SetUserRole_Cmd
end
function MsgType.Request_Union_SetUserRole:GetUrl()
    return "Request_Union_SetUserRole"
end
function MsgType.Request_Union_SetUserRole:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.targetId and string.len(self.targetId) > 0 then
        tb.c = self.targetId
    end
    if nil ~= self.unionJob and 0 ~= self.unionJob then
        tb.d = self.unionJob
    end
    return tb
end

function MsgType.Request_Union_SetUserRole:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_SetUserRole:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_SetUserRole = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionDetailData = {},
    userId = ""
}
MsgType.Response_Union_SetUserRole.__index = MsgType.Response_Union_SetUserRole
setmetatable(MsgType.Response_Union_SetUserRole.unionDetailData, MsgType.UnionDetailData)

function MsgType.Response_Union_SetUserRole:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionDetailData = MsgType.UnionDetailData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_SetUserRole:GetCmd()
    return MsgTypeCmd.Response_Union_SetUserRole_Cmd
end
function MsgType.Response_Union_SetUserRole:GetUrl()
    return "Response_Union_SetUserRole"
end
function MsgType.Response_Union_SetUserRole:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.unionDetailData:Decode(data.f)
    end
    if nil ~= data.g then
        self.userId = tostring(data.g)
    end
    return self
end


MsgType.Request_Union_SearchUserData = {
    msgSeq = 0,
    userId = ""
}
MsgType.Request_Union_SearchUserData.__index = MsgType.Request_Union_SearchUserData

function MsgType.Request_Union_SearchUserData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_SearchUserData:GetCmd()
    return MsgTypeCmd.Request_Union_SearchUserData_Cmd
end
function MsgType.Request_Union_SearchUserData:GetUrl()
    return "Request_Union_SearchUserData"
end
function MsgType.Request_Union_SearchUserData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.c = self.userId
    end
    return tb
end

function MsgType.Request_Union_SearchUserData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_SearchUserData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_SearchUserData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userId = "",
    userData = {},
    unionData = {},
    lastActiveTime = 0,
    petInfo = {},
    vipData = {}
}
MsgType.Response_Union_SearchUserData.__index = MsgType.Response_Union_SearchUserData
setmetatable(MsgType.Response_Union_SearchUserData.userData, MsgType.UserData)
setmetatable(MsgType.Response_Union_SearchUserData.unionData, MsgType.UnionData)
setmetatable(MsgType.Response_Union_SearchUserData.petInfo, MsgType.OnePetInfo)
setmetatable(MsgType.Response_Union_SearchUserData.vipData, MsgType.VIPInfo)

function MsgType.Response_Union_SearchUserData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userData = MsgType.UserData:New()
    tb.unionData = MsgType.UnionData:New()
    tb.petInfo = MsgType.OnePetInfo:New()
    tb.vipData = MsgType.VIPInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_SearchUserData:GetCmd()
    return MsgTypeCmd.Response_Union_SearchUserData_Cmd
end
function MsgType.Response_Union_SearchUserData:GetUrl()
    return "Response_Union_SearchUserData"
end
function MsgType.Response_Union_SearchUserData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userId = tostring(data.f)
    end
    if nil ~= data.g then
        self.userData:Decode(data.g)
    end
    if nil ~= data.h then
        self.unionData:Decode(data.h)
    end
    if nil ~= data.i then
        self.lastActiveTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.petInfo:Decode(data.j)
    end
    if nil ~= data.k then
        self.vipData:Decode(data.k)
    end
    return self
end


MsgType.Response_Union_MessageInfo = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionMsgList = {}, -- array of MsgType.UnionMsgData
    unionMsgUid = 0
}
MsgType.Response_Union_MessageInfo.__index = MsgType.Response_Union_MessageInfo

function MsgType.Response_Union_MessageInfo:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionMsgList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_MessageInfo:GetCmd()
    return MsgTypeCmd.Response_Union_MessageInfo_Cmd
end
function MsgType.Response_Union_MessageInfo:GetUrl()
    return "Response_Union_MessageInfo"
end
function MsgType.Response_Union_MessageInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpUnionMsgListObj = MsgType.UnionMsgData:New()
            tmpUnionMsgListObj:Decode(data.f[i])
            self.unionMsgList[i] = tmpUnionMsgListObj
        end
    end
    if nil ~= data.g then
        self.unionMsgUid = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Union_MessageInfoRefresh = {
    msgSeq = 0,
    unionMsgUid = 0
}
MsgType.Request_Union_MessageInfoRefresh.__index = MsgType.Request_Union_MessageInfoRefresh

function MsgType.Request_Union_MessageInfoRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_MessageInfoRefresh:GetCmd()
    return MsgTypeCmd.Request_Union_MessageInfoRefresh_Cmd
end
function MsgType.Request_Union_MessageInfoRefresh:GetUrl()
    return "Request_Union_MessageInfoRefresh"
end
function MsgType.Request_Union_MessageInfoRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.unionMsgUid and 0 ~= self.unionMsgUid then
        tb.c = self.unionMsgUid
    end
    return tb
end

function MsgType.Request_Union_MessageInfoRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_MessageInfoRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_MessageInfoRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    unionMsgList = {}, -- array of MsgType.UnionMsgData
    unionMsgUid = 0
}
MsgType.Response_Union_MessageInfoRefresh.__index = MsgType.Response_Union_MessageInfoRefresh

function MsgType.Response_Union_MessageInfoRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionMsgList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_MessageInfoRefresh:GetCmd()
    return MsgTypeCmd.Response_Union_MessageInfoRefresh_Cmd
end
function MsgType.Response_Union_MessageInfoRefresh:GetUrl()
    return "Response_Union_MessageInfoRefresh"
end
function MsgType.Response_Union_MessageInfoRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpUnionMsgListObj = MsgType.UnionMsgData:New()
            tmpUnionMsgListObj:Decode(data.f[i])
            self.unionMsgList[i] = tmpUnionMsgListObj
        end
    end
    if nil ~= data.g then
        self.unionMsgUid = tonumber(data.g) or 0
    end
    return self
end


MsgType.EHelpFurnitureType = {
    ShopInfo = 1,
    CounterInfo = 2,
    StoreBasketList = 3,
    ResBasketList = 4,
    ShelfList = 5
}

MsgType.OneUnionMemberHelpData = {
    userId = ""
}
MsgType.OneUnionMemberHelpData.__index = MsgType.OneUnionMemberHelpData

function MsgType.OneUnionMemberHelpData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneUnionMemberHelpData:Encode()
    local tb = {}
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.b = self.userId
    end
    return tb
end

function MsgType.OneUnionMemberHelpData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.userId = tostring(data.b)
    end
    return self
end

function MsgType.OneUnionMemberHelpData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneUnionMemberHelpData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneHelpData = {
    furnitureUid = 0,
    furnitureId = 0,
    furnitureType = 0, --enum EHelpFurnitureType
    userId = "",
    name = "",
    gender = 0,
    userLevel = 0,
    userDress = {},
    level = 0,
    unionId = "",
    showFlag = 0,
    stateEndTime = 0,
    memberList = {} -- array of MsgType.OneUnionMemberHelpData
}
MsgType.OneHelpData.__index = MsgType.OneHelpData
setmetatable(MsgType.OneHelpData.userDress, MsgType.RoleDress)

function MsgType.OneHelpData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.userDress = MsgType.RoleDress:New()
    tb.memberList = {}
    return tb
end

function MsgType.OneHelpData:_memberListEncode()
    local tb = {}
    for i=1, #self.memberList do
        tb[i] = self.memberList[i]:Encode()
    end
    return tb
end
function MsgType.OneHelpData:Encode()
    local tb = {}
    if nil ~= self.furnitureUid and 0 ~= self.furnitureUid then
        tb.b = self.furnitureUid
    end
    if nil ~= self.furnitureId and 0 ~= self.furnitureId then
        tb.c = self.furnitureId
    end
    if nil ~= self.furnitureType and 0 ~= self.furnitureType then
        tb.d = self.furnitureType
    end
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.e = self.userId
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.f = self.name
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.g = self.gender
    end
    if nil ~= self.userLevel and 0 ~= self.userLevel then
        tb.h = self.userLevel
    end
    tb.i = self.userDress:Encode()
    if nil ~= self.level and 0 ~= self.level then
        tb.j = self.level
    end
    if nil ~= self.unionId and string.len(self.unionId) > 0 then
        tb.k = self.unionId
    end
    if nil ~= self.showFlag and 0 ~= self.showFlag then
        tb.l = self.showFlag
    end
    if nil ~= self.stateEndTime and 0 ~= self.stateEndTime then
        tb.m = self.stateEndTime
    end
    tb.n = self:_memberListEncode()
    return tb
end

function MsgType.OneHelpData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.furnitureUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.furnitureId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.furnitureType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.userId = tostring(data.e)
    end
    if nil ~= data.f then
        self.name = tostring(data.f)
    end
    if nil ~= data.g then
        self.gender = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.userLevel = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.userDress:Decode(data.i)
    end
    if nil ~= data.j then
        self.level = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.unionId = tostring(data.k)
    end
    if nil ~= data.l then
        self.showFlag = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.stateEndTime = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        for i=1, #data.n do
            local tmpMemberListObj = MsgType.OneUnionMemberHelpData:New()
            tmpMemberListObj:Decode(data.n[i])
            self.memberList[i] = tmpMemberListObj
        end
    end
    return self
end

function MsgType.OneHelpData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneHelpData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Union_MemberHelpList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Union_MemberHelpList.__index = MsgType.Request_Union_MemberHelpList

function MsgType.Request_Union_MemberHelpList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_MemberHelpList:GetCmd()
    return MsgTypeCmd.Request_Union_MemberHelpList_Cmd
end
function MsgType.Request_Union_MemberHelpList:GetUrl()
    return "Request_Union_MemberHelpList"
end
function MsgType.Request_Union_MemberHelpList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Union_MemberHelpList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_MemberHelpList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_MemberHelpList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    helpList = {}, -- array of MsgType.OneHelpData
    furnitureFlag = 0,
    shopFlag = 0
}
MsgType.Response_Union_MemberHelpList.__index = MsgType.Response_Union_MemberHelpList

function MsgType.Response_Union_MemberHelpList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.helpList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_MemberHelpList:GetCmd()
    return MsgTypeCmd.Response_Union_MemberHelpList_Cmd
end
function MsgType.Response_Union_MemberHelpList:GetUrl()
    return "Response_Union_MemberHelpList"
end
function MsgType.Response_Union_MemberHelpList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpHelpListObj = MsgType.OneHelpData:New()
            tmpHelpListObj:Decode(data.f[i])
            self.helpList[i] = tmpHelpListObj
        end
    end
    if nil ~= data.g then
        self.furnitureFlag = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.shopFlag = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_Union_SetHelp = {
    msgSeq = 0,
    furnitureUid = 0
}
MsgType.Request_Union_SetHelp.__index = MsgType.Request_Union_SetHelp

function MsgType.Request_Union_SetHelp:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_SetHelp:GetCmd()
    return MsgTypeCmd.Request_Union_SetHelp_Cmd
end
function MsgType.Request_Union_SetHelp:GetUrl()
    return "Request_Union_SetHelp"
end
function MsgType.Request_Union_SetHelp:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.furnitureUid and 0 ~= self.furnitureUid then
        tb.c = self.furnitureUid
    end
    return tb
end

function MsgType.Request_Union_SetHelp:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_SetHelp:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_SetHelp = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    helpList = {}, -- array of MsgType.OneHelpData
    furnitureFlag = 0,
    shopFlag = 0
}
MsgType.Response_Union_SetHelp.__index = MsgType.Response_Union_SetHelp

function MsgType.Response_Union_SetHelp:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.helpList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_SetHelp:GetCmd()
    return MsgTypeCmd.Response_Union_SetHelp_Cmd
end
function MsgType.Response_Union_SetHelp:GetUrl()
    return "Response_Union_SetHelp"
end
function MsgType.Response_Union_SetHelp:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpHelpListObj = MsgType.OneHelpData:New()
            tmpHelpListObj:Decode(data.f[i])
            self.helpList[i] = tmpHelpListObj
        end
    end
    if nil ~= data.g then
        self.furnitureFlag = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.shopFlag = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_Union_HelpMember = {
    msgSeq = 0,
    furnitureUid = 0,
    userId = "",
    helpAll = 0,
    useGem = 0
}
MsgType.Request_Union_HelpMember.__index = MsgType.Request_Union_HelpMember

function MsgType.Request_Union_HelpMember:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_HelpMember:GetCmd()
    return MsgTypeCmd.Request_Union_HelpMember_Cmd
end
function MsgType.Request_Union_HelpMember:GetUrl()
    return "Request_Union_HelpMember"
end
function MsgType.Request_Union_HelpMember:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.furnitureUid and 0 ~= self.furnitureUid then
        tb.c = self.furnitureUid
    end
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.d = self.userId
    end
    if nil ~= self.helpAll and 0 ~= self.helpAll then
        tb.e = self.helpAll
    end
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.f = self.useGem
    end
    return tb
end

function MsgType.Request_Union_HelpMember:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_HelpMember:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_HelpMember = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    helpList = {} -- array of MsgType.OneHelpData
}
MsgType.Response_Union_HelpMember.__index = MsgType.Response_Union_HelpMember

function MsgType.Response_Union_HelpMember:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.helpList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_HelpMember:GetCmd()
    return MsgTypeCmd.Response_Union_HelpMember_Cmd
end
function MsgType.Response_Union_HelpMember:GetUrl()
    return "Response_Union_HelpMember"
end
function MsgType.Response_Union_HelpMember:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpHelpListObj = MsgType.OneHelpData:New()
            tmpHelpListObj:Decode(data.f[i])
            self.helpList[i] = tmpHelpListObj
        end
    end
    return self
end


MsgType.EUnionTaskType = {
    Equip = 1,
    UnionGemHelp = 2,
    OpenBox = 3,
    ResourceItem = 4,
    EquipSoldUp = 5,
    EquipSoldDown = 6,
    ExploreHeroCount = 7
}

MsgType.EUnionTaskShowType = {
    Equip_Easy = 1,
    Equip_Normal = 2,
    Equip_Hard = 3,
    UnionGemHelp = 4,
    OpenBox = 5,
    ResourceItem_Easy = 6,
    ResourceItem_Normal = 7,
    ResourceItem_Hard = 8,
    EquipSoldUp_Easy = 9,
    EquipSoldUp_Normal = 10,
    EquipSoldUp_Hard = 11,
    EquipSoldDown_Easy = 12,
    EquipSoldDown_Normal = 13,
    EquipSoldDown_Hard = 14,
    ExploreHeroCount_Easy = 15,
    ExploreHeroCount_Normal = 16,
    ExploreHeroCount_Hard = 17
}

MsgType.EUnionTaskRandomType = {
    Equip_Easy_Free = 1,
    Equip_Normal_Free = 2,
    Equip_Hard_Free = 3,
    Equip_Easy = 4,
    Equip_Normal = 5,
    Equip_Hard = 6,
    OpenBox = 7,
    ResourceItem_Free = 8,
    ResourceItem = 9,
    ExploreHeroCount = 10,
    EquipSoldUp = 11,
    EquipSoldDown = 12
}

MsgType.EUnionTaskState = {
    Idle = 1,
    Doing = 2,
    CanReward = 3,
    Done = 4
}

MsgType.OneUnionTaskData = {
    taskUid = 0,
    taskId = 0,
    userId = "",
    name = "",
    gender = 0,
    userDress = {},
    level = 0,
    state = 0, --enum EUnionTaskState
    endTime = 0,
    point = 0,
    taskTargetId = 0,
    process = 0,
    limit = 0
}
MsgType.OneUnionTaskData.__index = MsgType.OneUnionTaskData
setmetatable(MsgType.OneUnionTaskData.userDress, MsgType.RoleDress)

function MsgType.OneUnionTaskData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.userDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.OneUnionTaskData:Encode()
    local tb = {}
    if nil ~= self.taskUid and 0 ~= self.taskUid then
        tb.b = self.taskUid
    end
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.d = self.userId
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.e = self.name
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.f = self.gender
    end
    tb.g = self.userDress:Encode()
    if nil ~= self.level and 0 ~= self.level then
        tb.h = self.level
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.i = self.state
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.j = self.endTime
    end
    if nil ~= self.point and 0 ~= self.point then
        tb.k = self.point
    end
    if nil ~= self.taskTargetId and 0 ~= self.taskTargetId then
        tb.l = self.taskTargetId
    end
    if nil ~= self.process and 0 ~= self.process then
        tb.m = self.process
    end
    if nil ~= self.limit and 0 ~= self.limit then
        tb.n = self.limit
    end
    return tb
end

function MsgType.OneUnionTaskData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.taskUid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.userId = tostring(data.d)
    end
    if nil ~= data.e then
        self.name = tostring(data.e)
    end
    if nil ~= data.f then
        self.gender = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userDress:Decode(data.g)
    end
    if nil ~= data.h then
        self.level = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.state = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.endTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.point = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.taskTargetId = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.process = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.limit = tonumber(data.n) or 0
    end
    return self
end

function MsgType.OneUnionTaskData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneUnionTaskData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Union_TaskList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Union_TaskList.__index = MsgType.Request_Union_TaskList

function MsgType.Request_Union_TaskList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_TaskList:GetCmd()
    return MsgTypeCmd.Request_Union_TaskList_Cmd
end
function MsgType.Request_Union_TaskList:GetUrl()
    return "Request_Union_TaskList"
end
function MsgType.Request_Union_TaskList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Union_TaskList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_TaskList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_TaskList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneUnionTaskData
    unionTaskRefreshTime = 0,
    unionTaskCancelCoolTime = 0,
    unionTaskLevel = 0,
    unionTaskPoint = 0
}
MsgType.Response_Union_TaskList.__index = MsgType.Response_Union_TaskList

function MsgType.Response_Union_TaskList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_TaskList:GetCmd()
    return MsgTypeCmd.Response_Union_TaskList_Cmd
end
function MsgType.Response_Union_TaskList:GetUrl()
    return "Response_Union_TaskList"
end
function MsgType.Response_Union_TaskList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneUnionTaskData:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.unionTaskRefreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionTaskCancelCoolTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.unionTaskLevel = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.unionTaskPoint = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_Union_TaskResult = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Union_TaskResult.__index = MsgType.Request_Union_TaskResult

function MsgType.Request_Union_TaskResult:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_TaskResult:GetCmd()
    return MsgTypeCmd.Request_Union_TaskResult_Cmd
end
function MsgType.Request_Union_TaskResult:GetUrl()
    return "Request_Union_TaskResult"
end
function MsgType.Request_Union_TaskResult:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Union_TaskResult:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_TaskResult:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_TaskResult = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    showFlag = 0,
    unionTaskLevel = 0,
    userId = "",
    name = "",
    gender = 0,
    userPoint = 0,
    unionPoint = 0,
    userDress = {}
}
MsgType.Response_Union_TaskResult.__index = MsgType.Response_Union_TaskResult
setmetatable(MsgType.Response_Union_TaskResult.userDress, MsgType.RoleDress)

function MsgType.Response_Union_TaskResult:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.userDress = MsgType.RoleDress:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_TaskResult:GetCmd()
    return MsgTypeCmd.Response_Union_TaskResult_Cmd
end
function MsgType.Response_Union_TaskResult:GetUrl()
    return "Response_Union_TaskResult"
end
function MsgType.Response_Union_TaskResult:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.showFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.unionTaskLevel = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.userId = tostring(data.h)
    end
    if nil ~= data.i then
        self.name = tostring(data.i)
    end
    if nil ~= data.j then
        self.gender = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.userPoint = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.unionPoint = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.userDress:Decode(data.m)
    end
    return self
end


MsgType.Request_Union_KickOutMessage = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Union_KickOutMessage.__index = MsgType.Request_Union_KickOutMessage

function MsgType.Request_Union_KickOutMessage:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_KickOutMessage:GetCmd()
    return MsgTypeCmd.Request_Union_KickOutMessage_Cmd
end
function MsgType.Request_Union_KickOutMessage:GetUrl()
    return "Request_Union_KickOutMessage"
end
function MsgType.Request_Union_KickOutMessage:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Union_KickOutMessage:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_KickOutMessage:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_KickOutMessage = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    showFlag = 0
}
MsgType.Response_Union_KickOutMessage.__index = MsgType.Response_Union_KickOutMessage

function MsgType.Response_Union_KickOutMessage:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_KickOutMessage:GetCmd()
    return MsgTypeCmd.Response_Union_KickOutMessage_Cmd
end
function MsgType.Response_Union_KickOutMessage:GetUrl()
    return "Response_Union_KickOutMessage"
end
function MsgType.Response_Union_KickOutMessage:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.showFlag = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_Union_CheckUnionTask = {
    msgSeq = 0,
    taskUid = 0
}
MsgType.Request_Union_CheckUnionTask.__index = MsgType.Request_Union_CheckUnionTask

function MsgType.Request_Union_CheckUnionTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_CheckUnionTask:GetCmd()
    return MsgTypeCmd.Request_Union_CheckUnionTask_Cmd
end
function MsgType.Request_Union_CheckUnionTask:GetUrl()
    return "Request_Union_CheckUnionTask"
end
function MsgType.Request_Union_CheckUnionTask:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskUid and 0 ~= self.taskUid then
        tb.c = self.taskUid
    end
    return tb
end

function MsgType.Request_Union_CheckUnionTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_CheckUnionTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_CheckUnionTask = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskData = {},
    unionTaskRefreshTime = 0,
    unionTaskCancelCoolTime = 0,
    unionTaskLevel = 0,
    unionTaskPoint = 0
}
MsgType.Response_Union_CheckUnionTask.__index = MsgType.Response_Union_CheckUnionTask
setmetatable(MsgType.Response_Union_CheckUnionTask.taskData, MsgType.OneUnionTaskData)

function MsgType.Response_Union_CheckUnionTask:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskData = MsgType.OneUnionTaskData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_CheckUnionTask:GetCmd()
    return MsgTypeCmd.Response_Union_CheckUnionTask_Cmd
end
function MsgType.Response_Union_CheckUnionTask:GetUrl()
    return "Response_Union_CheckUnionTask"
end
function MsgType.Response_Union_CheckUnionTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.taskData:Decode(data.f)
    end
    if nil ~= data.g then
        self.unionTaskRefreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionTaskCancelCoolTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.unionTaskLevel = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.unionTaskPoint = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_Union_StartUnionTask = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_Union_StartUnionTask.__index = MsgType.Request_Union_StartUnionTask

function MsgType.Request_Union_StartUnionTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_StartUnionTask:GetCmd()
    return MsgTypeCmd.Request_Union_StartUnionTask_Cmd
end
function MsgType.Request_Union_StartUnionTask:GetUrl()
    return "Request_Union_StartUnionTask"
end
function MsgType.Request_Union_StartUnionTask:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_Union_StartUnionTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_StartUnionTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_StartUnionTask = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskData = {},
    unionTaskRefreshTime = 0,
    unionTaskCancelCoolTime = 0,
    unionTaskLevel = 0,
    unionTaskPoint = 0
}
MsgType.Response_Union_StartUnionTask.__index = MsgType.Response_Union_StartUnionTask
setmetatable(MsgType.Response_Union_StartUnionTask.taskData, MsgType.OneUnionTaskData)

function MsgType.Response_Union_StartUnionTask:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskData = MsgType.OneUnionTaskData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_StartUnionTask:GetCmd()
    return MsgTypeCmd.Response_Union_StartUnionTask_Cmd
end
function MsgType.Response_Union_StartUnionTask:GetUrl()
    return "Response_Union_StartUnionTask"
end
function MsgType.Response_Union_StartUnionTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.taskData:Decode(data.f)
    end
    if nil ~= data.g then
        self.unionTaskRefreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionTaskCancelCoolTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.unionTaskLevel = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.unionTaskPoint = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_Union_CancelUnionTask = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_Union_CancelUnionTask.__index = MsgType.Request_Union_CancelUnionTask

function MsgType.Request_Union_CancelUnionTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_CancelUnionTask:GetCmd()
    return MsgTypeCmd.Request_Union_CancelUnionTask_Cmd
end
function MsgType.Request_Union_CancelUnionTask:GetUrl()
    return "Request_Union_CancelUnionTask"
end
function MsgType.Request_Union_CancelUnionTask:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_Union_CancelUnionTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_CancelUnionTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_CancelUnionTask = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneUnionTaskData
    unionTaskRefreshTime = 0,
    unionTaskCancelCoolTime = 0,
    unionTaskLevel = 0,
    unionTaskPoint = 0
}
MsgType.Response_Union_CancelUnionTask.__index = MsgType.Response_Union_CancelUnionTask

function MsgType.Response_Union_CancelUnionTask:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_CancelUnionTask:GetCmd()
    return MsgTypeCmd.Response_Union_CancelUnionTask_Cmd
end
function MsgType.Response_Union_CancelUnionTask:GetUrl()
    return "Response_Union_CancelUnionTask"
end
function MsgType.Response_Union_CancelUnionTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneUnionTaskData:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.unionTaskRefreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionTaskCancelCoolTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.unionTaskLevel = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.unionTaskPoint = tonumber(data.j) or 0
    end
    return self
end


MsgType.Response_Union_UnionTaskChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneUnionTaskData
    unionTaskRefreshTime = 0,
    unionTaskCancelCoolTime = 0,
    unionTaskLevel = 0,
    unionTaskPoint = 0
}
MsgType.Response_Union_UnionTaskChange.__index = MsgType.Response_Union_UnionTaskChange

function MsgType.Response_Union_UnionTaskChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_UnionTaskChange:GetCmd()
    return MsgTypeCmd.Response_Union_UnionTaskChange_Cmd
end
function MsgType.Response_Union_UnionTaskChange:GetUrl()
    return "Response_Union_UnionTaskChange"
end
function MsgType.Response_Union_UnionTaskChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneUnionTaskData:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.unionTaskRefreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionTaskCancelCoolTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.unionTaskLevel = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.unionTaskPoint = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_Union_RewardUnionTask = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_Union_RewardUnionTask.__index = MsgType.Request_Union_RewardUnionTask

function MsgType.Request_Union_RewardUnionTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_RewardUnionTask:GetCmd()
    return MsgTypeCmd.Request_Union_RewardUnionTask_Cmd
end
function MsgType.Request_Union_RewardUnionTask:GetUrl()
    return "Request_Union_RewardUnionTask"
end
function MsgType.Request_Union_RewardUnionTask:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_Union_RewardUnionTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_RewardUnionTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_RewardUnionTask = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneUnionTaskData
    unionTaskRefreshTime = 0,
    unionTaskCancelCoolTime = 0,
    rewardList = {}, -- array of MsgType.OneRewardItem
    unionTaskLevel = 0,
    unionTaskPoint = 0
}
MsgType.Response_Union_RewardUnionTask.__index = MsgType.Response_Union_RewardUnionTask

function MsgType.Response_Union_RewardUnionTask:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_RewardUnionTask:GetCmd()
    return MsgTypeCmd.Response_Union_RewardUnionTask_Cmd
end
function MsgType.Response_Union_RewardUnionTask:GetUrl()
    return "Response_Union_RewardUnionTask"
end
function MsgType.Response_Union_RewardUnionTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneUnionTaskData:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.unionTaskRefreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionTaskCancelCoolTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        self.unionTaskLevel = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.unionTaskPoint = tonumber(data.k) or 0
    end
    return self
end


MsgType.Request_Union_AccelUnionTask = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_Union_AccelUnionTask.__index = MsgType.Request_Union_AccelUnionTask

function MsgType.Request_Union_AccelUnionTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_AccelUnionTask:GetCmd()
    return MsgTypeCmd.Request_Union_AccelUnionTask_Cmd
end
function MsgType.Request_Union_AccelUnionTask:GetUrl()
    return "Request_Union_AccelUnionTask"
end
function MsgType.Request_Union_AccelUnionTask:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_Union_AccelUnionTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_AccelUnionTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_AccelUnionTask = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {}, -- array of MsgType.OneUnionTaskData
    unionTaskRefreshTime = 0,
    unionTaskCancelCoolTime = 0,
    rewardList = {}, -- array of MsgType.OneRewardItem
    unionTaskLevel = 0,
    unionTaskPoint = 0
}
MsgType.Response_Union_AccelUnionTask.__index = MsgType.Response_Union_AccelUnionTask

function MsgType.Response_Union_AccelUnionTask:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_AccelUnionTask:GetCmd()
    return MsgTypeCmd.Response_Union_AccelUnionTask_Cmd
end
function MsgType.Response_Union_AccelUnionTask:GetUrl()
    return "Response_Union_AccelUnionTask"
end
function MsgType.Response_Union_AccelUnionTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OneUnionTaskData:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.g then
        self.unionTaskRefreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionTaskCancelCoolTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        self.unionTaskLevel = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.unionTaskPoint = tonumber(data.k) or 0
    end
    return self
end


MsgType.OneUnionRankData = {
    userId = "",
    name = "",
    gender = 0,
    userDress = {},
    point = 0
}
MsgType.OneUnionRankData.__index = MsgType.OneUnionRankData
setmetatable(MsgType.OneUnionRankData.userDress, MsgType.RoleDress)

function MsgType.OneUnionRankData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.userDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.OneUnionRankData:Encode()
    local tb = {}
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.b = self.userId
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.c = self.name
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.d = self.gender
    end
    tb.e = self.userDress:Encode()
    if nil ~= self.point and 0 ~= self.point then
        tb.f = self.point
    end
    return tb
end

function MsgType.OneUnionRankData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.userId = tostring(data.b)
    end
    if nil ~= data.c then
        self.name = tostring(data.c)
    end
    if nil ~= data.d then
        self.gender = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.userDress:Decode(data.e)
    end
    if nil ~= data.f then
        self.point = tonumber(data.f) or 0
    end
    return self
end

function MsgType.OneUnionRankData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneUnionRankData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Union_UnionTaskRankList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Union_UnionTaskRankList.__index = MsgType.Request_Union_UnionTaskRankList

function MsgType.Request_Union_UnionTaskRankList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_UnionTaskRankList:GetCmd()
    return MsgTypeCmd.Request_Union_UnionTaskRankList_Cmd
end
function MsgType.Request_Union_UnionTaskRankList:GetUrl()
    return "Request_Union_UnionTaskRankList"
end
function MsgType.Request_Union_UnionTaskRankList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Union_UnionTaskRankList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_UnionTaskRankList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_UnionTaskRankList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rankList = {} -- array of MsgType.OneUnionRankData
}
MsgType.Response_Union_UnionTaskRankList.__index = MsgType.Response_Union_UnionTaskRankList

function MsgType.Response_Union_UnionTaskRankList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rankList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_UnionTaskRankList:GetCmd()
    return MsgTypeCmd.Response_Union_UnionTaskRankList_Cmd
end
function MsgType.Response_Union_UnionTaskRankList:GetUrl()
    return "Response_Union_UnionTaskRankList"
end
function MsgType.Response_Union_UnionTaskRankList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRankListObj = MsgType.OneUnionRankData:New()
            tmpRankListObj:Decode(data.f[i])
            self.rankList[i] = tmpRankListObj
        end
    end
    return self
end


MsgType.EUnionScienceType = {
    UnionTaskLimit = 1,
    ResItem1Limit = 3,
    ResItem2Limit = 4,
    ResItem3Limit = 5,
    Shelf1Limit = 6,
    Shelf2Limit = 7,
    Shelf3Limit = 8,
    Shelf4Limit = 9,
    StoreBoxLimit = 10,
    PileLimit = 11,
    AccelSkill = 12,
    ExploreSkill = 13,
    ExpSkill = 14,
    ResSkill = 15,
    MarketBuyLimit = 16,
    MarketSoldLimit = 17,
    ResItem1Rate = 18,
    ResItem2Rate = 19,
    ResItem3Rate = 20,
    UnionLevelUp = 21
}

MsgType.EUnionScienceSkillType = {
    Type1 = 1,
    Type2 = 2
}

MsgType.EUnionScienceState = {
    Lock = 0,
    Unlock = 1
}

MsgType.EUnionScienceSkillState = {
    Lock = 0,
    Unlock = 1
}

MsgType.OneUnionScienceData = {
    level = 0,
    type = 0 --enum EUnionScienceType
}
MsgType.OneUnionScienceData.__index = MsgType.OneUnionScienceData

function MsgType.OneUnionScienceData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneUnionScienceData:Encode()
    local tb = {}
    if nil ~= self.level and 0 ~= self.level then
        tb.b = self.level
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    return tb
end

function MsgType.OneUnionScienceData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.level = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.type = tonumber(data.c) or 0
    end
    return self
end

function MsgType.OneUnionScienceData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneUnionScienceData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Union_ScienceList = {
    msgSeq = 0,
    scienceList = {} -- array of MsgType.OneUnionScienceData
}
MsgType.Request_Union_ScienceList.__index = MsgType.Request_Union_ScienceList

function MsgType.Request_Union_ScienceList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.scienceList = {}
    return tb
end

function MsgType.Request_Union_ScienceList:GetCmd()
    return MsgTypeCmd.Request_Union_ScienceList_Cmd
end
function MsgType.Request_Union_ScienceList:GetUrl()
    return "Request_Union_ScienceList"
end
function MsgType.Request_Union_ScienceList:_scienceListEncode()
    local tb = {}
    for i=1, #self.scienceList do
        tb[i] = self.scienceList[i]:Encode()
    end
    return tb
end
function MsgType.Request_Union_ScienceList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    tb.c = self:_scienceListEncode()
    return tb
end

function MsgType.Request_Union_ScienceList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_ScienceList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_ScienceList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    scienceList = {}, -- array of MsgType.OneUnionScienceData
    unionPoint = 0
}
MsgType.Response_Union_ScienceList.__index = MsgType.Response_Union_ScienceList

function MsgType.Response_Union_ScienceList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.scienceList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_ScienceList:GetCmd()
    return MsgTypeCmd.Response_Union_ScienceList_Cmd
end
function MsgType.Response_Union_ScienceList:GetUrl()
    return "Response_Union_ScienceList"
end
function MsgType.Response_Union_ScienceList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpScienceListObj = MsgType.OneUnionScienceData:New()
            tmpScienceListObj:Decode(data.f[i])
            self.scienceList[i] = tmpScienceListObj
        end
    end
    if nil ~= data.g then
        self.unionPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Union_ScienceUpgrade = {
    msgSeq = 0,
    type = 0
}
MsgType.Request_Union_ScienceUpgrade.__index = MsgType.Request_Union_ScienceUpgrade

function MsgType.Request_Union_ScienceUpgrade:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_ScienceUpgrade:GetCmd()
    return MsgTypeCmd.Request_Union_ScienceUpgrade_Cmd
end
function MsgType.Request_Union_ScienceUpgrade:GetUrl()
    return "Request_Union_ScienceUpgrade"
end
function MsgType.Request_Union_ScienceUpgrade:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    return tb
end

function MsgType.Request_Union_ScienceUpgrade:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_ScienceUpgrade:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_ScienceUpgrade = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    scienceList = {}, -- array of MsgType.OneUnionScienceData
    unionPoint = 0
}
MsgType.Response_Union_ScienceUpgrade.__index = MsgType.Response_Union_ScienceUpgrade

function MsgType.Response_Union_ScienceUpgrade:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.scienceList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_ScienceUpgrade:GetCmd()
    return MsgTypeCmd.Response_Union_ScienceUpgrade_Cmd
end
function MsgType.Response_Union_ScienceUpgrade:GetUrl()
    return "Response_Union_ScienceUpgrade"
end
function MsgType.Response_Union_ScienceUpgrade:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpScienceListObj = MsgType.OneUnionScienceData:New()
            tmpScienceListObj:Decode(data.f[i])
            self.scienceList[i] = tmpScienceListObj
        end
    end
    if nil ~= data.g then
        self.unionPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.OneUnionScienceSkillData = {
    level = 0,
    type = 0, --enum EUnionScienceType
    skillType = 0, --enum EUnionScienceSkillType
    time = 0
}
MsgType.OneUnionScienceSkillData.__index = MsgType.OneUnionScienceSkillData

function MsgType.OneUnionScienceSkillData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneUnionScienceSkillData:Encode()
    local tb = {}
    if nil ~= self.level and 0 ~= self.level then
        tb.b = self.level
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    if nil ~= self.skillType and 0 ~= self.skillType then
        tb.d = self.skillType
    end
    if nil ~= self.time and 0 ~= self.time then
        tb.e = self.time
    end
    return tb
end

function MsgType.OneUnionScienceSkillData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.level = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.type = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.skillType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.time = tonumber(data.e) or 0
    end
    return self
end

function MsgType.OneUnionScienceSkillData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneUnionScienceSkillData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Union_ScienceSkillList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Union_ScienceSkillList.__index = MsgType.Request_Union_ScienceSkillList

function MsgType.Request_Union_ScienceSkillList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_ScienceSkillList:GetCmd()
    return MsgTypeCmd.Request_Union_ScienceSkillList_Cmd
end
function MsgType.Request_Union_ScienceSkillList:GetUrl()
    return "Request_Union_ScienceSkillList"
end
function MsgType.Request_Union_ScienceSkillList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Union_ScienceSkillList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_ScienceSkillList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_ScienceSkillList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    skillList = {}, -- array of MsgType.OneUnionScienceSkillData
    unionPoint = 0
}
MsgType.Response_Union_ScienceSkillList.__index = MsgType.Response_Union_ScienceSkillList

function MsgType.Response_Union_ScienceSkillList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.skillList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_ScienceSkillList:GetCmd()
    return MsgTypeCmd.Response_Union_ScienceSkillList_Cmd
end
function MsgType.Response_Union_ScienceSkillList:GetUrl()
    return "Response_Union_ScienceSkillList"
end
function MsgType.Response_Union_ScienceSkillList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpSkillListObj = MsgType.OneUnionScienceSkillData:New()
            tmpSkillListObj:Decode(data.f[i])
            self.skillList[i] = tmpSkillListObj
        end
    end
    if nil ~= data.g then
        self.unionPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Union_ScienceSkillUse = {
    msgSeq = 0,
    type = 0
}
MsgType.Request_Union_ScienceSkillUse.__index = MsgType.Request_Union_ScienceSkillUse

function MsgType.Request_Union_ScienceSkillUse:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_ScienceSkillUse:GetCmd()
    return MsgTypeCmd.Request_Union_ScienceSkillUse_Cmd
end
function MsgType.Request_Union_ScienceSkillUse:GetUrl()
    return "Request_Union_ScienceSkillUse"
end
function MsgType.Request_Union_ScienceSkillUse:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    return tb
end

function MsgType.Request_Union_ScienceSkillUse:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_ScienceSkillUse:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_ScienceSkillUse = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    skill = {},
    unionPoint = 0
}
MsgType.Response_Union_ScienceSkillUse.__index = MsgType.Response_Union_ScienceSkillUse
setmetatable(MsgType.Response_Union_ScienceSkillUse.skill, MsgType.OneUnionScienceSkillData)

function MsgType.Response_Union_ScienceSkillUse:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.skill = MsgType.OneUnionScienceSkillData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_ScienceSkillUse:GetCmd()
    return MsgTypeCmd.Response_Union_ScienceSkillUse_Cmd
end
function MsgType.Response_Union_ScienceSkillUse:GetUrl()
    return "Response_Union_ScienceSkillUse"
end
function MsgType.Response_Union_ScienceSkillUse:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.skill:Decode(data.f)
    end
    if nil ~= data.g then
        self.unionPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Union_ScienceSkillRefresh = {
    msgSeq = 0,
    type = 0
}
MsgType.Request_Union_ScienceSkillRefresh.__index = MsgType.Request_Union_ScienceSkillRefresh

function MsgType.Request_Union_ScienceSkillRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_ScienceSkillRefresh:GetCmd()
    return MsgTypeCmd.Request_Union_ScienceSkillRefresh_Cmd
end
function MsgType.Request_Union_ScienceSkillRefresh:GetUrl()
    return "Request_Union_ScienceSkillRefresh"
end
function MsgType.Request_Union_ScienceSkillRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    return tb
end

function MsgType.Request_Union_ScienceSkillRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_ScienceSkillRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_ScienceSkillRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    skill = {},
    unionPoint = 0
}
MsgType.Response_Union_ScienceSkillRefresh.__index = MsgType.Response_Union_ScienceSkillRefresh
setmetatable(MsgType.Response_Union_ScienceSkillRefresh.skill, MsgType.OneUnionScienceSkillData)

function MsgType.Response_Union_ScienceSkillRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.skill = MsgType.OneUnionScienceSkillData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_ScienceSkillRefresh:GetCmd()
    return MsgTypeCmd.Response_Union_ScienceSkillRefresh_Cmd
end
function MsgType.Response_Union_ScienceSkillRefresh:GetUrl()
    return "Response_Union_ScienceSkillRefresh"
end
function MsgType.Response_Union_ScienceSkillRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.skill:Decode(data.f)
    end
    if nil ~= data.g then
        self.unionPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Union_Impeach = {
    msgSeq = 0,
    userId = ""
}
MsgType.Request_Union_Impeach.__index = MsgType.Request_Union_Impeach

function MsgType.Request_Union_Impeach:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Union_Impeach:GetCmd()
    return MsgTypeCmd.Request_Union_Impeach_Cmd
end
function MsgType.Request_Union_Impeach:GetUrl()
    return "Request_Union_Impeach"
end
function MsgType.Request_Union_Impeach:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.c = self.userId
    end
    return tb
end

function MsgType.Request_Union_Impeach:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Union_Impeach:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Union_Impeach = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userId = "",
    unionDetailData = {}
}
MsgType.Response_Union_Impeach.__index = MsgType.Response_Union_Impeach
setmetatable(MsgType.Response_Union_Impeach.unionDetailData, MsgType.UnionDetailData)

function MsgType.Response_Union_Impeach:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.unionDetailData = MsgType.UnionDetailData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Union_Impeach:GetCmd()
    return MsgTypeCmd.Response_Union_Impeach_Cmd
end
function MsgType.Response_Union_Impeach:GetUrl()
    return "Response_Union_Impeach"
end
function MsgType.Response_Union_Impeach:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userId = tostring(data.f)
    end
    if nil ~= data.g then
        self.unionDetailData:Decode(data.g)
    end
    return self
end


MsgType.BoothItemData = {
    boothFileId = 0,
    itemType = 0,
    itemId = 0,
    itemQuality = 0,
    remainNum = 0,
    marketType = 0,
    moneyType = 0,
    exchangeNum = 0,
    timeIndex = 0,
    remainTime = 0,
    unitPrice = 0
}
MsgType.BoothItemData.__index = MsgType.BoothItemData

function MsgType.BoothItemData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BoothItemData:Encode()
    local tb = {}
    if nil ~= self.boothFileId and 0 ~= self.boothFileId then
        tb.b = self.boothFileId
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.c = self.itemType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.d = self.itemId
    end
    if nil ~= self.itemQuality and 0 ~= self.itemQuality then
        tb.e = self.itemQuality
    end
    if nil ~= self.remainNum and 0 ~= self.remainNum then
        tb.f = self.remainNum
    end
    if nil ~= self.marketType and 0 ~= self.marketType then
        tb.g = self.marketType
    end
    if nil ~= self.moneyType and 0 ~= self.moneyType then
        tb.h = self.moneyType
    end
    if nil ~= self.exchangeNum and 0 ~= self.exchangeNum then
        tb.i = self.exchangeNum
    end
    if nil ~= self.timeIndex and 0 ~= self.timeIndex then
        tb.j = self.timeIndex
    end
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.k = self.remainTime
    end
    if nil ~= self.unitPrice and 0 ~= self.unitPrice then
        tb.l = self.unitPrice
    end
    return tb
end

function MsgType.BoothItemData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.boothFileId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.itemQuality = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.remainNum = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.marketType = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.moneyType = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.exchangeNum = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.timeIndex = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.remainTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.unitPrice = tonumber(data.l) or 0
    end
    return self
end

function MsgType.BoothItemData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.BoothItemData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.SellOneItem = {
    putAwayTime = 0,
    itemType = 0,
    itemId = 0,
    itemQuality = 0,
    marketNum = 0,
    goldPrice = 0,
    gemPrice = 0
}
MsgType.SellOneItem.__index = MsgType.SellOneItem

function MsgType.SellOneItem:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.SellOneItem:Encode()
    local tb = {}
    if nil ~= self.putAwayTime and 0 ~= self.putAwayTime then
        tb.b = self.putAwayTime
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.c = self.itemType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.d = self.itemId
    end
    if nil ~= self.itemQuality and 0 ~= self.itemQuality then
        tb.e = self.itemQuality
    end
    if nil ~= self.marketNum and 0 ~= self.marketNum then
        tb.f = self.marketNum
    end
    if nil ~= self.goldPrice and 0 ~= self.goldPrice then
        tb.g = self.goldPrice
    end
    if nil ~= self.gemPrice and 0 ~= self.gemPrice then
        tb.h = self.gemPrice
    end
    return tb
end

function MsgType.SellOneItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.putAwayTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.itemQuality = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.marketNum = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.goldPrice = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.gemPrice = tonumber(data.h) or 0
    end
    return self
end

function MsgType.SellOneItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.SellOneItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.ListedItems = {
    itemType = 0,
    itemId = 0,
    itemQuality = 0,
    itemNum = 0,
    buyOrSell = 0,
    moneyType = 0,
    unitPrice = 0,
    timeIndex = 0
}
MsgType.ListedItems.__index = MsgType.ListedItems

function MsgType.ListedItems:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ListedItems:Encode()
    local tb = {}
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.b = self.itemType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    if nil ~= self.itemQuality and 0 ~= self.itemQuality then
        tb.d = self.itemQuality
    end
    if nil ~= self.itemNum and 0 ~= self.itemNum then
        tb.e = self.itemNum
    end
    if nil ~= self.buyOrSell and 0 ~= self.buyOrSell then
        tb.f = self.buyOrSell
    end
    if nil ~= self.moneyType and 0 ~= self.moneyType then
        tb.g = self.moneyType
    end
    if nil ~= self.unitPrice and 0 ~= self.unitPrice then
        tb.h = self.unitPrice
    end
    if nil ~= self.timeIndex and 0 ~= self.timeIndex then
        tb.i = self.timeIndex
    end
    return tb
end

function MsgType.ListedItems:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.itemType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemQuality = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.itemNum = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.buyOrSell = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.moneyType = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unitPrice = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.timeIndex = tonumber(data.i) or 0
    end
    return self
end

function MsgType.ListedItems:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ListedItems:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Market_ListedItems = {
    msgSeq = 0,
    listedItems = {}
}
MsgType.Request_Market_ListedItems.__index = MsgType.Request_Market_ListedItems
setmetatable(MsgType.Request_Market_ListedItems.listedItems, MsgType.ListedItems)

function MsgType.Request_Market_ListedItems:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.listedItems = MsgType.ListedItems:New()
    return tb
end

function MsgType.Request_Market_ListedItems:GetCmd()
    return MsgTypeCmd.Request_Market_ListedItems_Cmd
end
function MsgType.Request_Market_ListedItems:GetUrl()
    return "Request_Market_ListedItems"
end
function MsgType.Request_Market_ListedItems:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    tb.c = self.listedItems:Encode()
    return tb
end

function MsgType.Request_Market_ListedItems:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_ListedItems:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Market_DealWith = {
    msgSeq = 0,
    dealLocation = 0
}
MsgType.Request_Market_DealWith.__index = MsgType.Request_Market_DealWith

function MsgType.Request_Market_DealWith:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Market_DealWith:GetCmd()
    return MsgTypeCmd.Request_Market_DealWith_Cmd
end
function MsgType.Request_Market_DealWith:GetUrl()
    return "Request_Market_DealWith"
end
function MsgType.Request_Market_DealWith:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.dealLocation and 0 ~= self.dealLocation then
        tb.c = self.dealLocation
    end
    return tb
end

function MsgType.Request_Market_DealWith:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_DealWith:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Market_OffShelf = {
    msgSeq = 0,
    offShelf = 0
}
MsgType.Request_Market_OffShelf.__index = MsgType.Request_Market_OffShelf

function MsgType.Request_Market_OffShelf:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Market_OffShelf:GetCmd()
    return MsgTypeCmd.Request_Market_OffShelf_Cmd
end
function MsgType.Request_Market_OffShelf:GetUrl()
    return "Request_Market_OffShelf"
end
function MsgType.Request_Market_OffShelf:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.offShelf and 0 ~= self.offShelf then
        tb.c = self.offShelf
    end
    return tb
end

function MsgType.Request_Market_OffShelf:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_OffShelf:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Market_OneItemList = {
    msgSeq = 0,
    buyOrSell = 0,
    itemType = 0,
    subTypesList = {}, -- array of number
    levelsList = {}, -- array of number
    qualityList = {}, -- array of number
    findAllItem = 0
}
MsgType.Request_Market_OneItemList.__index = MsgType.Request_Market_OneItemList

function MsgType.Request_Market_OneItemList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.subTypesList = {}
    tb.levelsList = {}
    tb.qualityList = {}
    return tb
end

function MsgType.Request_Market_OneItemList:GetCmd()
    return MsgTypeCmd.Request_Market_OneItemList_Cmd
end
function MsgType.Request_Market_OneItemList:GetUrl()
    return "Request_Market_OneItemList"
end
function MsgType.Request_Market_OneItemList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buyOrSell and 0 ~= self.buyOrSell then
        tb.c = self.buyOrSell
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.d = self.itemType
    end
    if nil ~= self.subTypesList and #self.subTypesList > 0 then
        for i=1, #self.subTypesList do
            tb.e[i] = tonumber(self.subTypesList[i])
        end
    end
    if nil ~= self.levelsList and #self.levelsList > 0 then
        for i=1, #self.levelsList do
            tb.e[i] = tonumber(self.levelsList[i])
        end
    end
    if nil ~= self.qualityList and #self.qualityList > 0 then
        for i=1, #self.qualityList do
            tb.e[i] = tonumber(self.qualityList[i])
        end
    end
    if nil ~= self.findAllItem and 0 ~= self.findAllItem then
        tb.h = self.findAllItem
    end
    return tb
end

function MsgType.Request_Market_OneItemList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_OneItemList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Market_OneItemList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    buyOrSell = 0,
    itemType = 0,
    itemSort = {}, -- array of number
    sellOneItemList = {}, -- array of MsgType.SellOneItem
    findAllItem = 0
}
MsgType.Response_Market_OneItemList.__index = MsgType.Response_Market_OneItemList

function MsgType.Response_Market_OneItemList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.itemSort = {}
    tb.sellOneItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Market_OneItemList:GetCmd()
    return MsgTypeCmd.Response_Market_OneItemList_Cmd
end
function MsgType.Response_Market_OneItemList:GetUrl()
    return "Response_Market_OneItemList"
end
function MsgType.Response_Market_OneItemList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.buyOrSell = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.itemType = tonumber(data.g) or 0
    end
    if nil ~= data.h and #data.h > 0 then
        for i=1, #data.h do
            self.itemSort[i] = tonumber(data.h[i])
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpSellOneItemListObj = MsgType.SellOneItem:New()
            tmpSellOneItemListObj:Decode(data.i[i])
            self.sellOneItemList[i] = tmpSellOneItemListObj
        end
    end
    if nil ~= data.j then
        self.findAllItem = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_Market_OneItemRef = {
    msgSeq = 0,
    buyOrSell = 0,
    itemType = 0,
    itemId = 0,
    itemQuality = 0
}
MsgType.Request_Market_OneItemRef.__index = MsgType.Request_Market_OneItemRef

function MsgType.Request_Market_OneItemRef:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Market_OneItemRef:GetCmd()
    return MsgTypeCmd.Request_Market_OneItemRef_Cmd
end
function MsgType.Request_Market_OneItemRef:GetUrl()
    return "Request_Market_OneItemRef"
end
function MsgType.Request_Market_OneItemRef:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buyOrSell and 0 ~= self.buyOrSell then
        tb.c = self.buyOrSell
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.d = self.itemType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.e = self.itemId
    end
    if nil ~= self.itemQuality and 0 ~= self.itemQuality then
        tb.f = self.itemQuality
    end
    return tb
end

function MsgType.Request_Market_OneItemRef:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_OneItemRef:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Market_OneItemRef = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    buyOrSell = 0,
    sellOneItem = {}
}
MsgType.Response_Market_OneItemRef.__index = MsgType.Response_Market_OneItemRef
setmetatable(MsgType.Response_Market_OneItemRef.sellOneItem, MsgType.SellOneItem)

function MsgType.Response_Market_OneItemRef:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.sellOneItem = MsgType.SellOneItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Market_OneItemRef:GetCmd()
    return MsgTypeCmd.Response_Market_OneItemRef_Cmd
end
function MsgType.Response_Market_OneItemRef:GetUrl()
    return "Response_Market_OneItemRef"
end
function MsgType.Response_Market_OneItemRef:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.buyOrSell = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.sellOneItem:Decode(data.g)
    end
    return self
end


MsgType.Request_Market_BuyOrSellOne = {
    msgSeq = 0,
    buyOrSell = 0,
    itemType = 0,
    itemId = 0,
    itemQuality = 0,
    moneyType = 0,
    costMoney = 0,
    payload = ""
}
MsgType.Request_Market_BuyOrSellOne.__index = MsgType.Request_Market_BuyOrSellOne

function MsgType.Request_Market_BuyOrSellOne:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Market_BuyOrSellOne:GetCmd()
    return MsgTypeCmd.Request_Market_BuyOrSellOne_Cmd
end
function MsgType.Request_Market_BuyOrSellOne:GetUrl()
    return "Request_Market_BuyOrSellOne"
end
function MsgType.Request_Market_BuyOrSellOne:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buyOrSell and 0 ~= self.buyOrSell then
        tb.c = self.buyOrSell
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.d = self.itemType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.e = self.itemId
    end
    if nil ~= self.itemQuality and 0 ~= self.itemQuality then
        tb.f = self.itemQuality
    end
    if nil ~= self.moneyType and 0 ~= self.moneyType then
        tb.g = self.moneyType
    end
    if nil ~= self.costMoney and 0 ~= self.costMoney then
        tb.h = self.costMoney
    end
    if nil ~= self.payload and string.len(self.payload) > 0 then
        tb.i = self.payload
    end
    return tb
end

function MsgType.Request_Market_BuyOrSellOne:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_BuyOrSellOne:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Market_BuyOrSellOne = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    yesOrNo = 0,
    comeWhere = 0,
    reason = 0,
    sellOneItem = {},
    payload = ""
}
MsgType.Response_Market_BuyOrSellOne.__index = MsgType.Response_Market_BuyOrSellOne
setmetatable(MsgType.Response_Market_BuyOrSellOne.sellOneItem, MsgType.SellOneItem)

function MsgType.Response_Market_BuyOrSellOne:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.sellOneItem = MsgType.SellOneItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Market_BuyOrSellOne:GetCmd()
    return MsgTypeCmd.Response_Market_BuyOrSellOne_Cmd
end
function MsgType.Response_Market_BuyOrSellOne:GetUrl()
    return "Response_Market_BuyOrSellOne"
end
function MsgType.Response_Market_BuyOrSellOne:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.yesOrNo = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.comeWhere = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.reason = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.sellOneItem:Decode(data.i)
    end
    if nil ~= data.j then
        self.payload = tostring(data.j)
    end
    return self
end


MsgType.Request_Market_BoothCount = {
    msgSeq = 0,
    money = 0,
    slot = 0
}
MsgType.Request_Market_BoothCount.__index = MsgType.Request_Market_BoothCount

function MsgType.Request_Market_BoothCount:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Market_BoothCount:GetCmd()
    return MsgTypeCmd.Request_Market_BoothCount_Cmd
end
function MsgType.Request_Market_BoothCount:GetUrl()
    return "Request_Market_BoothCount"
end
function MsgType.Request_Market_BoothCount:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.money and 0 ~= self.money then
        tb.c = self.money
    end
    if nil ~= self.slot and 0 ~= self.slot then
        tb.d = self.slot
    end
    return tb
end

function MsgType.Request_Market_BoothCount:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_BoothCount:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Market_BoothCount = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    Count = 0
}
MsgType.Response_Market_BoothCount.__index = MsgType.Response_Market_BoothCount

function MsgType.Response_Market_BoothCount:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Market_BoothCount:GetCmd()
    return MsgTypeCmd.Response_Market_BoothCount_Cmd
end
function MsgType.Response_Market_BoothCount:GetUrl()
    return "Response_Market_BoothCount"
end
function MsgType.Response_Market_BoothCount:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.Count = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_Market_BoothData = {
    msgSeq = 0,
}
MsgType.Request_Market_BoothData.__index = MsgType.Request_Market_BoothData

function MsgType.Request_Market_BoothData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Market_BoothData:GetCmd()
    return MsgTypeCmd.Request_Market_BoothData_Cmd
end
function MsgType.Request_Market_BoothData:GetUrl()
    return "Request_Market_BoothData"
end
function MsgType.Request_Market_BoothData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.Request_Market_BoothData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_BoothData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Market_BoothData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    Count = 0,
    saleList = {} -- array of MsgType.BoothItemData
}
MsgType.Response_Market_BoothData.__index = MsgType.Response_Market_BoothData

function MsgType.Response_Market_BoothData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.saleList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Market_BoothData:GetCmd()
    return MsgTypeCmd.Response_Market_BoothData_Cmd
end
function MsgType.Response_Market_BoothData:GetUrl()
    return "Response_Market_BoothData"
end
function MsgType.Response_Market_BoothData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.Count = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpSaleListObj = MsgType.BoothItemData:New()
            tmpSaleListObj:Decode(data.g[i])
            self.saleList[i] = tmpSaleListObj
        end
    end
    return self
end


MsgType.Request_Market_UpdatePut = {
    msgSeq = 0,
    boothFileId = 0
}
MsgType.Request_Market_UpdatePut.__index = MsgType.Request_Market_UpdatePut

function MsgType.Request_Market_UpdatePut:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Market_UpdatePut:GetCmd()
    return MsgTypeCmd.Request_Market_UpdatePut_Cmd
end
function MsgType.Request_Market_UpdatePut:GetUrl()
    return "Request_Market_UpdatePut"
end
function MsgType.Request_Market_UpdatePut:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.boothFileId and 0 ~= self.boothFileId then
        tb.c = self.boothFileId
    end
    return tb
end

function MsgType.Request_Market_UpdatePut:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Market_UpdatePut:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.JackpotDataState = {
    NotBeenGet = 0,
    BeenGet = 1
}

MsgType.PrizePoolStatus = {
    hasBeenReset = 0,
    hasNotBeenReset = 1
}

MsgType.EPrizePoolState = {
    hasBeenReset = 0,
    hasNotBeenReset = 1
}

MsgType.EPrizeRefreshType = {
    NotOnce = 1,
    OnlyOnce = 2
}

MsgType.JackpotData = {
    id = 0,
    prizeId = 0,
    prizeCount = 0,
    type = 0,
    rarity = 0,
    name = "",
    prizeState = 0, --enum JackpotDataState
    boxNum = 0
}
MsgType.JackpotData.__index = MsgType.JackpotData

function MsgType.JackpotData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.JackpotData:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.prizeId and 0 ~= self.prizeId then
        tb.c = self.prizeId
    end
    if nil ~= self.prizeCount and 0 ~= self.prizeCount then
        tb.d = self.prizeCount
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.e = self.type
    end
    if nil ~= self.rarity and 0 ~= self.rarity then
        tb.f = self.rarity
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.g = self.name
    end
    if nil ~= self.prizeState and 0 ~= self.prizeState then
        tb.h = self.prizeState
    end
    if nil ~= self.boxNum and 0 ~= self.boxNum then
        tb.i = self.boxNum
    end
    return tb
end

function MsgType.JackpotData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.prizeId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.prizeCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.type = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rarity = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.name = tostring(data.g)
    end
    if nil ~= data.h then
        self.prizeState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.boxNum = tonumber(data.i) or 0
    end
    return self
end

function MsgType.JackpotData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.JackpotData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.GrandTotal = {
    id = 0,
    rewardGroup = 0,
    rewardSequence = 0,
    cumulativeTimes = 0,
    rewardType1 = 0,
    rewardName1 = "",
    rewardItemId1 = 0,
    rewardItemNum1 = 0,
    rewardType2 = 0,
    rewardName2 = "",
    rewardItemId2 = 0,
    rewardItemNum2 = 0,
    rewardType3 = 0,
    rewardName3 = "",
    rewardItemId3 = 0,
    rewardItemNum3 = 0
}
MsgType.GrandTotal.__index = MsgType.GrandTotal

function MsgType.GrandTotal:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.GrandTotal:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.rewardGroup and 0 ~= self.rewardGroup then
        tb.c = self.rewardGroup
    end
    if nil ~= self.rewardSequence and 0 ~= self.rewardSequence then
        tb.d = self.rewardSequence
    end
    if nil ~= self.cumulativeTimes and 0 ~= self.cumulativeTimes then
        tb.e = self.cumulativeTimes
    end
    if nil ~= self.rewardType1 and 0 ~= self.rewardType1 then
        tb.f = self.rewardType1
    end
    if nil ~= self.rewardName1 and string.len(self.rewardName1) > 0 then
        tb.g = self.rewardName1
    end
    if nil ~= self.rewardItemId1 and 0 ~= self.rewardItemId1 then
        tb.h = self.rewardItemId1
    end
    if nil ~= self.rewardItemNum1 and 0 ~= self.rewardItemNum1 then
        tb.i = self.rewardItemNum1
    end
    if nil ~= self.rewardType2 and 0 ~= self.rewardType2 then
        tb.j = self.rewardType2
    end
    if nil ~= self.rewardName2 and string.len(self.rewardName2) > 0 then
        tb.k = self.rewardName2
    end
    if nil ~= self.rewardItemId2 and 0 ~= self.rewardItemId2 then
        tb.l = self.rewardItemId2
    end
    if nil ~= self.rewardItemNum2 and 0 ~= self.rewardItemNum2 then
        tb.m = self.rewardItemNum2
    end
    if nil ~= self.rewardType3 and 0 ~= self.rewardType3 then
        tb.n = self.rewardType3
    end
    if nil ~= self.rewardName3 and string.len(self.rewardName3) > 0 then
        tb.o = self.rewardName3
    end
    if nil ~= self.rewardItemId3 and 0 ~= self.rewardItemId3 then
        tb.p = self.rewardItemId3
    end
    if nil ~= self.rewardItemNum3 and 0 ~= self.rewardItemNum3 then
        tb.q = self.rewardItemNum3
    end
    return tb
end

function MsgType.GrandTotal:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.rewardGroup = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardSequence = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.cumulativeTimes = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rewardType1 = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.rewardName1 = tostring(data.g)
    end
    if nil ~= data.h then
        self.rewardItemId1 = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.rewardItemNum1 = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.rewardType2 = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.rewardName2 = tostring(data.k)
    end
    if nil ~= data.l then
        self.rewardItemId2 = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.rewardItemNum2 = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.rewardType3 = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.rewardName3 = tostring(data.o)
    end
    if nil ~= data.p then
        self.rewardItemId3 = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        self.rewardItemNum3 = tonumber(data.q) or 0
    end
    return self
end

function MsgType.GrandTotal:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.GrandTotal:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.JackpotDataRefresh = {
    zeroTime = 0,
    prizePoolStatus = 0, --enum PrizePoolStatus
    gemConsume = 0
}
MsgType.JackpotDataRefresh.__index = MsgType.JackpotDataRefresh

function MsgType.JackpotDataRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.JackpotDataRefresh:Encode()
    local tb = {}
    if nil ~= self.zeroTime and 0 ~= self.zeroTime then
        tb.b = self.zeroTime
    end
    if nil ~= self.prizePoolStatus and 0 ~= self.prizePoolStatus then
        tb.c = self.prizePoolStatus
    end
    if nil ~= self.gemConsume and 0 ~= self.gemConsume then
        tb.d = self.gemConsume
    end
    return tb
end

function MsgType.JackpotDataRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.zeroTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.prizePoolStatus = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.gemConsume = tonumber(data.d) or 0
    end
    return self
end

function MsgType.JackpotDataRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.JackpotDataRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Recording = {
    recordingTime = 0,
    recordingContent = 0,
    recordingType = 0,
    name = "",
    type = 0,
    count = 0,
    quality = 0
}
MsgType.Recording.__index = MsgType.Recording

function MsgType.Recording:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.Recording:Encode()
    local tb = {}
    if nil ~= self.recordingTime and 0 ~= self.recordingTime then
        tb.b = self.recordingTime
    end
    if nil ~= self.recordingContent and 0 ~= self.recordingContent then
        tb.c = self.recordingContent
    end
    if nil ~= self.recordingType and 0 ~= self.recordingType then
        tb.d = self.recordingType
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.e = self.name
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.f = self.type
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.g = self.count
    end
    if nil ~= self.quality and 0 ~= self.quality then
        tb.h = self.quality
    end
    return tb
end

function MsgType.Recording:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.recordingTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.recordingContent = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.recordingType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.name = tostring(data.e)
    end
    if nil ~= data.f then
        self.type = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.count = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.quality = tonumber(data.h) or 0
    end
    return self
end

function MsgType.Recording:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Recording:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Jackpot_Data = {
    msgSeq = 0,
    uid = 0
}
MsgType.Request_Jackpot_Data.__index = MsgType.Request_Jackpot_Data

function MsgType.Request_Jackpot_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Jackpot_Data:GetCmd()
    return MsgTypeCmd.Request_Jackpot_Data_Cmd
end
function MsgType.Request_Jackpot_Data:GetUrl()
    return "Request_Jackpot_Data"
end
function MsgType.Request_Jackpot_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.uid and 0 ~= self.uid then
        tb.c = self.uid
    end
    return tb
end

function MsgType.Request_Jackpot_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Jackpot_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Jackpot_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    prizeBaseData = {}, -- array of MsgType.JackpotData
    group = 0,
    prizePoolStatus = 0, --enum PrizePoolStatus
    zeroTime = 0,
    freeTime = 0,
    freeState = 0,
    gemConsume = 0,
    grandTotalNum = 0,
    props = 0,
    recording = {}, -- array of MsgType.Recording
    grandTotal = {},
    nextGrandTotal = {}
}
MsgType.Response_Jackpot_Data.__index = MsgType.Response_Jackpot_Data
setmetatable(MsgType.Response_Jackpot_Data.grandTotal, MsgType.GrandTotal)
setmetatable(MsgType.Response_Jackpot_Data.nextGrandTotal, MsgType.GrandTotal)

function MsgType.Response_Jackpot_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.prizeBaseData = {}
    tb.recording = {}
    tb.grandTotal = MsgType.GrandTotal:New()
    tb.nextGrandTotal = MsgType.GrandTotal:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Jackpot_Data:GetCmd()
    return MsgTypeCmd.Response_Jackpot_Data_Cmd
end
function MsgType.Response_Jackpot_Data:GetUrl()
    return "Response_Jackpot_Data"
end
function MsgType.Response_Jackpot_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpPrizeBaseDataObj = MsgType.JackpotData:New()
            tmpPrizeBaseDataObj:Decode(data.f[i])
            self.prizeBaseData[i] = tmpPrizeBaseDataObj
        end
    end
    if nil ~= data.g then
        self.group = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.prizePoolStatus = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.zeroTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.freeTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.freeState = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.gemConsume = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.grandTotalNum = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.props = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        for i=1, #data.o do
            local tmpRecordingObj = MsgType.Recording:New()
            tmpRecordingObj:Decode(data.o[i])
            self.recording[i] = tmpRecordingObj
        end
    end
    if nil ~= data.p then
        self.grandTotal:Decode(data.p)
    end
    if nil ~= data.q then
        self.nextGrandTotal:Decode(data.q)
    end
    return self
end


MsgType.DrawMoney = {
    free = 0,
    props = 1,
    gem = 2,
    vip = 3,
    ad = 4
}

MsgType.Request_Jackpot_Refresh = {
    msgSeq = 0,
    gem = 0,
    useType = 0 --enum DrawMoney
}
MsgType.Request_Jackpot_Refresh.__index = MsgType.Request_Jackpot_Refresh

function MsgType.Request_Jackpot_Refresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Jackpot_Refresh:GetCmd()
    return MsgTypeCmd.Request_Jackpot_Refresh_Cmd
end
function MsgType.Request_Jackpot_Refresh:GetUrl()
    return "Request_Jackpot_Refresh"
end
function MsgType.Request_Jackpot_Refresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.gem and 0 ~= self.gem then
        tb.c = self.gem
    end
    if nil ~= self.useType and 0 ~= self.useType then
        tb.d = self.useType
    end
    return tb
end

function MsgType.Request_Jackpot_Refresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Jackpot_Refresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Jackpot_Refresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    JackpotDataRefresh = {},
    prizeBaseData = {}, -- array of MsgType.JackpotData
    grandTotal = {}
}
MsgType.Response_Jackpot_Refresh.__index = MsgType.Response_Jackpot_Refresh
setmetatable(MsgType.Response_Jackpot_Refresh.JackpotDataRefresh, MsgType.JackpotDataRefresh)
setmetatable(MsgType.Response_Jackpot_Refresh.grandTotal, MsgType.GrandTotal)

function MsgType.Response_Jackpot_Refresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.JackpotDataRefresh = MsgType.JackpotDataRefresh:New()
    tb.prizeBaseData = {}
    tb.grandTotal = MsgType.GrandTotal:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Jackpot_Refresh:GetCmd()
    return MsgTypeCmd.Response_Jackpot_Refresh_Cmd
end
function MsgType.Response_Jackpot_Refresh:GetUrl()
    return "Response_Jackpot_Refresh"
end
function MsgType.Response_Jackpot_Refresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.JackpotDataRefresh:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpPrizeBaseDataObj = MsgType.JackpotData:New()
            tmpPrizeBaseDataObj:Decode(data.g[i])
            self.prizeBaseData[i] = tmpPrizeBaseDataObj
        end
    end
    if nil ~= data.h then
        self.grandTotal:Decode(data.h)
    end
    return self
end


MsgType.EUserBehaviorType = {
    GameUI = 1
}

MsgType.OneBehavior = {
    userId = "",
    optionTime = 0,
    type = 0, --enum EUserBehaviorType
    optionName = "",
    param = ""
}
MsgType.OneBehavior.__index = MsgType.OneBehavior

function MsgType.OneBehavior:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneBehavior:Encode()
    local tb = {}
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.b = self.userId
    end
    if nil ~= self.optionTime and 0 ~= self.optionTime then
        tb.c = self.optionTime
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.d = self.type
    end
    if nil ~= self.optionName and string.len(self.optionName) > 0 then
        tb.e = self.optionName
    end
    if nil ~= self.param and string.len(self.param) > 0 then
        tb.f = self.param
    end
    return tb
end

function MsgType.OneBehavior:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.userId = tostring(data.b)
    end
    if nil ~= data.c then
        self.optionTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.type = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.optionName = tostring(data.e)
    end
    if nil ~= data.f then
        self.param = tostring(data.f)
    end
    return self
end

function MsgType.OneBehavior:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneBehavior:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_BehaviorCounter = {
    msgSeq = 0,
    list = {} -- array of MsgType.OneBehavior
}
MsgType.Request_User_BehaviorCounter.__index = MsgType.Request_User_BehaviorCounter

function MsgType.Request_User_BehaviorCounter:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.list = {}
    return tb
end

function MsgType.Request_User_BehaviorCounter:GetCmd()
    return MsgTypeCmd.Request_User_BehaviorCounter_Cmd
end
function MsgType.Request_User_BehaviorCounter:GetUrl()
    return "Request_User_BehaviorCounter"
end
function MsgType.Request_User_BehaviorCounter:_listEncode()
    local tb = {}
    for i=1, #self.list do
        tb[i] = self.list[i]:Encode()
    end
    return tb
end
function MsgType.Request_User_BehaviorCounter:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    tb.c = self:_listEncode()
    return tb
end

function MsgType.Request_User_BehaviorCounter:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_BehaviorCounter:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_BehaviorCounter = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_User_BehaviorCounter.__index = MsgType.Response_User_BehaviorCounter

function MsgType.Response_User_BehaviorCounter:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_BehaviorCounter:GetCmd()
    return MsgTypeCmd.Response_User_BehaviorCounter_Cmd
end
function MsgType.Response_User_BehaviorCounter:GetUrl()
    return "Response_User_BehaviorCounter"
end
function MsgType.Response_User_BehaviorCounter:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_User_Lottery = {
    msgSeq = 0,
    money = 0 --enum DrawMoney
}
MsgType.Request_User_Lottery.__index = MsgType.Request_User_Lottery

function MsgType.Request_User_Lottery:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_Lottery:GetCmd()
    return MsgTypeCmd.Request_User_Lottery_Cmd
end
function MsgType.Request_User_Lottery:GetUrl()
    return "Request_User_Lottery"
end
function MsgType.Request_User_Lottery:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.money and 0 ~= self.money then
        tb.c = self.money
    end
    return tb
end

function MsgType.Request_User_Lottery:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_Lottery:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_Lottery = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    prizeBaseData = {}, -- array of MsgType.JackpotData
    prizedPropsCount = 0,
    grandTotal = {},
    freeTime = 0,
    freeState = 0
}
MsgType.Response_User_Lottery.__index = MsgType.Response_User_Lottery
setmetatable(MsgType.Response_User_Lottery.grandTotal, MsgType.GrandTotal)

function MsgType.Response_User_Lottery:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.prizeBaseData = {}
    tb.grandTotal = MsgType.GrandTotal:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_Lottery:GetCmd()
    return MsgTypeCmd.Response_User_Lottery_Cmd
end
function MsgType.Response_User_Lottery:GetUrl()
    return "Response_User_Lottery"
end
function MsgType.Response_User_Lottery:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpPrizeBaseDataObj = MsgType.JackpotData:New()
            tmpPrizeBaseDataObj:Decode(data.f[i])
            self.prizeBaseData[i] = tmpPrizeBaseDataObj
        end
    end
    if nil ~= data.g then
        self.prizedPropsCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.grandTotal:Decode(data.h)
    end
    if nil ~= data.i then
        self.freeTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.freeState = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_User_LotteryTenth = {
    msgSeq = 0,
    money = 0 --enum DrawMoney
}
MsgType.Request_User_LotteryTenth.__index = MsgType.Request_User_LotteryTenth

function MsgType.Request_User_LotteryTenth:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_LotteryTenth:GetCmd()
    return MsgTypeCmd.Request_User_LotteryTenth_Cmd
end
function MsgType.Request_User_LotteryTenth:GetUrl()
    return "Request_User_LotteryTenth"
end
function MsgType.Request_User_LotteryTenth:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.money and 0 ~= self.money then
        tb.c = self.money
    end
    return tb
end

function MsgType.Request_User_LotteryTenth:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_LotteryTenth:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_LotteryTenth = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    prizeBaseData = {}, -- array of MsgType.JackpotData
    prizedPropsCount = 0,
    grandTotal = {}
}
MsgType.Response_User_LotteryTenth.__index = MsgType.Response_User_LotteryTenth
setmetatable(MsgType.Response_User_LotteryTenth.grandTotal, MsgType.GrandTotal)

function MsgType.Response_User_LotteryTenth:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.prizeBaseData = {}
    tb.grandTotal = MsgType.GrandTotal:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_LotteryTenth:GetCmd()
    return MsgTypeCmd.Response_User_LotteryTenth_Cmd
end
function MsgType.Response_User_LotteryTenth:GetUrl()
    return "Response_User_LotteryTenth"
end
function MsgType.Response_User_LotteryTenth:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpPrizeBaseDataObj = MsgType.JackpotData:New()
            tmpPrizeBaseDataObj:Decode(data.f[i])
            self.prizeBaseData[i] = tmpPrizeBaseDataObj
        end
    end
    if nil ~= data.g then
        self.prizedPropsCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.grandTotal:Decode(data.h)
    end
    return self
end


MsgType.Request_Cumulative_Reward = {
    msgSeq = 0,
    rewardId = 0
}
MsgType.Request_Cumulative_Reward.__index = MsgType.Request_Cumulative_Reward

function MsgType.Request_Cumulative_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Cumulative_Reward:GetCmd()
    return MsgTypeCmd.Request_Cumulative_Reward_Cmd
end
function MsgType.Request_Cumulative_Reward:GetUrl()
    return "Request_Cumulative_Reward"
end
function MsgType.Request_Cumulative_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rewardId and 0 ~= self.rewardId then
        tb.c = self.rewardId
    end
    return tb
end

function MsgType.Request_Cumulative_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Cumulative_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Cumulative_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    grandTotalId = 0,
    grandTotalNum = 0,
    grandTotal = {},
    nextGrandTotal = {}
}
MsgType.Response_Cumulative_Reward.__index = MsgType.Response_Cumulative_Reward
setmetatable(MsgType.Response_Cumulative_Reward.grandTotal, MsgType.GrandTotal)
setmetatable(MsgType.Response_Cumulative_Reward.nextGrandTotal, MsgType.GrandTotal)

function MsgType.Response_Cumulative_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.grandTotal = MsgType.GrandTotal:New()
    tb.nextGrandTotal = MsgType.GrandTotal:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Cumulative_Reward:GetCmd()
    return MsgTypeCmd.Response_Cumulative_Reward_Cmd
end
function MsgType.Response_Cumulative_Reward:GetUrl()
    return "Response_Cumulative_Reward"
end
function MsgType.Response_Cumulative_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.grandTotalId = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.grandTotalNum = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.grandTotal:Decode(data.h)
    end
    if nil ~= data.i then
        self.nextGrandTotal:Decode(data.i)
    end
    return self
end


MsgType.Response_Roulette_Recording = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    recording = {} -- array of MsgType.Recording
}
MsgType.Response_Roulette_Recording.__index = MsgType.Response_Roulette_Recording

function MsgType.Response_Roulette_Recording:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.recording = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Roulette_Recording:GetCmd()
    return MsgTypeCmd.Response_Roulette_Recording_Cmd
end
function MsgType.Response_Roulette_Recording:GetUrl()
    return "Response_Roulette_Recording"
end
function MsgType.Response_Roulette_Recording:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRecordingObj = MsgType.Recording:New()
            tmpRecordingObj:Decode(data.f[i])
            self.recording[i] = tmpRecordingObj
        end
    end
    return self
end


MsgType.Request_Prize_Free = {
    msgSeq = 0,
}
MsgType.Request_Prize_Free.__index = MsgType.Request_Prize_Free

function MsgType.Request_Prize_Free:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Prize_Free:GetCmd()
    return MsgTypeCmd.Request_Prize_Free_Cmd
end
function MsgType.Request_Prize_Free:GetUrl()
    return "Request_Prize_Free"
end
function MsgType.Request_Prize_Free:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.Request_Prize_Free:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Prize_Free:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Prize_Free = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    freeState = 0, --enum EPrizePoolState
    prizePoolStatus = 0, --enum PrizePoolStatus
    zeroTime = 0,
    freeTime = 0,
    gemConsume = 0
}
MsgType.Response_Prize_Free.__index = MsgType.Response_Prize_Free

function MsgType.Response_Prize_Free:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Prize_Free:GetCmd()
    return MsgTypeCmd.Response_Prize_Free_Cmd
end
function MsgType.Response_Prize_Free:GetUrl()
    return "Response_Prize_Free"
end
function MsgType.Response_Prize_Free:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.freeState = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.prizePoolStatus = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.zeroTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.freeTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.gemConsume = tonumber(data.j) or 0
    end
    return self
end


MsgType.EItemUse = {
    Success = 0,
    Fail = 1
}

MsgType.Request_Hero_UseHeroStatusItem = {
    msgSeq = 0,
    itemId = 0,
    heroId = 0,
    itemCount = 0
}
MsgType.Request_Hero_UseHeroStatusItem.__index = MsgType.Request_Hero_UseHeroStatusItem

function MsgType.Request_Hero_UseHeroStatusItem:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_UseHeroStatusItem:GetCmd()
    return MsgTypeCmd.Request_Hero_UseHeroStatusItem_Cmd
end
function MsgType.Request_Hero_UseHeroStatusItem:GetUrl()
    return "Request_Hero_UseHeroStatusItem"
end
function MsgType.Request_Hero_UseHeroStatusItem:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    if nil ~= self.heroId and 0 ~= self.heroId then
        tb.d = self.heroId
    end
    if nil ~= self.itemCount and 0 ~= self.itemCount then
        tb.e = self.itemCount
    end
    return tb
end

function MsgType.Request_Hero_UseHeroStatusItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_UseHeroStatusItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_UseHeroStatusItem = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    itemUse = 0, --enum EItemUse
    heroInfo = {}
}
MsgType.Response_Hero_UseHeroStatusItem.__index = MsgType.Response_Hero_UseHeroStatusItem
setmetatable(MsgType.Response_Hero_UseHeroStatusItem.heroInfo, MsgType.HeroInfo)

function MsgType.Response_Hero_UseHeroStatusItem:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroInfo = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_UseHeroStatusItem:GetCmd()
    return MsgTypeCmd.Response_Hero_UseHeroStatusItem_Cmd
end
function MsgType.Response_Hero_UseHeroStatusItem:GetUrl()
    return "Response_Hero_UseHeroStatusItem"
end
function MsgType.Response_Hero_UseHeroStatusItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.itemUse = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.heroInfo:Decode(data.g)
    end
    return self
end


MsgType.Request_Hero_UseEquipItem = {
    msgSeq = 0,
    equipId = 0
}
MsgType.Request_Hero_UseEquipItem.__index = MsgType.Request_Hero_UseEquipItem

function MsgType.Request_Hero_UseEquipItem:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_UseEquipItem:GetCmd()
    return MsgTypeCmd.Request_Hero_UseEquipItem_Cmd
end
function MsgType.Request_Hero_UseEquipItem:GetUrl()
    return "Request_Hero_UseEquipItem"
end
function MsgType.Request_Hero_UseEquipItem:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.equipId and 0 ~= self.equipId then
        tb.c = self.equipId
    end
    return tb
end

function MsgType.Request_Hero_UseEquipItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_UseEquipItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_UseEquipItem = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    itemUse = 0, --enum EItemUse
    equipDrawingId = 0
}
MsgType.Response_Hero_UseEquipItem.__index = MsgType.Response_Hero_UseEquipItem

function MsgType.Response_Hero_UseEquipItem:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_UseEquipItem:GetCmd()
    return MsgTypeCmd.Response_Hero_UseEquipItem_Cmd
end
function MsgType.Response_Hero_UseEquipItem:GetUrl()
    return "Response_Hero_UseEquipItem"
end
function MsgType.Response_Hero_UseEquipItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.itemUse = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.equipDrawingId = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Hero_UseItem = {
    msgSeq = 0,
    itemId = 0,
    heroId = 0
}
MsgType.Request_Hero_UseItem.__index = MsgType.Request_Hero_UseItem

function MsgType.Request_Hero_UseItem:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Hero_UseItem:GetCmd()
    return MsgTypeCmd.Request_Hero_UseItem_Cmd
end
function MsgType.Request_Hero_UseItem:GetUrl()
    return "Request_Hero_UseItem"
end
function MsgType.Request_Hero_UseItem:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    if nil ~= self.heroId and 0 ~= self.heroId then
        tb.d = self.heroId
    end
    return tb
end

function MsgType.Request_Hero_UseItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Hero_UseItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Hero_UseItem = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    itemUse = 0 --enum EItemUse
}
MsgType.Response_Hero_UseItem.__index = MsgType.Response_Hero_UseItem

function MsgType.Response_Hero_UseItem:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Hero_UseItem:GetCmd()
    return MsgTypeCmd.Response_Hero_UseItem_Cmd
end
function MsgType.Response_Hero_UseItem:GetUrl()
    return "Response_Hero_UseItem"
end
function MsgType.Response_Hero_UseItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.itemUse = tonumber(data.f) or 0
    end
    return self
end


MsgType.EBuildState = {
    EB_Lock = 0,
    EB_Unlock = 1,
    EB_Upgrading = 2,
    EB_Finished = 3
}

MsgType.EBuildType = {
    ResourceBuild = 1,
    FunctionalBuild = 2,
    ScienceProject = 3
}

MsgType.EBuildEffectType = {
    EB_OutPut = 1,
    EB_UpperLevel = 2,
    EB_TimeReduce = 3,
    EB_ResourceAdd = 4,
    EB_HeroLevelLimit = 5,
    EB_UnionMemberCountLimit = 6
}

MsgType.BuildData = {
    buildId = 0,
    buildState = 0, --enum EBuildState
    buildLevel = 0,
    buildCostCount = 0,
    oneSelfCostCount = 0,
    currentCostCount = 0,
    stateRemainTime = 0
}
MsgType.BuildData.__index = MsgType.BuildData

function MsgType.BuildData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BuildData:Encode()
    local tb = {}
    if nil ~= self.buildId and 0 ~= self.buildId then
        tb.b = self.buildId
    end
    if nil ~= self.buildState and 0 ~= self.buildState then
        tb.c = self.buildState
    end
    if nil ~= self.buildLevel and 0 ~= self.buildLevel then
        tb.d = self.buildLevel
    end
    if nil ~= self.buildCostCount and 0 ~= self.buildCostCount then
        tb.e = self.buildCostCount
    end
    if nil ~= self.oneSelfCostCount and 0 ~= self.oneSelfCostCount then
        tb.f = self.oneSelfCostCount
    end
    if nil ~= self.currentCostCount and 0 ~= self.currentCostCount then
        tb.g = self.currentCostCount
    end
    if nil ~= self.stateRemainTime and 0 ~= self.stateRemainTime then
        tb.h = self.stateRemainTime
    end
    return tb
end

function MsgType.BuildData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.buildId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.buildState = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.buildLevel = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.buildCostCount = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.oneSelfCostCount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.currentCostCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.stateRemainTime = tonumber(data.h) or 0
    end
    return self
end

function MsgType.BuildData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.BuildData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_City_BuildData = {
    msgSeq = 0,
}
MsgType.Request_City_BuildData.__index = MsgType.Request_City_BuildData

function MsgType.Request_City_BuildData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_City_BuildData:GetCmd()
    return MsgTypeCmd.Request_City_BuildData_Cmd
end
function MsgType.Request_City_BuildData:GetUrl()
    return "Request_City_BuildData"
end
function MsgType.Request_City_BuildData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.Request_City_BuildData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_City_BuildData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_City_BuildData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    buildData = {} -- array of MsgType.BuildData
}
MsgType.Response_City_BuildData.__index = MsgType.Response_City_BuildData

function MsgType.Response_City_BuildData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.buildData = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_City_BuildData:GetCmd()
    return MsgTypeCmd.Response_City_BuildData_Cmd
end
function MsgType.Response_City_BuildData:GetUrl()
    return "Response_City_BuildData"
end
function MsgType.Response_City_BuildData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpBuildDataObj = MsgType.BuildData:New()
            tmpBuildDataObj:Decode(data.f[i])
            self.buildData[i] = tmpBuildDataObj
        end
    end
    return self
end


MsgType.Request_City_BuildCost = {
    msgSeq = 0,
    buildId = 0,
    costMoneyType = 0,
    buildCostCount = 0
}
MsgType.Request_City_BuildCost.__index = MsgType.Request_City_BuildCost

function MsgType.Request_City_BuildCost:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_City_BuildCost:GetCmd()
    return MsgTypeCmd.Request_City_BuildCost_Cmd
end
function MsgType.Request_City_BuildCost:GetUrl()
    return "Request_City_BuildCost"
end
function MsgType.Request_City_BuildCost:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buildId and 0 ~= self.buildId then
        tb.c = self.buildId
    end
    if nil ~= self.costMoneyType and 0 ~= self.costMoneyType then
        tb.d = self.costMoneyType
    end
    if nil ~= self.buildCostCount and 0 ~= self.buildCostCount then
        tb.e = self.buildCostCount
    end
    return tb
end

function MsgType.Request_City_BuildCost:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_City_BuildCost:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_City_BuildDataChanged = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    buildData = {}
}
MsgType.Response_City_BuildDataChanged.__index = MsgType.Response_City_BuildDataChanged
setmetatable(MsgType.Response_City_BuildDataChanged.buildData, MsgType.BuildData)

function MsgType.Response_City_BuildDataChanged:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.buildData = MsgType.BuildData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_City_BuildDataChanged:GetCmd()
    return MsgTypeCmd.Response_City_BuildDataChanged_Cmd
end
function MsgType.Response_City_BuildDataChanged:GetUrl()
    return "Response_City_BuildDataChanged"
end
function MsgType.Response_City_BuildDataChanged:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.buildData:Decode(data.f)
    end
    return self
end


MsgType.BuildTopList = {
    name = "",
    investNum = 0
}
MsgType.BuildTopList.__index = MsgType.BuildTopList

function MsgType.BuildTopList:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.BuildTopList:Encode()
    local tb = {}
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.b = self.name
    end
    if nil ~= self.investNum and 0 ~= self.investNum then
        tb.c = self.investNum
    end
    return tb
end

function MsgType.BuildTopList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.name = tostring(data.b)
    end
    if nil ~= data.c then
        self.investNum = tonumber(data.c) or 0
    end
    return self
end

function MsgType.BuildTopList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.BuildTopList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_City_BuildingRankData = {
    msgSeq = 0,
    buildId = 0
}
MsgType.Request_City_BuildingRankData.__index = MsgType.Request_City_BuildingRankData

function MsgType.Request_City_BuildingRankData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_City_BuildingRankData:GetCmd()
    return MsgTypeCmd.Request_City_BuildingRankData_Cmd
end
function MsgType.Request_City_BuildingRankData:GetUrl()
    return "Request_City_BuildingRankData"
end
function MsgType.Request_City_BuildingRankData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buildId and 0 ~= self.buildId then
        tb.c = self.buildId
    end
    return tb
end

function MsgType.Request_City_BuildingRankData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_City_BuildingRankData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_City_BuildingRankData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    buildTopList = {} -- array of MsgType.BuildTopList
}
MsgType.Response_City_BuildingRankData.__index = MsgType.Response_City_BuildingRankData

function MsgType.Response_City_BuildingRankData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.buildTopList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_City_BuildingRankData:GetCmd()
    return MsgTypeCmd.Response_City_BuildingRankData_Cmd
end
function MsgType.Response_City_BuildingRankData:GetUrl()
    return "Response_City_BuildingRankData"
end
function MsgType.Response_City_BuildingRankData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpBuildTopListObj = MsgType.BuildTopList:New()
            tmpBuildTopListObj:Decode(data.f[i])
            self.buildTopList[i] = tmpBuildTopListObj
        end
    end
    return self
end


MsgType.EExploreType = {
    Normal = 1,
    Boss = 2
}

MsgType.EExploringState = {
    EE_Idle = 0,
    EE_Exploring = 1,
    EE_Finish = 2
}

MsgType.EBossExploreState = {
    EB_Idle = 1,
    EB_FightIng = 2,
    EB_Wait = 3,
    EB_Ready = 4
}

MsgType.EUserVipEffectType = {
    FixBrokenEquip = 1,
    BrokenEquipSpendGold = 2,
    SevenDayReward = 3,
    ExploreVipReward = 4,
    OpenBoxVipReward = 5,
    PiggyBankVipReward = 6,
    DailyTaskVipQuest = 7,
    DailyTaskVipQuestReward = 8,
    PrizeTenVipPrice = 9,
    GemMallVipPrice = 10,
    HireHeroVipPrice = 11,
    VipFurniture = 12,
    VipExploreRest = 13
}

MsgType.EExploreSlotType = {
    None = 0,
    Normal = 1,
    Tower = 2,
    GoldCastle = 3
}

MsgType.ExploreSlot = {
    slotId = 0,
    exploreId = 0,
    exploringRemainTime = 0,
    exploreTotalTime = 0,
    exploreState = 0, --enum EExploringState
    exploreType = 0,
    heroInfoUIds = {}, -- array of number
    useItemId = 0,
    slotType = 0 --enum EExploreSlotType
}
MsgType.ExploreSlot.__index = MsgType.ExploreSlot

function MsgType.ExploreSlot:New()
    local tb = {}
    setmetatable(tb, self)
    tb.heroInfoUIds = {}
    return tb
end

function MsgType.ExploreSlot:Encode()
    local tb = {}
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.b = self.slotId
    end
    if nil ~= self.exploreId and 0 ~= self.exploreId then
        tb.c = self.exploreId
    end
    if nil ~= self.exploringRemainTime and 0 ~= self.exploringRemainTime then
        tb.d = self.exploringRemainTime
    end
    if nil ~= self.exploreTotalTime and 0 ~= self.exploreTotalTime then
        tb.e = self.exploreTotalTime
    end
    if nil ~= self.exploreState and 0 ~= self.exploreState then
        tb.f = self.exploreState
    end
    if nil ~= self.exploreType and 0 ~= self.exploreType then
        tb.g = self.exploreType
    end
    if nil ~= self.heroInfoUIds and #self.heroInfoUIds > 0 then
        for i=1, #self.heroInfoUIds do
            tb.e[i] = tonumber(self.heroInfoUIds[i])
        end
    end
    if nil ~= self.useItemId and 0 ~= self.useItemId then
        tb.i = self.useItemId
    end
    if nil ~= self.slotType and 0 ~= self.slotType then
        tb.j = self.slotType
    end
    return tb
end

function MsgType.ExploreSlot:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.slotId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.exploreId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.exploringRemainTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.exploreTotalTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.exploreState = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.exploreType = tonumber(data.g) or 0
    end
    if nil ~= data.h and #data.h > 0 then
        for i=1, #data.h do
            self.heroInfoUIds[i] = tonumber(data.h[i])
        end
    end
    if nil ~= data.i then
        self.useItemId = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.slotType = tonumber(data.j) or 0
    end
    return self
end

function MsgType.ExploreSlot:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ExploreSlot:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.ExploreGroupData = {
    groupId = 0,
    level = 0,
    exp = 0,
    bossExploreState = 0, --enum EBossExploreState
    bossRemainTime = 0,
    groupState = 0,
    slotType = 0
}
MsgType.ExploreGroupData.__index = MsgType.ExploreGroupData

function MsgType.ExploreGroupData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ExploreGroupData:Encode()
    local tb = {}
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.b = self.groupId
    end
    if nil ~= self.level and 0 ~= self.level then
        tb.c = self.level
    end
    if nil ~= self.exp and 0 ~= self.exp then
        tb.d = self.exp
    end
    if nil ~= self.bossExploreState and 0 ~= self.bossExploreState then
        tb.e = self.bossExploreState
    end
    if nil ~= self.bossRemainTime and 0 ~= self.bossRemainTime then
        tb.f = self.bossRemainTime
    end
    if nil ~= self.groupState and 0 ~= self.groupState then
        tb.g = self.groupState
    end
    if nil ~= self.slotType and 0 ~= self.slotType then
        tb.h = self.slotType
    end
    return tb
end

function MsgType.ExploreGroupData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.groupId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.level = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.exp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.bossExploreState = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.bossRemainTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.groupState = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.slotType = tonumber(data.h) or 0
    end
    return self
end

function MsgType.ExploreGroupData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ExploreGroupData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Explore_BuySlot = {
    msgSeq = 0,
    useGem = 0
}
MsgType.Request_Explore_BuySlot.__index = MsgType.Request_Explore_BuySlot

function MsgType.Request_Explore_BuySlot:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Explore_BuySlot:GetCmd()
    return MsgTypeCmd.Request_Explore_BuySlot_Cmd
end
function MsgType.Request_Explore_BuySlot:GetUrl()
    return "Request_Explore_BuySlot"
end
function MsgType.Request_Explore_BuySlot:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.c = self.useGem
    end
    return tb
end

function MsgType.Request_Explore_BuySlot:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_BuySlot:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_BuySlot = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {}
}
MsgType.Response_Explore_BuySlot.__index = MsgType.Response_Explore_BuySlot
setmetatable(MsgType.Response_Explore_BuySlot.exploreSlot, MsgType.ExploreSlot)

function MsgType.Response_Explore_BuySlot:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_BuySlot:GetCmd()
    return MsgTypeCmd.Response_Explore_BuySlot_Cmd
end
function MsgType.Response_Explore_BuySlot:GetUrl()
    return "Response_Explore_BuySlot"
end
function MsgType.Response_Explore_BuySlot:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    return self
end


MsgType.Request_Explore_Data = {
    msgSeq = 0,
}
MsgType.Request_Explore_Data.__index = MsgType.Request_Explore_Data

function MsgType.Request_Explore_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Explore_Data:GetCmd()
    return MsgTypeCmd.Request_Explore_Data_Cmd
end
function MsgType.Request_Explore_Data:GetUrl()
    return "Request_Explore_Data"
end
function MsgType.Request_Explore_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.Request_Explore_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreGroupData = {} -- array of MsgType.ExploreGroupData
}
MsgType.Response_Explore_Data.__index = MsgType.Response_Explore_Data

function MsgType.Response_Explore_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreGroupData = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_Data:GetCmd()
    return MsgTypeCmd.Response_Explore_Data_Cmd
end
function MsgType.Response_Explore_Data:GetUrl()
    return "Response_Explore_Data"
end
function MsgType.Response_Explore_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpExploreGroupDataObj = MsgType.ExploreGroupData:New()
            tmpExploreGroupDataObj:Decode(data.f[i])
            self.exploreGroupData[i] = tmpExploreGroupDataObj
        end
    end
    return self
end


MsgType.Request_Explore_Start = {
    msgSeq = 0,
    exploreSlotId = 0,
    exploreId = 0,
    exploreType = 0,
    useItemId = 0,
    heroInfoUIds = {} -- array of number
}
MsgType.Request_Explore_Start.__index = MsgType.Request_Explore_Start

function MsgType.Request_Explore_Start:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroInfoUIds = {}
    return tb
end

function MsgType.Request_Explore_Start:GetCmd()
    return MsgTypeCmd.Request_Explore_Start_Cmd
end
function MsgType.Request_Explore_Start:GetUrl()
    return "Request_Explore_Start"
end
function MsgType.Request_Explore_Start:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exploreSlotId and 0 ~= self.exploreSlotId then
        tb.c = self.exploreSlotId
    end
    if nil ~= self.exploreId and 0 ~= self.exploreId then
        tb.d = self.exploreId
    end
    if nil ~= self.exploreType and 0 ~= self.exploreType then
        tb.e = self.exploreType
    end
    if nil ~= self.useItemId and 0 ~= self.useItemId then
        tb.f = self.useItemId
    end
    if nil ~= self.heroInfoUIds and #self.heroInfoUIds > 0 then
        for i=1, #self.heroInfoUIds do
            tb.e[i] = tonumber(self.heroInfoUIds[i])
        end
    end
    return tb
end

function MsgType.Request_Explore_Start:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_Start:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_Start = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {},
    heroInfo = {} -- array of MsgType.HeroInfo
}
MsgType.Response_Explore_Start.__index = MsgType.Response_Explore_Start
setmetatable(MsgType.Response_Explore_Start.exploreSlot, MsgType.ExploreSlot)

function MsgType.Response_Explore_Start:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    tb.heroInfo = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_Start:GetCmd()
    return MsgTypeCmd.Response_Explore_Start_Cmd
end
function MsgType.Response_Explore_Start:GetUrl()
    return "Response_Explore_Start"
end
function MsgType.Response_Explore_Start:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpHeroInfoObj = MsgType.HeroInfo:New()
            tmpHeroInfoObj:Decode(data.g[i])
            self.heroInfo[i] = tmpHeroInfoObj
        end
    end
    return self
end


MsgType.Request_Explore_End = {
    msgSeq = 0,
    exploreSlotId = 0
}
MsgType.Request_Explore_End.__index = MsgType.Request_Explore_End

function MsgType.Request_Explore_End:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Explore_End:GetCmd()
    return MsgTypeCmd.Request_Explore_End_Cmd
end
function MsgType.Request_Explore_End:GetUrl()
    return "Request_Explore_End"
end
function MsgType.Request_Explore_End:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exploreSlotId and 0 ~= self.exploreSlotId then
        tb.c = self.exploreSlotId
    end
    return tb
end

function MsgType.Request_Explore_End:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_End:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_End = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {},
    exploreId = 0,
    resultState = 0,
    rewardList = {}, -- array of MsgType.OneRewardItem
    brokeEquipList = {}, -- array of MsgType.HeroBrokenEquip
    getMoney = 0,
    exploreGroupData = {},
    heroInfo = {}, -- array of MsgType.HeroInfo
    combatReport = {}
}
MsgType.Response_Explore_End.__index = MsgType.Response_Explore_End
setmetatable(MsgType.Response_Explore_End.exploreSlot, MsgType.ExploreSlot)
setmetatable(MsgType.Response_Explore_End.exploreGroupData, MsgType.ExploreGroupData)
setmetatable(MsgType.Response_Explore_End.combatReport, MsgType.CombatReport)

function MsgType.Response_Explore_End:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    tb.rewardList = {}
    tb.brokeEquipList = {}
    tb.exploreGroupData = MsgType.ExploreGroupData:New()
    tb.heroInfo = {}
    tb.combatReport = MsgType.CombatReport:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_End:GetCmd()
    return MsgTypeCmd.Response_Explore_End_Cmd
end
function MsgType.Response_Explore_End:GetUrl()
    return "Response_Explore_End"
end
function MsgType.Response_Explore_End:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    if nil ~= data.g then
        self.exploreId = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.resultState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpBrokeEquipListObj = MsgType.HeroBrokenEquip:New()
            tmpBrokeEquipListObj:Decode(data.j[i])
            self.brokeEquipList[i] = tmpBrokeEquipListObj
        end
    end
    if nil ~= data.k then
        self.getMoney = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.exploreGroupData:Decode(data.l)
    end
    if nil ~= data.m then
        for i=1, #data.m do
            local tmpHeroInfoObj = MsgType.HeroInfo:New()
            tmpHeroInfoObj:Decode(data.m[i])
            self.heroInfo[i] = tmpHeroInfoObj
        end
    end
    if nil ~= data.n then
        self.combatReport:Decode(data.n)
    end
    return self
end


MsgType.Request_Explore_RewardVip = {
    msgSeq = 0,
    exploreSlotId = 0
}
MsgType.Request_Explore_RewardVip.__index = MsgType.Request_Explore_RewardVip

function MsgType.Request_Explore_RewardVip:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Explore_RewardVip:GetCmd()
    return MsgTypeCmd.Request_Explore_RewardVip_Cmd
end
function MsgType.Request_Explore_RewardVip:GetUrl()
    return "Request_Explore_RewardVip"
end
function MsgType.Request_Explore_RewardVip:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exploreSlotId and 0 ~= self.exploreSlotId then
        tb.c = self.exploreSlotId
    end
    return tb
end

function MsgType.Request_Explore_RewardVip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_RewardVip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_RewardVip = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_Explore_RewardVip.__index = MsgType.Response_Explore_RewardVip

function MsgType.Response_Explore_RewardVip:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_RewardVip:GetCmd()
    return MsgTypeCmd.Response_Explore_RewardVip_Cmd
end
function MsgType.Response_Explore_RewardVip:GetUrl()
    return "Response_Explore_RewardVip"
end
function MsgType.Response_Explore_RewardVip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.f[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Request_Explore_Unlock = {
    msgSeq = 0,
    group = 0,
    useGem = 0
}
MsgType.Request_Explore_Unlock.__index = MsgType.Request_Explore_Unlock

function MsgType.Request_Explore_Unlock:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Explore_Unlock:GetCmd()
    return MsgTypeCmd.Request_Explore_Unlock_Cmd
end
function MsgType.Request_Explore_Unlock:GetUrl()
    return "Request_Explore_Unlock"
end
function MsgType.Request_Explore_Unlock:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.group and 0 ~= self.group then
        tb.c = self.group
    end
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.d = self.useGem
    end
    return tb
end

function MsgType.Request_Explore_Unlock:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_Unlock:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_Unlock = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreGroupData = {}
}
MsgType.Response_Explore_Unlock.__index = MsgType.Response_Explore_Unlock
setmetatable(MsgType.Response_Explore_Unlock.exploreGroupData, MsgType.ExploreGroupData)

function MsgType.Response_Explore_Unlock:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreGroupData = MsgType.ExploreGroupData:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_Unlock:GetCmd()
    return MsgTypeCmd.Response_Explore_Unlock_Cmd
end
function MsgType.Response_Explore_Unlock:GetUrl()
    return "Response_Explore_Unlock"
end
function MsgType.Response_Explore_Unlock:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreGroupData:Decode(data.f)
    end
    return self
end


MsgType.Request_ExploreSlot_Data = {
    msgSeq = 0,
}
MsgType.Request_ExploreSlot_Data.__index = MsgType.Request_ExploreSlot_Data

function MsgType.Request_ExploreSlot_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_ExploreSlot_Data:GetCmd()
    return MsgTypeCmd.Request_ExploreSlot_Data_Cmd
end
function MsgType.Request_ExploreSlot_Data:GetUrl()
    return "Request_ExploreSlot_Data"
end
function MsgType.Request_ExploreSlot_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.Request_ExploreSlot_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_ExploreSlot_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_ExploreSlot_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlotList = {} -- array of MsgType.ExploreSlot
}
MsgType.Response_ExploreSlot_Data.__index = MsgType.Response_ExploreSlot_Data

function MsgType.Response_ExploreSlot_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlotList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_ExploreSlot_Data:GetCmd()
    return MsgTypeCmd.Response_ExploreSlot_Data_Cmd
end
function MsgType.Response_ExploreSlot_Data:GetUrl()
    return "Response_ExploreSlot_Data"
end
function MsgType.Response_ExploreSlot_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpExploreSlotListObj = MsgType.ExploreSlot:New()
            tmpExploreSlotListObj:Decode(data.f[i])
            self.exploreSlotList[i] = tmpExploreSlotListObj
        end
    end
    return self
end


MsgType.Request_Explore_Refresh = {
    msgSeq = 0,
    slotId = 0
}
MsgType.Request_Explore_Refresh.__index = MsgType.Request_Explore_Refresh

function MsgType.Request_Explore_Refresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Explore_Refresh:GetCmd()
    return MsgTypeCmd.Request_Explore_Refresh_Cmd
end
function MsgType.Request_Explore_Refresh:GetUrl()
    return "Request_Explore_Refresh"
end
function MsgType.Request_Explore_Refresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.c = self.slotId
    end
    return tb
end

function MsgType.Request_Explore_Refresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_Refresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_Refresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlotList = {}
}
MsgType.Response_Explore_Refresh.__index = MsgType.Response_Explore_Refresh
setmetatable(MsgType.Response_Explore_Refresh.exploreSlotList, MsgType.ExploreSlot)

function MsgType.Response_Explore_Refresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlotList = MsgType.ExploreSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_Refresh:GetCmd()
    return MsgTypeCmd.Response_Explore_Refresh_Cmd
end
function MsgType.Response_Explore_Refresh:GetUrl()
    return "Response_Explore_Refresh"
end
function MsgType.Response_Explore_Refresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlotList:Decode(data.f)
    end
    return self
end


MsgType.Request_Explore_Immediately = {
    msgSeq = 0,
    slotId = 0
}
MsgType.Request_Explore_Immediately.__index = MsgType.Request_Explore_Immediately

function MsgType.Request_Explore_Immediately:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Explore_Immediately:GetCmd()
    return MsgTypeCmd.Request_Explore_Immediately_Cmd
end
function MsgType.Request_Explore_Immediately:GetUrl()
    return "Request_Explore_Immediately"
end
function MsgType.Request_Explore_Immediately:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.c = self.slotId
    end
    return tb
end

function MsgType.Request_Explore_Immediately:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Explore_Immediately:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Explore_Immediately = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {}
}
MsgType.Response_Explore_Immediately.__index = MsgType.Response_Explore_Immediately
setmetatable(MsgType.Response_Explore_Immediately.exploreSlot, MsgType.ExploreSlot)

function MsgType.Response_Explore_Immediately:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Explore_Immediately:GetCmd()
    return MsgTypeCmd.Response_Explore_Immediately_Cmd
end
function MsgType.Response_Explore_Immediately:GetUrl()
    return "Response_Explore_Immediately"
end
function MsgType.Response_Explore_Immediately:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    return self
end


MsgType.ExclusiveData = {
    itemId = 0,
    isUnlock = 0
}
MsgType.ExclusiveData.__index = MsgType.ExclusiveData

function MsgType.ExclusiveData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ExclusiveData:Encode()
    local tb = {}
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.b = self.itemId
    end
    if nil ~= self.isUnlock and 0 ~= self.isUnlock then
        tb.c = self.isUnlock
    end
    return tb
end

function MsgType.ExclusiveData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.itemId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.isUnlock = tonumber(data.c) or 0
    end
    return self
end

function MsgType.ExclusiveData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ExclusiveData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.TreasureBox = {
    boxGroupId = 0,
    boxItemId = 0,
    boxCount = 0,
    keyId = 0,
    keyCount = 0,
    costGem = 0,
    exclusiveData = {} -- array of MsgType.ExclusiveData
}
MsgType.TreasureBox.__index = MsgType.TreasureBox

function MsgType.TreasureBox:New()
    local tb = {}
    setmetatable(tb, self)
    tb.exclusiveData = {}
    return tb
end

function MsgType.TreasureBox:_exclusiveDataEncode()
    local tb = {}
    for i=1, #self.exclusiveData do
        tb[i] = self.exclusiveData[i]:Encode()
    end
    return tb
end
function MsgType.TreasureBox:Encode()
    local tb = {}
    if nil ~= self.boxGroupId and 0 ~= self.boxGroupId then
        tb.b = self.boxGroupId
    end
    if nil ~= self.boxItemId and 0 ~= self.boxItemId then
        tb.c = self.boxItemId
    end
    if nil ~= self.boxCount and 0 ~= self.boxCount then
        tb.d = self.boxCount
    end
    if nil ~= self.keyId and 0 ~= self.keyId then
        tb.e = self.keyId
    end
    if nil ~= self.keyCount and 0 ~= self.keyCount then
        tb.f = self.keyCount
    end
    if nil ~= self.costGem and 0 ~= self.costGem then
        tb.g = self.costGem
    end
    tb.h = self:_exclusiveDataEncode()
    return tb
end

function MsgType.TreasureBox:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.boxGroupId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.boxItemId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.boxCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.keyId = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.keyCount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.costGem = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpExclusiveDataObj = MsgType.ExclusiveData:New()
            tmpExclusiveDataObj:Decode(data.h[i])
            self.exclusiveData[i] = tmpExclusiveDataObj
        end
    end
    return self
end

function MsgType.TreasureBox:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.TreasureBox:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_TreasureBox_Data = {
    msgSeq = 0,
}
MsgType.Request_TreasureBox_Data.__index = MsgType.Request_TreasureBox_Data

function MsgType.Request_TreasureBox_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_TreasureBox_Data:GetCmd()
    return MsgTypeCmd.Request_TreasureBox_Data_Cmd
end
function MsgType.Request_TreasureBox_Data:GetUrl()
    return "Request_TreasureBox_Data"
end
function MsgType.Request_TreasureBox_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    return tb
end

function MsgType.Request_TreasureBox_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_TreasureBox_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_TreasureBox_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    treasureBox = {} -- array of MsgType.TreasureBox
}
MsgType.Response_TreasureBox_Data.__index = MsgType.Response_TreasureBox_Data

function MsgType.Response_TreasureBox_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.treasureBox = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_TreasureBox_Data:GetCmd()
    return MsgTypeCmd.Response_TreasureBox_Data_Cmd
end
function MsgType.Response_TreasureBox_Data:GetUrl()
    return "Response_TreasureBox_Data"
end
function MsgType.Response_TreasureBox_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTreasureBoxObj = MsgType.TreasureBox:New()
            tmpTreasureBoxObj:Decode(data.f[i])
            self.treasureBox[i] = tmpTreasureBoxObj
        end
    end
    return self
end


MsgType.Request_TreasureBox_Open = {
    msgSeq = 0,
    boxGroupId = 0,
    useGem = 0
}
MsgType.Request_TreasureBox_Open.__index = MsgType.Request_TreasureBox_Open

function MsgType.Request_TreasureBox_Open:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_TreasureBox_Open:GetCmd()
    return MsgTypeCmd.Request_TreasureBox_Open_Cmd
end
function MsgType.Request_TreasureBox_Open:GetUrl()
    return "Request_TreasureBox_Open"
end
function MsgType.Request_TreasureBox_Open:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.boxGroupId and 0 ~= self.boxGroupId then
        tb.c = self.boxGroupId
    end
    if nil ~= self.useGem and 0 ~= self.useGem then
        tb.d = self.useGem
    end
    return tb
end

function MsgType.Request_TreasureBox_Open:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_TreasureBox_Open:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_TreasureBox_Open = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    treasureBox = {},
    rewardItemList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_TreasureBox_Open.__index = MsgType.Response_TreasureBox_Open
setmetatable(MsgType.Response_TreasureBox_Open.treasureBox, MsgType.TreasureBox)

function MsgType.Response_TreasureBox_Open:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.treasureBox = MsgType.TreasureBox:New()
    tb.rewardItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_TreasureBox_Open:GetCmd()
    return MsgTypeCmd.Response_TreasureBox_Open_Cmd
end
function MsgType.Response_TreasureBox_Open:GetUrl()
    return "Response_TreasureBox_Open"
end
function MsgType.Response_TreasureBox_Open:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.treasureBox:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardItemListObj = MsgType.OneRewardItem:New()
            tmpRewardItemListObj:Decode(data.g[i])
            self.rewardItemList[i] = tmpRewardItemListObj
        end
    end
    return self
end


MsgType.EMailStatus = {
    Unread = 0,
    Read = 1,
    Unclaimed = 2,
    Claimed = 3,
    Deleted = 99
}

MsgType.OneMailDetail = {
    lang = 0, --enum ELangType
    mailSender = "",
    mailReceiver = "",
    mailTitle = "",
    mailContent = ""
}
MsgType.OneMailDetail.__index = MsgType.OneMailDetail

function MsgType.OneMailDetail:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneMailDetail:Encode()
    local tb = {}
    if nil ~= self.lang and 0 ~= self.lang then
        tb.b = self.lang
    end
    if nil ~= self.mailSender and string.len(self.mailSender) > 0 then
        tb.c = self.mailSender
    end
    if nil ~= self.mailReceiver and string.len(self.mailReceiver) > 0 then
        tb.d = self.mailReceiver
    end
    if nil ~= self.mailTitle and string.len(self.mailTitle) > 0 then
        tb.e = self.mailTitle
    end
    if nil ~= self.mailContent and string.len(self.mailContent) > 0 then
        tb.f = self.mailContent
    end
    return tb
end

function MsgType.OneMailDetail:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.lang = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.mailSender = tostring(data.c)
    end
    if nil ~= data.d then
        self.mailReceiver = tostring(data.d)
    end
    if nil ~= data.e then
        self.mailTitle = tostring(data.e)
    end
    if nil ~= data.f then
        self.mailContent = tostring(data.f)
    end
    return self
end

function MsgType.OneMailDetail:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneMailDetail:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneMail = {
    mailId = 0,
    createTime = 0,
    expireTime = 0,
    mailStatus = 0, --enum EMailStatus
    itemList = {}, -- array of MsgType.OneRewardItem
    detailList = {} -- array of MsgType.OneMailDetail
}
MsgType.OneMail.__index = MsgType.OneMail

function MsgType.OneMail:New()
    local tb = {}
    setmetatable(tb, self)
    tb.itemList = {}
    tb.detailList = {}
    return tb
end

function MsgType.OneMail:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:Encode()
    end
    return tb
end
function MsgType.OneMail:_detailListEncode()
    local tb = {}
    for i=1, #self.detailList do
        tb[i] = self.detailList[i]:Encode()
    end
    return tb
end
function MsgType.OneMail:Encode()
    local tb = {}
    if nil ~= self.mailId and 0 ~= self.mailId then
        tb.b = self.mailId
    end
    if nil ~= self.createTime and 0 ~= self.createTime then
        tb.c = self.createTime
    end
    if nil ~= self.expireTime and 0 ~= self.expireTime then
        tb.d = self.expireTime
    end
    if nil ~= self.mailStatus and 0 ~= self.mailStatus then
        tb.e = self.mailStatus
    end
    tb.f = self:_itemListEncode()
    tb.g = self:_detailListEncode()
    return tb
end

function MsgType.OneMail:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.mailId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.createTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.expireTime = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.mailStatus = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.f[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpDetailListObj = MsgType.OneMailDetail:New()
            tmpDetailListObj:Decode(data.g[i])
            self.detailList[i] = tmpDetailListObj
        end
    end
    return self
end

function MsgType.OneMail:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneMail:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Mail_List = {
    msgSeq = 0,
    mailId = 0
}
MsgType.Request_Mail_List.__index = MsgType.Request_Mail_List

function MsgType.Request_Mail_List:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Mail_List:GetCmd()
    return MsgTypeCmd.Request_Mail_List_Cmd
end
function MsgType.Request_Mail_List:GetUrl()
    return "Request_Mail_List"
end
function MsgType.Request_Mail_List:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.mailId and 0 ~= self.mailId then
        tb.c = self.mailId
    end
    return tb
end

function MsgType.Request_Mail_List:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Mail_List:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Mail_List = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    mailList = {} -- array of MsgType.OneMail
}
MsgType.Response_Mail_List.__index = MsgType.Response_Mail_List

function MsgType.Response_Mail_List:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.mailList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Mail_List:GetCmd()
    return MsgTypeCmd.Response_Mail_List_Cmd
end
function MsgType.Response_Mail_List:GetUrl()
    return "Response_Mail_List"
end
function MsgType.Response_Mail_List:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpMailListObj = MsgType.OneMail:New()
            tmpMailListObj:Decode(data.f[i])
            self.mailList[i] = tmpMailListObj
        end
    end
    return self
end


MsgType.Request_Mail_Read = {
    msgSeq = 0,
    mailId = 0
}
MsgType.Request_Mail_Read.__index = MsgType.Request_Mail_Read

function MsgType.Request_Mail_Read:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Mail_Read:GetCmd()
    return MsgTypeCmd.Request_Mail_Read_Cmd
end
function MsgType.Request_Mail_Read:GetUrl()
    return "Request_Mail_Read"
end
function MsgType.Request_Mail_Read:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.mailId and 0 ~= self.mailId then
        tb.c = self.mailId
    end
    return tb
end

function MsgType.Request_Mail_Read:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Mail_Read:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Mail_Read = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    mailId = 0
}
MsgType.Response_Mail_Read.__index = MsgType.Response_Mail_Read

function MsgType.Response_Mail_Read:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Mail_Read:GetCmd()
    return MsgTypeCmd.Response_Mail_Read_Cmd
end
function MsgType.Response_Mail_Read:GetUrl()
    return "Response_Mail_Read"
end
function MsgType.Response_Mail_Read:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.mailId = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_Mail_Claimed = {
    msgSeq = 0,
    mailId = 0
}
MsgType.Request_Mail_Claimed.__index = MsgType.Request_Mail_Claimed

function MsgType.Request_Mail_Claimed:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Mail_Claimed:GetCmd()
    return MsgTypeCmd.Request_Mail_Claimed_Cmd
end
function MsgType.Request_Mail_Claimed:GetUrl()
    return "Request_Mail_Claimed"
end
function MsgType.Request_Mail_Claimed:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.mailId and 0 ~= self.mailId then
        tb.c = self.mailId
    end
    return tb
end

function MsgType.Request_Mail_Claimed:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Mail_Claimed:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Mail_Claimed = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    mailList = {}, -- array of MsgType.OneMail
    itemList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_Mail_Claimed.__index = MsgType.Response_Mail_Claimed

function MsgType.Response_Mail_Claimed:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.mailList = {}
    tb.itemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Mail_Claimed:GetCmd()
    return MsgTypeCmd.Response_Mail_Claimed_Cmd
end
function MsgType.Response_Mail_Claimed:GetUrl()
    return "Response_Mail_Claimed"
end
function MsgType.Response_Mail_Claimed:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpMailListObj = MsgType.OneMail:New()
            tmpMailListObj:Decode(data.f[i])
            self.mailList[i] = tmpMailListObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.g[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    return self
end


MsgType.Request_Mail_Delete = {
    msgSeq = 0,
    mailId = 0
}
MsgType.Request_Mail_Delete.__index = MsgType.Request_Mail_Delete

function MsgType.Request_Mail_Delete:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Mail_Delete:GetCmd()
    return MsgTypeCmd.Request_Mail_Delete_Cmd
end
function MsgType.Request_Mail_Delete:GetUrl()
    return "Request_Mail_Delete"
end
function MsgType.Request_Mail_Delete:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.mailId and 0 ~= self.mailId then
        tb.c = self.mailId
    end
    return tb
end

function MsgType.Request_Mail_Delete:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Mail_Delete:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Mail_Delete = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    mailId = 0
}
MsgType.Response_Mail_Delete.__index = MsgType.Response_Mail_Delete

function MsgType.Response_Mail_Delete:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Mail_Delete:GetCmd()
    return MsgTypeCmd.Response_Mail_Delete_Cmd
end
function MsgType.Response_Mail_Delete:GetUrl()
    return "Response_Mail_Delete"
end
function MsgType.Response_Mail_Delete:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.mailId = tonumber(data.f) or 0
    end
    return self
end


MsgType.Request_Mail_Feedback = {
    msgSeq = 0,
    osType = 0, --enum EOsType
    ver = "",
    feedback = ""
}
MsgType.Request_Mail_Feedback.__index = MsgType.Request_Mail_Feedback

function MsgType.Request_Mail_Feedback:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Mail_Feedback:GetCmd()
    return MsgTypeCmd.Request_Mail_Feedback_Cmd
end
function MsgType.Request_Mail_Feedback:GetUrl()
    return "Request_Mail_Feedback"
end
function MsgType.Request_Mail_Feedback:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.osType and 0 ~= self.osType then
        tb.c = self.osType
    end
    if nil ~= self.ver and string.len(self.ver) > 0 then
        tb.d = self.ver
    end
    if nil ~= self.feedback and string.len(self.feedback) > 0 then
        tb.e = self.feedback
    end
    return tb
end

function MsgType.Request_Mail_Feedback:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Mail_Feedback:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Mail_Feedback = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Mail_Feedback.__index = MsgType.Response_Mail_Feedback

function MsgType.Response_Mail_Feedback:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Mail_Feedback:GetCmd()
    return MsgTypeCmd.Response_Mail_Feedback_Cmd
end
function MsgType.Response_Mail_Feedback:GetUrl()
    return "Response_Mail_Feedback"
end
function MsgType.Response_Mail_Feedback:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.DailyGift = {
    opening = 0,
    nextTime = 0,
    id = 0,
    itemType = 0, --enum EItemType
    itemId = 0,
    count = 0,
    nextId = 0,
    totalGiftCount = 0,
    rewardList = {} -- array of MsgType.OneRewardItem
}
MsgType.DailyGift.__index = MsgType.DailyGift

function MsgType.DailyGift:New()
    local tb = {}
    setmetatable(tb, self)
    tb.rewardList = {}
    return tb
end

function MsgType.DailyGift:_rewardListEncode()
    local tb = {}
    for i=1, #self.rewardList do
        tb[i] = self.rewardList[i]:Encode()
    end
    return tb
end
function MsgType.DailyGift:Encode()
    local tb = {}
    if nil ~= self.opening and 0 ~= self.opening then
        tb.b = self.opening
    end
    if nil ~= self.nextTime and 0 ~= self.nextTime then
        tb.c = self.nextTime
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.d = self.id
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.e = self.itemType
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.f = self.itemId
    end
    if nil ~= self.count and 0 ~= self.count then
        tb.g = self.count
    end
    if nil ~= self.nextId and 0 ~= self.nextId then
        tb.h = self.nextId
    end
    if nil ~= self.totalGiftCount and 0 ~= self.totalGiftCount then
        tb.i = self.totalGiftCount
    end
    tb.j = self:_rewardListEncode()
    return tb
end

function MsgType.DailyGift:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.opening = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.nextTime = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.id = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.itemType = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.itemId = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.count = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.nextId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.totalGiftCount = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.j[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end

function MsgType.DailyGift:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.DailyGift:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Activity_List = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Activity_List.__index = MsgType.Request_Activity_List

function MsgType.Request_Activity_List:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_List:GetCmd()
    return MsgTypeCmd.Request_Activity_List_Cmd
end
function MsgType.Request_Activity_List:GetUrl()
    return "Request_Activity_List"
end
function MsgType.Request_Activity_List:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Activity_List:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_List:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_List = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    dailyGift = {}
}
MsgType.Response_Activity_List.__index = MsgType.Response_Activity_List
setmetatable(MsgType.Response_Activity_List.dailyGift, MsgType.DailyGift)

function MsgType.Response_Activity_List:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.dailyGift = MsgType.DailyGift:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_List:GetCmd()
    return MsgTypeCmd.Response_Activity_List_Cmd
end
function MsgType.Response_Activity_List:GetUrl()
    return "Response_Activity_List"
end
function MsgType.Response_Activity_List:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.dailyGift:Decode(data.f)
    end
    return self
end


MsgType.Request_Activity_DailyGiftReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Activity_DailyGiftReward.__index = MsgType.Request_Activity_DailyGiftReward

function MsgType.Request_Activity_DailyGiftReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_DailyGiftReward:GetCmd()
    return MsgTypeCmd.Request_Activity_DailyGiftReward_Cmd
end
function MsgType.Request_Activity_DailyGiftReward:GetUrl()
    return "Request_Activity_DailyGiftReward"
end
function MsgType.Request_Activity_DailyGiftReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Activity_DailyGiftReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_DailyGiftReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_DailyGiftReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    itemList = {}, -- array of MsgType.OneRewardItem
    dailyGift = {}
}
MsgType.Response_Activity_DailyGiftReward.__index = MsgType.Response_Activity_DailyGiftReward
setmetatable(MsgType.Response_Activity_DailyGiftReward.dailyGift, MsgType.DailyGift)

function MsgType.Response_Activity_DailyGiftReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.itemList = {}
    tb.dailyGift = MsgType.DailyGift:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_DailyGiftReward:GetCmd()
    return MsgTypeCmd.Response_Activity_DailyGiftReward_Cmd
end
function MsgType.Response_Activity_DailyGiftReward:GetUrl()
    return "Response_Activity_DailyGiftReward"
end
function MsgType.Response_Activity_DailyGiftReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.f[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.g then
        self.dailyGift:Decode(data.g)
    end
    return self
end


MsgType.ESevenDayTaskType = {
    EarnGold = 1,
    MakeItem = 2,
    UnlockEquip = 3,
    GetLayout = 4,
    EquipLevelUnlock = 5,
    EquipMastered = 6,
    BuyFurniture = 7,
    LevelUpFurniture = 8,
    ExploreShop = 9,
    UnionType = 10,
    LevelUpScience = 11,
    LevelUpBuilding = 12,
    BuildingLevel = 13,
    HireHero = 14,
    HeroChangeJob = 15,
    HeroRare = 16,
    HeroEquipRare = 17,
    LevelUpExplore = 18,
    ExploreClear = 19,
    SlotExplore = 20,
    PlayerLevelUp = 21,
    ChestBoxOpen = 22,
    ReputationRaise = 23,
    MarketDeal = 24,
    EnergyRaise = 25,
    ExploreCount = 26,
    SoldEquip = 27,
    SoldEquipRaisePrice = 28,
    EquipExchange = 29,
    HeroLevelCount = 30
}

MsgType.ESevenDayTaskState = {
    NotUnlock = 0,
    Doing = 1,
    CanReward = 2,
    Rewarded = 3,
    VIPRewarded = 4
}

MsgType.OneDayTask = {
    id = 0,
    param = 0,
    limit = 0,
    state = 0, --enum ESevenDayTaskState
    reward1Id = 0,
    reward2Id = 0,
    reward3Id = 0
}
MsgType.OneDayTask.__index = MsgType.OneDayTask

function MsgType.OneDayTask:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneDayTask:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.param and 0 ~= self.param then
        tb.c = self.param
    end
    if nil ~= self.limit and 0 ~= self.limit then
        tb.d = self.limit
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.e = self.state
    end
    if nil ~= self.reward1Id and 0 ~= self.reward1Id then
        tb.f = self.reward1Id
    end
    if nil ~= self.reward2Id and 0 ~= self.reward2Id then
        tb.g = self.reward2Id
    end
    if nil ~= self.reward3Id and 0 ~= self.reward3Id then
        tb.h = self.reward3Id
    end
    return tb
end

function MsgType.OneDayTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.param = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.limit = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.state = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.reward1Id = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.reward2Id = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.reward3Id = tonumber(data.h) or 0
    end
    return self
end

function MsgType.OneDayTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneDayTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.SevenDayTask = {
    taskListId = 0,
    taskListState = 0, --enum ESevenDayTaskState
    taskListRewardId = 0,
    taskList = {} -- array of MsgType.OneDayTask
}
MsgType.SevenDayTask.__index = MsgType.SevenDayTask

function MsgType.SevenDayTask:New()
    local tb = {}
    setmetatable(tb, self)
    tb.taskList = {}
    return tb
end

function MsgType.SevenDayTask:_taskListEncode()
    local tb = {}
    for i=1, #self.taskList do
        tb[i] = self.taskList[i]:Encode()
    end
    return tb
end
function MsgType.SevenDayTask:Encode()
    local tb = {}
    if nil ~= self.taskListId and 0 ~= self.taskListId then
        tb.b = self.taskListId
    end
    if nil ~= self.taskListState and 0 ~= self.taskListState then
        tb.c = self.taskListState
    end
    if nil ~= self.taskListRewardId and 0 ~= self.taskListRewardId then
        tb.d = self.taskListRewardId
    end
    tb.e = self:_taskListEncode()
    return tb
end

function MsgType.SevenDayTask:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.taskListId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.taskListState = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.taskListRewardId = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpTaskListObj = MsgType.OneDayTask:New()
            tmpTaskListObj:Decode(data.e[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    return self
end

function MsgType.SevenDayTask:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.SevenDayTask:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.EPayActivityType = {
    GeneralPurchase = 1,
    DirectPurchase = 2,
    DailySale = 3,
    VipPurchase = 4,
    OperatingActivityPurchase = 5,
    ShopperLevelPurchase = 6,
    SevenDayPurchase = 7,
    GoldVipPurchase = 8,
    PointActivityPurchase = 9
}

MsgType.PayProduct = {
    priceId = 0,
    monetaryUnit = "",
    money = 0,
    productId = "",
    payActivityType = 0, --enum EPayActivityType
    payActivityId = 0
}
MsgType.PayProduct.__index = MsgType.PayProduct

function MsgType.PayProduct:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.PayProduct:Encode()
    local tb = {}
    if nil ~= self.priceId and 0 ~= self.priceId then
        tb.b = self.priceId
    end
    if nil ~= self.monetaryUnit and string.len(self.monetaryUnit) > 0 then
        tb.c = self.monetaryUnit
    end
    if nil ~= self.money and 0 ~= self.money then
        tb.d = self.money
    end
    if nil ~= self.productId and string.len(self.productId) > 0 then
        tb.e = self.productId
    end
    if nil ~= self.payActivityType and 0 ~= self.payActivityType then
        tb.f = self.payActivityType
    end
    if nil ~= self.payActivityId and 0 ~= self.payActivityId then
        tb.g = self.payActivityId
    end
    return tb
end

function MsgType.PayProduct:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.priceId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.monetaryUnit = tostring(data.c)
    end
    if nil ~= data.d then
        self.money = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.productId = tostring(data.e)
    end
    if nil ~= data.f then
        self.payActivityType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.payActivityId = tonumber(data.g) or 0
    end
    return self
end

function MsgType.PayProduct:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.PayProduct:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Activity_SevenDayCheck = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Activity_SevenDayCheck.__index = MsgType.Request_Activity_SevenDayCheck

function MsgType.Request_Activity_SevenDayCheck:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_SevenDayCheck:GetCmd()
    return MsgTypeCmd.Request_Activity_SevenDayCheck_Cmd
end
function MsgType.Request_Activity_SevenDayCheck:GetUrl()
    return "Request_Activity_SevenDayCheck"
end
function MsgType.Request_Activity_SevenDayCheck:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Activity_SevenDayCheck:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_SevenDayCheck:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_SevenDayCheck = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    sevenDayList = {}, -- array of MsgType.SevenDayTask
    refreshTime = 0,
    nowDay = 0,
    sevenDayFlag = 0,
    payProduct = {}
}
MsgType.Response_Activity_SevenDayCheck.__index = MsgType.Response_Activity_SevenDayCheck
setmetatable(MsgType.Response_Activity_SevenDayCheck.payProduct, MsgType.PayProduct)

function MsgType.Response_Activity_SevenDayCheck:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.sevenDayList = {}
    tb.payProduct = MsgType.PayProduct:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_SevenDayCheck:GetCmd()
    return MsgTypeCmd.Response_Activity_SevenDayCheck_Cmd
end
function MsgType.Response_Activity_SevenDayCheck:GetUrl()
    return "Response_Activity_SevenDayCheck"
end
function MsgType.Response_Activity_SevenDayCheck:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpSevenDayListObj = MsgType.SevenDayTask:New()
            tmpSevenDayListObj:Decode(data.f[i])
            self.sevenDayList[i] = tmpSevenDayListObj
        end
    end
    if nil ~= data.g then
        self.refreshTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.nowDay = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.sevenDayFlag = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.payProduct:Decode(data.j)
    end
    return self
end


MsgType.Request_Activity_SevenDayReward = {
    msgSeq = 0,
    sevenDayTaskId = 0
}
MsgType.Request_Activity_SevenDayReward.__index = MsgType.Request_Activity_SevenDayReward

function MsgType.Request_Activity_SevenDayReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_SevenDayReward:GetCmd()
    return MsgTypeCmd.Request_Activity_SevenDayReward_Cmd
end
function MsgType.Request_Activity_SevenDayReward:GetUrl()
    return "Request_Activity_SevenDayReward"
end
function MsgType.Request_Activity_SevenDayReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.sevenDayTaskId and 0 ~= self.sevenDayTaskId then
        tb.c = self.sevenDayTaskId
    end
    return tb
end

function MsgType.Request_Activity_SevenDayReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_SevenDayReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_SevenDayReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    sevenDayTask = {},
    rewardItemList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_Activity_SevenDayReward.__index = MsgType.Response_Activity_SevenDayReward
setmetatable(MsgType.Response_Activity_SevenDayReward.sevenDayTask, MsgType.OneDayTask)

function MsgType.Response_Activity_SevenDayReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.sevenDayTask = MsgType.OneDayTask:New()
    tb.rewardItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_SevenDayReward:GetCmd()
    return MsgTypeCmd.Response_Activity_SevenDayReward_Cmd
end
function MsgType.Response_Activity_SevenDayReward:GetUrl()
    return "Response_Activity_SevenDayReward"
end
function MsgType.Response_Activity_SevenDayReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.sevenDayTask:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardItemListObj = MsgType.OneRewardItem:New()
            tmpRewardItemListObj:Decode(data.g[i])
            self.rewardItemList[i] = tmpRewardItemListObj
        end
    end
    return self
end


MsgType.Request_Activity_SevenDayListReward = {
    msgSeq = 0,
    sevenDayListId = 0
}
MsgType.Request_Activity_SevenDayListReward.__index = MsgType.Request_Activity_SevenDayListReward

function MsgType.Request_Activity_SevenDayListReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_SevenDayListReward:GetCmd()
    return MsgTypeCmd.Request_Activity_SevenDayListReward_Cmd
end
function MsgType.Request_Activity_SevenDayListReward:GetUrl()
    return "Request_Activity_SevenDayListReward"
end
function MsgType.Request_Activity_SevenDayListReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.sevenDayListId and 0 ~= self.sevenDayListId then
        tb.c = self.sevenDayListId
    end
    return tb
end

function MsgType.Request_Activity_SevenDayListReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_SevenDayListReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_SevenDayListReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    sevenDayInfo = {},
    rewardItemList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_Activity_SevenDayListReward.__index = MsgType.Response_Activity_SevenDayListReward
setmetatable(MsgType.Response_Activity_SevenDayListReward.sevenDayInfo, MsgType.SevenDayTask)

function MsgType.Response_Activity_SevenDayListReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.sevenDayInfo = MsgType.SevenDayTask:New()
    tb.rewardItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_SevenDayListReward:GetCmd()
    return MsgTypeCmd.Response_Activity_SevenDayListReward_Cmd
end
function MsgType.Response_Activity_SevenDayListReward:GetUrl()
    return "Response_Activity_SevenDayListReward"
end
function MsgType.Response_Activity_SevenDayListReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.sevenDayInfo:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardItemListObj = MsgType.OneRewardItem:New()
            tmpRewardItemListObj:Decode(data.g[i])
            self.rewardItemList[i] = tmpRewardItemListObj
        end
    end
    return self
end


MsgType.Response_Activity_SevenDayChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    sevenDayTaskList = {}, -- array of MsgType.OneDayTask
    sevenDayFlag = 0
}
MsgType.Response_Activity_SevenDayChange.__index = MsgType.Response_Activity_SevenDayChange

function MsgType.Response_Activity_SevenDayChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.sevenDayTaskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_SevenDayChange:GetCmd()
    return MsgTypeCmd.Response_Activity_SevenDayChange_Cmd
end
function MsgType.Response_Activity_SevenDayChange:GetUrl()
    return "Response_Activity_SevenDayChange"
end
function MsgType.Response_Activity_SevenDayChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpSevenDayTaskListObj = MsgType.OneDayTask:New()
            tmpSevenDayTaskListObj:Decode(data.f[i])
            self.sevenDayTaskList[i] = tmpSevenDayTaskListObj
        end
    end
    if nil ~= data.g then
        self.sevenDayFlag = tonumber(data.g) or 0
    end
    return self
end


MsgType.Response_Activity_SevenDayListChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    sevenDayTaskList = {}
}
MsgType.Response_Activity_SevenDayListChange.__index = MsgType.Response_Activity_SevenDayListChange
setmetatable(MsgType.Response_Activity_SevenDayListChange.sevenDayTaskList, MsgType.SevenDayTask)

function MsgType.Response_Activity_SevenDayListChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.sevenDayTaskList = MsgType.SevenDayTask:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_SevenDayListChange:GetCmd()
    return MsgTypeCmd.Response_Activity_SevenDayListChange_Cmd
end
function MsgType.Response_Activity_SevenDayListChange:GetUrl()
    return "Response_Activity_SevenDayListChange"
end
function MsgType.Response_Activity_SevenDayListChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.sevenDayTaskList:Decode(data.f)
    end
    return self
end


MsgType.EActivityBuffType = {
    EquipMoneyUp = 1,
    ShopOwnerExpUp = 2,
    EnergyRaiseUp = 3,
    EquipRaiseMoneyUp = 4,
    MakeSpeedUp = 5,
    EquipPropUp = 6,
    ResourceSpeedUp = 7,
    ExploreSpeedUp = 8,
    HeroHealSpeedUp = 9,
    ExploreDropUp = 10,
    ExploreExpUp = 11,
    RefreshBarHighRankHeroUp = 12,
    ChestBoxItemRateUp = 13
}

MsgType.EActivityBuffState = {
    None = 0,
    Doing = 1,
    Done = 2
}

MsgType.ActivityBuffText = {
    lang = 0,
    buffTitle = "",
    buffTitle1 = "",
    buffTitle2 = "",
    buffText = "",
    buffConform = "",
    buffHerald = ""
}
MsgType.ActivityBuffText.__index = MsgType.ActivityBuffText

function MsgType.ActivityBuffText:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.ActivityBuffText:Encode()
    local tb = {}
    if nil ~= self.lang and 0 ~= self.lang then
        tb.b = self.lang
    end
    if nil ~= self.buffTitle and string.len(self.buffTitle) > 0 then
        tb.c = self.buffTitle
    end
    if nil ~= self.buffTitle1 and string.len(self.buffTitle1) > 0 then
        tb.d = self.buffTitle1
    end
    if nil ~= self.buffTitle2 and string.len(self.buffTitle2) > 0 then
        tb.e = self.buffTitle2
    end
    if nil ~= self.buffText and string.len(self.buffText) > 0 then
        tb.f = self.buffText
    end
    if nil ~= self.buffConform and string.len(self.buffConform) > 0 then
        tb.g = self.buffConform
    end
    if nil ~= self.buffHerald and string.len(self.buffHerald) > 0 then
        tb.h = self.buffHerald
    end
    return tb
end

function MsgType.ActivityBuffText:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.lang = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.buffTitle = tostring(data.c)
    end
    if nil ~= data.d then
        self.buffTitle1 = tostring(data.d)
    end
    if nil ~= data.e then
        self.buffTitle2 = tostring(data.e)
    end
    if nil ~= data.f then
        self.buffText = tostring(data.f)
    end
    if nil ~= data.g then
        self.buffConform = tostring(data.g)
    end
    if nil ~= data.h then
        self.buffHerald = tostring(data.h)
    end
    return self
end

function MsgType.ActivityBuffText:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ActivityBuffText:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.ActivityBuff = {
    buffId = 0,
    buffType = 0, --enum EActivityBuffType
    buffParam = 0,
    startTime = 0,
    endTime = 0,
    buffState = 0, --enum EActivityBuffState
    activityTime = 0,
    textList = {} -- array of MsgType.ActivityBuffText
}
MsgType.ActivityBuff.__index = MsgType.ActivityBuff

function MsgType.ActivityBuff:New()
    local tb = {}
    setmetatable(tb, self)
    tb.textList = {}
    return tb
end

function MsgType.ActivityBuff:_textListEncode()
    local tb = {}
    for i=1, #self.textList do
        tb[i] = self.textList[i]:Encode()
    end
    return tb
end
function MsgType.ActivityBuff:Encode()
    local tb = {}
    if nil ~= self.buffId and 0 ~= self.buffId then
        tb.b = self.buffId
    end
    if nil ~= self.buffType and 0 ~= self.buffType then
        tb.c = self.buffType
    end
    if nil ~= self.buffParam and 0 ~= self.buffParam then
        tb.d = self.buffParam
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.e = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.f = self.endTime
    end
    if nil ~= self.buffState and 0 ~= self.buffState then
        tb.g = self.buffState
    end
    if nil ~= self.activityTime and 0 ~= self.activityTime then
        tb.h = self.activityTime
    end
    tb.i = self:_textListEncode()
    return tb
end

function MsgType.ActivityBuff:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.buffId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.buffType = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.buffParam = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.startTime = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.endTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.buffState = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.activityTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpTextListObj = MsgType.ActivityBuffText:New()
            tmpTextListObj:Decode(data.i[i])
            self.textList[i] = tmpTextListObj
        end
    end
    return self
end

function MsgType.ActivityBuff:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.ActivityBuff:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_Buff_Info = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityBuffList = {}, -- array of MsgType.ActivityBuff
    uid = 0
}
MsgType.Response_Activity_Buff_Info.__index = MsgType.Response_Activity_Buff_Info

function MsgType.Response_Activity_Buff_Info:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.activityBuffList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_Buff_Info:GetCmd()
    return MsgTypeCmd.Response_Activity_Buff_Info_Cmd
end
function MsgType.Response_Activity_Buff_Info:GetUrl()
    return "Response_Activity_Buff_Info"
end
function MsgType.Response_Activity_Buff_Info:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpActivityBuffListObj = MsgType.ActivityBuff:New()
            tmpActivityBuffListObj:Decode(data.f[i])
            self.activityBuffList[i] = tmpActivityBuffListObj
        end
    end
    if nil ~= data.g then
        self.uid = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Activity_Buff_Refresh = {
    msgSeq = 0,
    uid = 0
}
MsgType.Request_Activity_Buff_Refresh.__index = MsgType.Request_Activity_Buff_Refresh

function MsgType.Request_Activity_Buff_Refresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_Buff_Refresh:GetCmd()
    return MsgTypeCmd.Request_Activity_Buff_Refresh_Cmd
end
function MsgType.Request_Activity_Buff_Refresh:GetUrl()
    return "Request_Activity_Buff_Refresh"
end
function MsgType.Request_Activity_Buff_Refresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.uid and 0 ~= self.uid then
        tb.c = self.uid
    end
    return tb
end

function MsgType.Request_Activity_Buff_Refresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_Buff_Refresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_Buff_Refresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityBuffList = {}, -- array of MsgType.ActivityBuff
    uid = 0
}
MsgType.Response_Activity_Buff_Refresh.__index = MsgType.Response_Activity_Buff_Refresh

function MsgType.Response_Activity_Buff_Refresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.activityBuffList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_Buff_Refresh:GetCmd()
    return MsgTypeCmd.Response_Activity_Buff_Refresh_Cmd
end
function MsgType.Response_Activity_Buff_Refresh:GetUrl()
    return "Response_Activity_Buff_Refresh"
end
function MsgType.Response_Activity_Buff_Refresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpActivityBuffListObj = MsgType.ActivityBuff:New()
            tmpActivityBuffListObj:Decode(data.f[i])
            self.activityBuffList[i] = tmpActivityBuffListObj
        end
    end
    if nil ~= data.g then
        self.uid = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Activity_Buff_Update = {
    msgSeq = 0,
    buffId = 0
}
MsgType.Request_Activity_Buff_Update.__index = MsgType.Request_Activity_Buff_Update

function MsgType.Request_Activity_Buff_Update:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_Buff_Update:GetCmd()
    return MsgTypeCmd.Request_Activity_Buff_Update_Cmd
end
function MsgType.Request_Activity_Buff_Update:GetUrl()
    return "Request_Activity_Buff_Update"
end
function MsgType.Request_Activity_Buff_Update:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.buffId and 0 ~= self.buffId then
        tb.c = self.buffId
    end
    return tb
end

function MsgType.Request_Activity_Buff_Update:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_Buff_Update:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_Buff_Update = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityBuff = {},
    uid = 0
}
MsgType.Response_Activity_Buff_Update.__index = MsgType.Response_Activity_Buff_Update
setmetatable(MsgType.Response_Activity_Buff_Update.activityBuff, MsgType.ActivityBuff)

function MsgType.Response_Activity_Buff_Update:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.activityBuff = MsgType.ActivityBuff:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_Buff_Update:GetCmd()
    return MsgTypeCmd.Response_Activity_Buff_Update_Cmd
end
function MsgType.Response_Activity_Buff_Update:GetUrl()
    return "Response_Activity_Buff_Update"
end
function MsgType.Response_Activity_Buff_Update:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityBuff:Decode(data.f)
    end
    if nil ~= data.g then
        self.uid = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Activity_Data = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Activity_Data.__index = MsgType.Request_Activity_Data

function MsgType.Request_Activity_Data:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_Data:GetCmd()
    return MsgTypeCmd.Request_Activity_Data_Cmd
end
function MsgType.Request_Activity_Data:GetUrl()
    return "Request_Activity_Data"
end
function MsgType.Request_Activity_Data:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Activity_Data:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_Data:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_Data = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroList = {}, -- array of MsgType.HeroInfo
    currentStageId = 0,
    enemyWaveId = 0,
    remainTime = 0,
    enemyRemainCount = 0,
    enemyRemainHp = 0
}
MsgType.Response_Activity_Data.__index = MsgType.Response_Activity_Data

function MsgType.Response_Activity_Data:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_Data:GetCmd()
    return MsgTypeCmd.Response_Activity_Data_Cmd
end
function MsgType.Response_Activity_Data:GetUrl()
    return "Response_Activity_Data"
end
function MsgType.Response_Activity_Data:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpHeroListObj = MsgType.HeroInfo:New()
            tmpHeroListObj:Decode(data.f[i])
            self.heroList[i] = tmpHeroListObj
        end
    end
    if nil ~= data.g then
        self.currentStageId = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.enemyWaveId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.remainTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.enemyRemainCount = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.enemyRemainHp = tonumber(data.k) or 0
    end
    return self
end


MsgType.Request_Activity_Battle = {
    msgSeq = 0,
    heroInfoUIds = ""
}
MsgType.Request_Activity_Battle.__index = MsgType.Request_Activity_Battle

function MsgType.Request_Activity_Battle:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Activity_Battle:GetCmd()
    return MsgTypeCmd.Request_Activity_Battle_Cmd
end
function MsgType.Request_Activity_Battle:GetUrl()
    return "Request_Activity_Battle"
end
function MsgType.Request_Activity_Battle:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroInfoUIds and string.len(self.heroInfoUIds) > 0 then
        tb.c = self.heroInfoUIds
    end
    return tb
end

function MsgType.Request_Activity_Battle:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Activity_Battle:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Activity_Battle = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroInfo = {}, -- array of MsgType.HeroInfo
    combatReport = {},
    rewardItemList = {}, -- array of MsgType.OneRewardItem
    currentStageId = 0,
    enemyWaveId = 0,
    startWaveId = 0,
    remainCount = 0,
    totalCount = 0
}
MsgType.Response_Activity_Battle.__index = MsgType.Response_Activity_Battle
setmetatable(MsgType.Response_Activity_Battle.combatReport, MsgType.CombatReport)

function MsgType.Response_Activity_Battle:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroInfo = {}
    tb.combatReport = MsgType.CombatReport:New()
    tb.rewardItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Activity_Battle:GetCmd()
    return MsgTypeCmd.Response_Activity_Battle_Cmd
end
function MsgType.Response_Activity_Battle:GetUrl()
    return "Response_Activity_Battle"
end
function MsgType.Response_Activity_Battle:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpHeroInfoObj = MsgType.HeroInfo:New()
            tmpHeroInfoObj:Decode(data.f[i])
            self.heroInfo[i] = tmpHeroInfoObj
        end
    end
    if nil ~= data.g then
        self.combatReport:Decode(data.g)
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpRewardItemListObj = MsgType.OneRewardItem:New()
            tmpRewardItemListObj:Decode(data.h[i])
            self.rewardItemList[i] = tmpRewardItemListObj
        end
    end
    if nil ~= data.i then
        self.currentStageId = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.enemyWaveId = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.startWaveId = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.remainCount = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.totalCount = tonumber(data.m) or 0
    end
    return self
end


MsgType.OneRubbish = {
    rubbishId = 0,
    item = {}
}
MsgType.OneRubbish.__index = MsgType.OneRubbish
setmetatable(MsgType.OneRubbish.item, MsgType.OneRewardItem)

function MsgType.OneRubbish:New()
    local tb = {}
    setmetatable(tb, self)
    tb.item = MsgType.OneRewardItem:New()
    return tb
end

function MsgType.OneRubbish:Encode()
    local tb = {}
    if nil ~= self.rubbishId and 0 ~= self.rubbishId then
        tb.b = self.rubbishId
    end
    tb.c = self.item:Encode()
    return tb
end

function MsgType.OneRubbish:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.rubbishId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.item:Decode(data.c)
    end
    return self
end

function MsgType.OneRubbish:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneRubbish:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.RubbishList = {
    rubbishList = {} -- array of MsgType.OneRubbish
}
MsgType.RubbishList.__index = MsgType.RubbishList

function MsgType.RubbishList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.rubbishList = {}
    return tb
end

function MsgType.RubbishList:_rubbishListEncode()
    local tb = {}
    for i=1, #self.rubbishList do
        tb[i] = self.rubbishList[i]:Encode()
    end
    return tb
end
function MsgType.RubbishList:Encode()
    local tb = {}
    tb.b = self:_rubbishListEncode()
    return tb
end

function MsgType.RubbishList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpRubbishListObj = MsgType.OneRubbish:New()
            tmpRubbishListObj:Decode(data.b[i])
            self.rubbishList[i] = tmpRubbishListObj
        end
    end
    return self
end

function MsgType.RubbishList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.RubbishList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Rubbish_List = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    nextRefreshTime = 0,
    rubbishList = {}
}
MsgType.Response_Rubbish_List.__index = MsgType.Response_Rubbish_List
setmetatable(MsgType.Response_Rubbish_List.rubbishList, MsgType.RubbishList)

function MsgType.Response_Rubbish_List:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rubbishList = MsgType.RubbishList:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Rubbish_List:GetCmd()
    return MsgTypeCmd.Response_Rubbish_List_Cmd
end
function MsgType.Response_Rubbish_List:GetUrl()
    return "Response_Rubbish_List"
end
function MsgType.Response_Rubbish_List:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.nextRefreshTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.rubbishList:Decode(data.g)
    end
    return self
end


MsgType.Request_Rubbish_Refresh = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Rubbish_Refresh.__index = MsgType.Request_Rubbish_Refresh

function MsgType.Request_Rubbish_Refresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Rubbish_Refresh:GetCmd()
    return MsgTypeCmd.Request_Rubbish_Refresh_Cmd
end
function MsgType.Request_Rubbish_Refresh:GetUrl()
    return "Request_Rubbish_Refresh"
end
function MsgType.Request_Rubbish_Refresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Rubbish_Refresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Rubbish_Refresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Rubbish_Refresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    nextRefreshTime = 0,
    oneRubbish = {}
}
MsgType.Response_Rubbish_Refresh.__index = MsgType.Response_Rubbish_Refresh
setmetatable(MsgType.Response_Rubbish_Refresh.oneRubbish, MsgType.OneRubbish)

function MsgType.Response_Rubbish_Refresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.oneRubbish = MsgType.OneRubbish:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Rubbish_Refresh:GetCmd()
    return MsgTypeCmd.Response_Rubbish_Refresh_Cmd
end
function MsgType.Response_Rubbish_Refresh:GetUrl()
    return "Response_Rubbish_Refresh"
end
function MsgType.Response_Rubbish_Refresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.nextRefreshTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.oneRubbish:Decode(data.g)
    end
    return self
end


MsgType.Request_Rubbish_Claimed = {
    msgSeq = 0,
    rubbishId = 0
}
MsgType.Request_Rubbish_Claimed.__index = MsgType.Request_Rubbish_Claimed

function MsgType.Request_Rubbish_Claimed:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Rubbish_Claimed:GetCmd()
    return MsgTypeCmd.Request_Rubbish_Claimed_Cmd
end
function MsgType.Request_Rubbish_Claimed:GetUrl()
    return "Request_Rubbish_Claimed"
end
function MsgType.Request_Rubbish_Claimed:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rubbishId and 0 ~= self.rubbishId then
        tb.c = self.rubbishId
    end
    return tb
end

function MsgType.Request_Rubbish_Claimed:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Rubbish_Claimed:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Rubbish_Claimed = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    nextRefreshTime = 0,
    oneRubbish = {}
}
MsgType.Response_Rubbish_Claimed.__index = MsgType.Response_Rubbish_Claimed
setmetatable(MsgType.Response_Rubbish_Claimed.oneRubbish, MsgType.OneRubbish)

function MsgType.Response_Rubbish_Claimed:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.oneRubbish = MsgType.OneRubbish:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Rubbish_Claimed:GetCmd()
    return MsgTypeCmd.Response_Rubbish_Claimed_Cmd
end
function MsgType.Response_Rubbish_Claimed:GetUrl()
    return "Response_Rubbish_Claimed"
end
function MsgType.Response_Rubbish_Claimed:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.nextRefreshTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.oneRubbish:Decode(data.g)
    end
    return self
end


MsgType.Request_Pay_Order = {
    msgSeq = 0,
    platform = 0, --enum EPlatform
    priceId = 0,
    payActivityType = 0, --enum EPayActivityType
    payActivityId = 0
}
MsgType.Request_Pay_Order.__index = MsgType.Request_Pay_Order

function MsgType.Request_Pay_Order:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_Order:GetCmd()
    return MsgTypeCmd.Request_Pay_Order_Cmd
end
function MsgType.Request_Pay_Order:GetUrl()
    return "Request_Pay_Order"
end
function MsgType.Request_Pay_Order:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.platform and 0 ~= self.platform then
        tb.c = self.platform
    end
    if nil ~= self.priceId and 0 ~= self.priceId then
        tb.d = self.priceId
    end
    if nil ~= self.payActivityType and 0 ~= self.payActivityType then
        tb.e = self.payActivityType
    end
    if nil ~= self.payActivityId and 0 ~= self.payActivityId then
        tb.f = self.payActivityId
    end
    return tb
end

function MsgType.Request_Pay_Order:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_Order:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_Order = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    gameOrderId = "",
    payload = "",
    productId = "",
    productName = "",
    productDesc = "",
    amount = 0,
    payType = ""
}
MsgType.Response_Pay_Order.__index = MsgType.Response_Pay_Order

function MsgType.Response_Pay_Order:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_Order:GetCmd()
    return MsgTypeCmd.Response_Pay_Order_Cmd
end
function MsgType.Response_Pay_Order:GetUrl()
    return "Response_Pay_Order"
end
function MsgType.Response_Pay_Order:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.gameOrderId = tostring(data.f)
    end
    if nil ~= data.g then
        self.payload = tostring(data.g)
    end
    if nil ~= data.h then
        self.productId = tostring(data.h)
    end
    if nil ~= data.i then
        self.productName = tostring(data.i)
    end
    if nil ~= data.j then
        self.productDesc = tostring(data.j)
    end
    if nil ~= data.k then
        self.amount = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.payType = tostring(data.l)
    end
    return self
end


MsgType.Request_Pay_Balance = {
    msgSeq = 0,
    platform = 0, --enum EPlatform
    gameOrderId = "",
    thirdOrderId = "",
    purchase = "",
    productId = ""
}
MsgType.Request_Pay_Balance.__index = MsgType.Request_Pay_Balance

function MsgType.Request_Pay_Balance:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_Balance:GetCmd()
    return MsgTypeCmd.Request_Pay_Balance_Cmd
end
function MsgType.Request_Pay_Balance:GetUrl()
    return "Request_Pay_Balance"
end
function MsgType.Request_Pay_Balance:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.platform and 0 ~= self.platform then
        tb.c = self.platform
    end
    if nil ~= self.gameOrderId and string.len(self.gameOrderId) > 0 then
        tb.d = self.gameOrderId
    end
    if nil ~= self.thirdOrderId and string.len(self.thirdOrderId) > 0 then
        tb.e = self.thirdOrderId
    end
    if nil ~= self.purchase and string.len(self.purchase) > 0 then
        tb.f = self.purchase
    end
    if nil ~= self.productId and string.len(self.productId) > 0 then
        tb.g = self.productId
    end
    return tb
end

function MsgType.Request_Pay_Balance:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_Balance:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_Balance = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    gameOrderId = "",
    thirdOrderId = "",
    productId = "",
    purchase = "",
    itemList = {}, -- array of MsgType.OneRewardItem
    pic1 = "",
    pic2 = "",
    tag = ""
}
MsgType.Response_Pay_Balance.__index = MsgType.Response_Pay_Balance

function MsgType.Response_Pay_Balance:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.itemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_Balance:GetCmd()
    return MsgTypeCmd.Response_Pay_Balance_Cmd
end
function MsgType.Response_Pay_Balance:GetUrl()
    return "Response_Pay_Balance"
end
function MsgType.Response_Pay_Balance:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.gameOrderId = tostring(data.f)
    end
    if nil ~= data.g then
        self.thirdOrderId = tostring(data.g)
    end
    if nil ~= data.h then
        self.productId = tostring(data.h)
    end
    if nil ~= data.i then
        self.purchase = tostring(data.i)
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.j[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.k then
        self.pic1 = tostring(data.k)
    end
    if nil ~= data.l then
        self.pic2 = tostring(data.l)
    end
    if nil ~= data.m then
        self.tag = tostring(data.m)
    end
    return self
end


MsgType.Request_Pay_IOSBuy = {
    msgSeq = 0,
    priceId = 0,
    payActivityType = 0, --enum EPayActivityType
    payActivityId = 0
}
MsgType.Request_Pay_IOSBuy.__index = MsgType.Request_Pay_IOSBuy

function MsgType.Request_Pay_IOSBuy:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_IOSBuy:GetCmd()
    return MsgTypeCmd.Request_Pay_IOSBuy_Cmd
end
function MsgType.Request_Pay_IOSBuy:GetUrl()
    return "Request_Pay_IOSBuy"
end
function MsgType.Request_Pay_IOSBuy:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.priceId and 0 ~= self.priceId then
        tb.c = self.priceId
    end
    if nil ~= self.payActivityType and 0 ~= self.payActivityType then
        tb.d = self.payActivityType
    end
    if nil ~= self.payActivityId and 0 ~= self.payActivityId then
        tb.e = self.payActivityId
    end
    return tb
end

function MsgType.Request_Pay_IOSBuy:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_IOSBuy:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_IOSBuy = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Pay_IOSBuy.__index = MsgType.Response_Pay_IOSBuy

function MsgType.Response_Pay_IOSBuy:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_IOSBuy:GetCmd()
    return MsgTypeCmd.Response_Pay_IOSBuy_Cmd
end
function MsgType.Response_Pay_IOSBuy:GetUrl()
    return "Response_Pay_IOSBuy"
end
function MsgType.Response_Pay_IOSBuy:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Pay_AmountCheck = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_AmountCheck.__index = MsgType.Request_Pay_AmountCheck

function MsgType.Request_Pay_AmountCheck:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_AmountCheck:GetCmd()
    return MsgTypeCmd.Request_Pay_AmountCheck_Cmd
end
function MsgType.Request_Pay_AmountCheck:GetUrl()
    return "Request_Pay_AmountCheck"
end
function MsgType.Request_Pay_AmountCheck:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_AmountCheck:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_AmountCheck:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_AmountCheck = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    amount = 0,
    index = 0,
    flag = 0
}
MsgType.Response_Pay_AmountCheck.__index = MsgType.Response_Pay_AmountCheck

function MsgType.Response_Pay_AmountCheck:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_AmountCheck:GetCmd()
    return MsgTypeCmd.Response_Pay_AmountCheck_Cmd
end
function MsgType.Response_Pay_AmountCheck:GetUrl()
    return "Response_Pay_AmountCheck"
end
function MsgType.Response_Pay_AmountCheck:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.amount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.index = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.flag = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_Pay_AmountReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_AmountReward.__index = MsgType.Request_Pay_AmountReward

function MsgType.Request_Pay_AmountReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_AmountReward:GetCmd()
    return MsgTypeCmd.Request_Pay_AmountReward_Cmd
end
function MsgType.Request_Pay_AmountReward:GetUrl()
    return "Request_Pay_AmountReward"
end
function MsgType.Request_Pay_AmountReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_AmountReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_AmountReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_AmountReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    item = {},
    index = 0,
    flag = 0
}
MsgType.Response_Pay_AmountReward.__index = MsgType.Response_Pay_AmountReward
setmetatable(MsgType.Response_Pay_AmountReward.item, MsgType.OneRewardItem)

function MsgType.Response_Pay_AmountReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.item = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_AmountReward:GetCmd()
    return MsgTypeCmd.Response_Pay_AmountReward_Cmd
end
function MsgType.Response_Pay_AmountReward:GetUrl()
    return "Response_Pay_AmountReward"
end
function MsgType.Response_Pay_AmountReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.item:Decode(data.f)
    end
    if nil ~= data.g then
        self.index = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.flag = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_Pay_OrderCancel = {
    msgSeq = 0,
    gameOrderId = ""
}
MsgType.Request_Pay_OrderCancel.__index = MsgType.Request_Pay_OrderCancel

function MsgType.Request_Pay_OrderCancel:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_OrderCancel:GetCmd()
    return MsgTypeCmd.Request_Pay_OrderCancel_Cmd
end
function MsgType.Request_Pay_OrderCancel:GetUrl()
    return "Request_Pay_OrderCancel"
end
function MsgType.Request_Pay_OrderCancel:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.gameOrderId and string.len(self.gameOrderId) > 0 then
        tb.c = self.gameOrderId
    end
    return tb
end

function MsgType.Request_Pay_OrderCancel:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_OrderCancel:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_OrderCancel = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = ""
}
MsgType.Response_Pay_OrderCancel.__index = MsgType.Response_Pay_OrderCancel

function MsgType.Response_Pay_OrderCancel:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_OrderCancel:GetCmd()
    return MsgTypeCmd.Response_Pay_OrderCancel_Cmd
end
function MsgType.Response_Pay_OrderCancel:GetUrl()
    return "Response_Pay_OrderCancel"
end
function MsgType.Response_Pay_OrderCancel:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    return self
end


MsgType.Request_Pay_GoldVip = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_GoldVip.__index = MsgType.Request_Pay_GoldVip

function MsgType.Request_Pay_GoldVip:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_GoldVip:GetCmd()
    return MsgTypeCmd.Request_Pay_GoldVip_Cmd
end
function MsgType.Request_Pay_GoldVip:GetUrl()
    return "Request_Pay_GoldVip"
end
function MsgType.Request_Pay_GoldVip:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_GoldVip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_GoldVip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_GoldVip = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    item = {},
    payProduct = {},
    name = "",
    value = "",
    roleImgIcon = "",
    endTime = 0,
    flag = 0,
    remainCount = 0
}
MsgType.Response_Pay_GoldVip.__index = MsgType.Response_Pay_GoldVip
setmetatable(MsgType.Response_Pay_GoldVip.item, MsgType.OneRewardItem)
setmetatable(MsgType.Response_Pay_GoldVip.payProduct, MsgType.PayProduct)

function MsgType.Response_Pay_GoldVip:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.item = MsgType.OneRewardItem:New()
    tb.payProduct = MsgType.PayProduct:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_GoldVip:GetCmd()
    return MsgTypeCmd.Response_Pay_GoldVip_Cmd
end
function MsgType.Response_Pay_GoldVip:GetUrl()
    return "Response_Pay_GoldVip"
end
function MsgType.Response_Pay_GoldVip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.item:Decode(data.f)
    end
    if nil ~= data.g then
        self.payProduct:Decode(data.g)
    end
    if nil ~= data.h then
        self.name = tostring(data.h)
    end
    if nil ~= data.i then
        self.value = tostring(data.i)
    end
    if nil ~= data.j then
        self.roleImgIcon = tostring(data.j)
    end
    if nil ~= data.k then
        self.endTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.flag = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.remainCount = tonumber(data.m) or 0
    end
    return self
end


MsgType.Request_Pay_GoldVipReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_GoldVipReward.__index = MsgType.Request_Pay_GoldVipReward

function MsgType.Request_Pay_GoldVipReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_GoldVipReward:GetCmd()
    return MsgTypeCmd.Request_Pay_GoldVipReward_Cmd
end
function MsgType.Request_Pay_GoldVipReward:GetUrl()
    return "Request_Pay_GoldVipReward"
end
function MsgType.Request_Pay_GoldVipReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_GoldVipReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_GoldVipReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_GoldVipReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    item = {},
    endTime = 0,
    flag = 0,
    remainCount = 0
}
MsgType.Response_Pay_GoldVipReward.__index = MsgType.Response_Pay_GoldVipReward
setmetatable(MsgType.Response_Pay_GoldVipReward.item, MsgType.OneRewardItem)

function MsgType.Response_Pay_GoldVipReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.item = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_GoldVipReward:GetCmd()
    return MsgTypeCmd.Response_Pay_GoldVipReward_Cmd
end
function MsgType.Response_Pay_GoldVipReward:GetUrl()
    return "Response_Pay_GoldVipReward"
end
function MsgType.Response_Pay_GoldVipReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.item:Decode(data.f)
    end
    if nil ~= data.g then
        self.endTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.flag = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.remainCount = tonumber(data.i) or 0
    end
    return self
end


MsgType.EFurnitureBuffType = {
    SoldPriceSingle = 1,
    SoldPriceAll = 2,
    MakeSpeedSingle = 3,
    MakeSpeedAll = 4,
    HighRareSingle = 5,
    HighRareAll = 6,
    ProductionSpeedAll = 7,
    ProductionSpeedSingle = 8,
    HeroRefreshRate = 9,
    EquipBrokenRate = 10
}

MsgType.EVIPState = {
    None = 0,
    Buy = 1,
    Done = 2
}

MsgType.EVIPType = {
    Month = 1,
    Year = 2
}

MsgType.EVIPPayState = {
    None = 0,
    Buy = 1
}

MsgType.VIPPayInfo = {
    name = "",
    tag = "",
    atlasIcon = "",
    icon1 = "",
    icon2 = "",
    icon3 = "",
    icon4 = "",
    pic1 = "",
    pic2 = "",
    title = "",
    slogan = "",
    value = "",
    payProduct = {},
    roleImgAtlas = "",
    roleImgIcon = "",
    pic3 = "",
    pic4 = "",
    pic5 = "",
    pic6 = ""
}
MsgType.VIPPayInfo.__index = MsgType.VIPPayInfo
setmetatable(MsgType.VIPPayInfo.payProduct, MsgType.PayProduct)

function MsgType.VIPPayInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.payProduct = MsgType.PayProduct:New()
    return tb
end

function MsgType.VIPPayInfo:Encode()
    local tb = {}
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.b = self.name
    end
    if nil ~= self.tag and string.len(self.tag) > 0 then
        tb.c = self.tag
    end
    if nil ~= self.atlasIcon and string.len(self.atlasIcon) > 0 then
        tb.d = self.atlasIcon
    end
    if nil ~= self.icon1 and string.len(self.icon1) > 0 then
        tb.e = self.icon1
    end
    if nil ~= self.icon2 and string.len(self.icon2) > 0 then
        tb.f = self.icon2
    end
    if nil ~= self.icon3 and string.len(self.icon3) > 0 then
        tb.g = self.icon3
    end
    if nil ~= self.icon4 and string.len(self.icon4) > 0 then
        tb.h = self.icon4
    end
    if nil ~= self.pic1 and string.len(self.pic1) > 0 then
        tb.i = self.pic1
    end
    if nil ~= self.pic2 and string.len(self.pic2) > 0 then
        tb.j = self.pic2
    end
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.k = self.title
    end
    if nil ~= self.slogan and string.len(self.slogan) > 0 then
        tb.l = self.slogan
    end
    if nil ~= self.value and string.len(self.value) > 0 then
        tb.m = self.value
    end
    tb.n = self.payProduct:Encode()
    if nil ~= self.roleImgAtlas and string.len(self.roleImgAtlas) > 0 then
        tb.o = self.roleImgAtlas
    end
    if nil ~= self.roleImgIcon and string.len(self.roleImgIcon) > 0 then
        tb.p = self.roleImgIcon
    end
    if nil ~= self.pic3 and string.len(self.pic3) > 0 then
        tb.q = self.pic3
    end
    if nil ~= self.pic4 and string.len(self.pic4) > 0 then
        tb.r = self.pic4
    end
    if nil ~= self.pic5 and string.len(self.pic5) > 0 then
        tb.s = self.pic5
    end
    if nil ~= self.pic6 and string.len(self.pic6) > 0 then
        tb.t = self.pic6
    end
    return tb
end

function MsgType.VIPPayInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.name = tostring(data.b)
    end
    if nil ~= data.c then
        self.tag = tostring(data.c)
    end
    if nil ~= data.d then
        self.atlasIcon = tostring(data.d)
    end
    if nil ~= data.e then
        self.icon1 = tostring(data.e)
    end
    if nil ~= data.f then
        self.icon2 = tostring(data.f)
    end
    if nil ~= data.g then
        self.icon3 = tostring(data.g)
    end
    if nil ~= data.h then
        self.icon4 = tostring(data.h)
    end
    if nil ~= data.i then
        self.pic1 = tostring(data.i)
    end
    if nil ~= data.j then
        self.pic2 = tostring(data.j)
    end
    if nil ~= data.k then
        self.title = tostring(data.k)
    end
    if nil ~= data.l then
        self.slogan = tostring(data.l)
    end
    if nil ~= data.m then
        self.value = tostring(data.m)
    end
    if nil ~= data.n then
        self.payProduct:Decode(data.n)
    end
    if nil ~= data.o then
        self.roleImgAtlas = tostring(data.o)
    end
    if nil ~= data.p then
        self.roleImgIcon = tostring(data.p)
    end
    if nil ~= data.q then
        self.pic3 = tostring(data.q)
    end
    if nil ~= data.r then
        self.pic4 = tostring(data.r)
    end
    if nil ~= data.s then
        self.pic5 = tostring(data.s)
    end
    if nil ~= data.t then
        self.pic6 = tostring(data.t)
    end
    return self
end

function MsgType.VIPPayInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.VIPPayInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneStoreItem = {
    uid = 0,
    index = 0,
    number1 = 0,
    item = {},
    priceShow = 0,
    price = 0,
    textCn = "",
    textTc = "",
    textEn = "",
    fileGroup = "",
    fileName = "",
    state = 0 --enum EVIPPayState
}
MsgType.OneStoreItem.__index = MsgType.OneStoreItem
setmetatable(MsgType.OneStoreItem.item, MsgType.OneRewardItem)

function MsgType.OneStoreItem:New()
    local tb = {}
    setmetatable(tb, self)
    tb.item = MsgType.OneRewardItem:New()
    return tb
end

function MsgType.OneStoreItem:Encode()
    local tb = {}
    if nil ~= self.uid and 0 ~= self.uid then
        tb.b = self.uid
    end
    if nil ~= self.index and 0 ~= self.index then
        tb.c = self.index
    end
    if nil ~= self.number1 and 0 ~= self.number1 then
        tb.d = self.number1
    end
    tb.e = self.item:Encode()
    if nil ~= self.priceShow and 0 ~= self.priceShow then
        tb.f = self.priceShow
    end
    if nil ~= self.price and 0 ~= self.price then
        tb.g = self.price
    end
    if nil ~= self.textCn and string.len(self.textCn) > 0 then
        tb.h = self.textCn
    end
    if nil ~= self.textTc and string.len(self.textTc) > 0 then
        tb.i = self.textTc
    end
    if nil ~= self.textEn and string.len(self.textEn) > 0 then
        tb.j = self.textEn
    end
    if nil ~= self.fileGroup and string.len(self.fileGroup) > 0 then
        tb.k = self.fileGroup
    end
    if nil ~= self.fileName and string.len(self.fileName) > 0 then
        tb.l = self.fileName
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.m = self.state
    end
    return tb
end

function MsgType.OneStoreItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.uid = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.index = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.number1 = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.item:Decode(data.e)
    end
    if nil ~= data.f then
        self.priceShow = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.price = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.textCn = tostring(data.h)
    end
    if nil ~= data.i then
        self.textTc = tostring(data.i)
    end
    if nil ~= data.j then
        self.textEn = tostring(data.j)
    end
    if nil ~= data.k then
        self.fileGroup = tostring(data.k)
    end
    if nil ~= data.l then
        self.fileName = tostring(data.l)
    end
    if nil ~= data.m then
        self.state = tonumber(data.m) or 0
    end
    return self
end

function MsgType.OneStoreItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneStoreItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Pay_StoreList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_StoreList.__index = MsgType.Request_Pay_StoreList

function MsgType.Request_Pay_StoreList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_StoreList:GetCmd()
    return MsgTypeCmd.Request_Pay_StoreList_Cmd
end
function MsgType.Request_Pay_StoreList:GetUrl()
    return "Request_Pay_StoreList"
end
function MsgType.Request_Pay_StoreList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_StoreList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_StoreList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_StoreList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    storeItemList = {}, -- array of MsgType.OneStoreItem
    vipInfo = {},
    vipPayInfoMonth = {},
    vipPayInfoYear = {},
    freeRefresh = 0,
    refreshTime = 0,
    refreshCost = 0
}
MsgType.Response_Pay_StoreList.__index = MsgType.Response_Pay_StoreList
setmetatable(MsgType.Response_Pay_StoreList.vipInfo, MsgType.VIPInfo)
setmetatable(MsgType.Response_Pay_StoreList.vipPayInfoMonth, MsgType.VIPPayInfo)
setmetatable(MsgType.Response_Pay_StoreList.vipPayInfoYear, MsgType.VIPPayInfo)

function MsgType.Response_Pay_StoreList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.storeItemList = {}
    tb.vipInfo = MsgType.VIPInfo:New()
    tb.vipPayInfoMonth = MsgType.VIPPayInfo:New()
    tb.vipPayInfoYear = MsgType.VIPPayInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_StoreList:GetCmd()
    return MsgTypeCmd.Response_Pay_StoreList_Cmd
end
function MsgType.Response_Pay_StoreList:GetUrl()
    return "Response_Pay_StoreList"
end
function MsgType.Response_Pay_StoreList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpStoreItemListObj = MsgType.OneStoreItem:New()
            tmpStoreItemListObj:Decode(data.f[i])
            self.storeItemList[i] = tmpStoreItemListObj
        end
    end
    if nil ~= data.g then
        self.vipInfo:Decode(data.g)
    end
    if nil ~= data.h then
        self.vipPayInfoMonth:Decode(data.h)
    end
    if nil ~= data.i then
        self.vipPayInfoYear:Decode(data.i)
    end
    if nil ~= data.j then
        self.freeRefresh = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.refreshTime = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.refreshCost = tonumber(data.l) or 0
    end
    return self
end


MsgType.Request_Pay_StoreRefresh = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_StoreRefresh.__index = MsgType.Request_Pay_StoreRefresh

function MsgType.Request_Pay_StoreRefresh:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_StoreRefresh:GetCmd()
    return MsgTypeCmd.Request_Pay_StoreRefresh_Cmd
end
function MsgType.Request_Pay_StoreRefresh:GetUrl()
    return "Request_Pay_StoreRefresh"
end
function MsgType.Request_Pay_StoreRefresh:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_StoreRefresh:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_StoreRefresh:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_StoreRefresh = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    storeItemList = {}, -- array of MsgType.OneStoreItem
    freeRefresh = 0,
    refreshTime = 0,
    refreshCost = 0
}
MsgType.Response_Pay_StoreRefresh.__index = MsgType.Response_Pay_StoreRefresh

function MsgType.Response_Pay_StoreRefresh:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.storeItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_StoreRefresh:GetCmd()
    return MsgTypeCmd.Response_Pay_StoreRefresh_Cmd
end
function MsgType.Response_Pay_StoreRefresh:GetUrl()
    return "Response_Pay_StoreRefresh"
end
function MsgType.Response_Pay_StoreRefresh:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpStoreItemListObj = MsgType.OneStoreItem:New()
            tmpStoreItemListObj:Decode(data.f[i])
            self.storeItemList[i] = tmpStoreItemListObj
        end
    end
    if nil ~= data.g then
        self.freeRefresh = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.refreshTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.refreshCost = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_Pay_StoreBuy = {
    msgSeq = 0,
    uid = 0
}
MsgType.Request_Pay_StoreBuy.__index = MsgType.Request_Pay_StoreBuy

function MsgType.Request_Pay_StoreBuy:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_StoreBuy:GetCmd()
    return MsgTypeCmd.Request_Pay_StoreBuy_Cmd
end
function MsgType.Request_Pay_StoreBuy:GetUrl()
    return "Request_Pay_StoreBuy"
end
function MsgType.Request_Pay_StoreBuy:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.uid and 0 ~= self.uid then
        tb.c = self.uid
    end
    return tb
end

function MsgType.Request_Pay_StoreBuy:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_StoreBuy:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_StoreBuy = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    storeItemList = {}, -- array of MsgType.OneStoreItem
    reward = {}
}
MsgType.Response_Pay_StoreBuy.__index = MsgType.Response_Pay_StoreBuy
setmetatable(MsgType.Response_Pay_StoreBuy.reward, MsgType.OneRewardItem)

function MsgType.Response_Pay_StoreBuy:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.storeItemList = {}
    tb.reward = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_StoreBuy:GetCmd()
    return MsgTypeCmd.Response_Pay_StoreBuy_Cmd
end
function MsgType.Response_Pay_StoreBuy:GetUrl()
    return "Response_Pay_StoreBuy"
end
function MsgType.Response_Pay_StoreBuy:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpStoreItemListObj = MsgType.OneStoreItem:New()
            tmpStoreItemListObj:Decode(data.f[i])
            self.storeItemList[i] = tmpStoreItemListObj
        end
    end
    if nil ~= data.g then
        self.reward:Decode(data.g)
    end
    return self
end


MsgType.Request_Pay_BuyVIP = {
    msgSeq = 0,
    index = 0
}
MsgType.Request_Pay_BuyVIP.__index = MsgType.Request_Pay_BuyVIP

function MsgType.Request_Pay_BuyVIP:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_BuyVIP:GetCmd()
    return MsgTypeCmd.Request_Pay_BuyVIP_Cmd
end
function MsgType.Request_Pay_BuyVIP:GetUrl()
    return "Request_Pay_BuyVIP"
end
function MsgType.Request_Pay_BuyVIP:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.index and 0 ~= self.index then
        tb.c = self.index
    end
    return tb
end

function MsgType.Request_Pay_BuyVIP:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_BuyVIP:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_BuyVIP = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    vipPayInfoMonth = {},
    vipPayInfoYear = {},
    vipInfo = {}
}
MsgType.Response_Pay_BuyVIP.__index = MsgType.Response_Pay_BuyVIP
setmetatable(MsgType.Response_Pay_BuyVIP.vipPayInfoMonth, MsgType.VIPPayInfo)
setmetatable(MsgType.Response_Pay_BuyVIP.vipPayInfoYear, MsgType.VIPPayInfo)
setmetatable(MsgType.Response_Pay_BuyVIP.vipInfo, MsgType.VIPInfo)

function MsgType.Response_Pay_BuyVIP:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.vipPayInfoMonth = MsgType.VIPPayInfo:New()
    tb.vipPayInfoYear = MsgType.VIPPayInfo:New()
    tb.vipInfo = MsgType.VIPInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_BuyVIP:GetCmd()
    return MsgTypeCmd.Response_Pay_BuyVIP_Cmd
end
function MsgType.Response_Pay_BuyVIP:GetUrl()
    return "Response_Pay_BuyVIP"
end
function MsgType.Response_Pay_BuyVIP:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.vipPayInfoMonth:Decode(data.f)
    end
    if nil ~= data.g then
        self.vipPayInfoYear:Decode(data.g)
    end
    if nil ~= data.h then
        self.vipInfo:Decode(data.h)
    end
    return self
end


MsgType.Response_Pay_VIPChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    vipPayInfoMonth = {},
    vipPayInfoYear = {},
    vipInfo = {}
}
MsgType.Response_Pay_VIPChange.__index = MsgType.Response_Pay_VIPChange
setmetatable(MsgType.Response_Pay_VIPChange.vipPayInfoMonth, MsgType.VIPPayInfo)
setmetatable(MsgType.Response_Pay_VIPChange.vipPayInfoYear, MsgType.VIPPayInfo)
setmetatable(MsgType.Response_Pay_VIPChange.vipInfo, MsgType.VIPInfo)

function MsgType.Response_Pay_VIPChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.vipPayInfoMonth = MsgType.VIPPayInfo:New()
    tb.vipPayInfoYear = MsgType.VIPPayInfo:New()
    tb.vipInfo = MsgType.VIPInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_VIPChange:GetCmd()
    return MsgTypeCmd.Response_Pay_VIPChange_Cmd
end
function MsgType.Response_Pay_VIPChange:GetUrl()
    return "Response_Pay_VIPChange"
end
function MsgType.Response_Pay_VIPChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.vipPayInfoMonth:Decode(data.f)
    end
    if nil ~= data.g then
        self.vipPayInfoYear:Decode(data.g)
    end
    if nil ~= data.h then
        self.vipInfo:Decode(data.h)
    end
    return self
end


MsgType.GeneralPurchase = {
    id = 0,
    rebateRatio = "",
    txt = "",
    pic1 = "",
    pic2 = "",
    rewardItem = {},
    rebateItem = {},
    rebateState = 0,
    payProduct = {},
    pic3 = "",
    pic4 = "",
    pic5 = "",
    pic6 = ""
}
MsgType.GeneralPurchase.__index = MsgType.GeneralPurchase
setmetatable(MsgType.GeneralPurchase.rewardItem, MsgType.OneRewardItem)
setmetatable(MsgType.GeneralPurchase.rebateItem, MsgType.OneRewardItem)
setmetatable(MsgType.GeneralPurchase.payProduct, MsgType.PayProduct)

function MsgType.GeneralPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.rewardItem = MsgType.OneRewardItem:New()
    tb.rebateItem = MsgType.OneRewardItem:New()
    tb.payProduct = MsgType.PayProduct:New()
    return tb
end

function MsgType.GeneralPurchase:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.rebateRatio and string.len(self.rebateRatio) > 0 then
        tb.c = self.rebateRatio
    end
    if nil ~= self.txt and string.len(self.txt) > 0 then
        tb.d = self.txt
    end
    if nil ~= self.pic1 and string.len(self.pic1) > 0 then
        tb.e = self.pic1
    end
    if nil ~= self.pic2 and string.len(self.pic2) > 0 then
        tb.f = self.pic2
    end
    tb.g = self.rewardItem:Encode()
    tb.h = self.rebateItem:Encode()
    if nil ~= self.rebateState and 0 ~= self.rebateState then
        tb.i = self.rebateState
    end
    tb.j = self.payProduct:Encode()
    if nil ~= self.pic3 and string.len(self.pic3) > 0 then
        tb.k = self.pic3
    end
    if nil ~= self.pic4 and string.len(self.pic4) > 0 then
        tb.l = self.pic4
    end
    if nil ~= self.pic5 and string.len(self.pic5) > 0 then
        tb.m = self.pic5
    end
    if nil ~= self.pic6 and string.len(self.pic6) > 0 then
        tb.n = self.pic6
    end
    return tb
end

function MsgType.GeneralPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.rebateRatio = tostring(data.c)
    end
    if nil ~= data.d then
        self.txt = tostring(data.d)
    end
    if nil ~= data.e then
        self.pic1 = tostring(data.e)
    end
    if nil ~= data.f then
        self.pic2 = tostring(data.f)
    end
    if nil ~= data.g then
        self.rewardItem:Decode(data.g)
    end
    if nil ~= data.h then
        self.rebateItem:Decode(data.h)
    end
    if nil ~= data.i then
        self.rebateState = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.payProduct:Decode(data.j)
    end
    if nil ~= data.k then
        self.pic3 = tostring(data.k)
    end
    if nil ~= data.l then
        self.pic4 = tostring(data.l)
    end
    if nil ~= data.m then
        self.pic5 = tostring(data.m)
    end
    if nil ~= data.n then
        self.pic6 = tostring(data.n)
    end
    return self
end

function MsgType.GeneralPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.GeneralPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.GeneralPurchaseList = {
    purchaseList = {} -- array of MsgType.GeneralPurchase
}
MsgType.GeneralPurchaseList.__index = MsgType.GeneralPurchaseList

function MsgType.GeneralPurchaseList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.purchaseList = {}
    return tb
end

function MsgType.GeneralPurchaseList:_purchaseListEncode()
    local tb = {}
    for i=1, #self.purchaseList do
        tb[i] = self.purchaseList[i]:Encode()
    end
    return tb
end
function MsgType.GeneralPurchaseList:Encode()
    local tb = {}
    tb.b = self:_purchaseListEncode()
    return tb
end

function MsgType.GeneralPurchaseList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpPurchaseListObj = MsgType.GeneralPurchase:New()
            tmpPurchaseListObj:Decode(data.b[i])
            self.purchaseList[i] = tmpPurchaseListObj
        end
    end
    return self
end

function MsgType.GeneralPurchaseList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.GeneralPurchaseList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Pay_GeneralPurchase = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_GeneralPurchase.__index = MsgType.Request_Pay_GeneralPurchase

function MsgType.Request_Pay_GeneralPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_GeneralPurchase:GetCmd()
    return MsgTypeCmd.Request_Pay_GeneralPurchase_Cmd
end
function MsgType.Request_Pay_GeneralPurchase:GetUrl()
    return "Request_Pay_GeneralPurchase"
end
function MsgType.Request_Pay_GeneralPurchase:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_GeneralPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_GeneralPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_GeneralPurchase = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    generalPurchaseList = {}
}
MsgType.Response_Pay_GeneralPurchase.__index = MsgType.Response_Pay_GeneralPurchase
setmetatable(MsgType.Response_Pay_GeneralPurchase.generalPurchaseList, MsgType.GeneralPurchaseList)

function MsgType.Response_Pay_GeneralPurchase:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.generalPurchaseList = MsgType.GeneralPurchaseList:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_GeneralPurchase:GetCmd()
    return MsgTypeCmd.Response_Pay_GeneralPurchase_Cmd
end
function MsgType.Response_Pay_GeneralPurchase:GetUrl()
    return "Response_Pay_GeneralPurchase"
end
function MsgType.Response_Pay_GeneralPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.generalPurchaseList:Decode(data.f)
    end
    return self
end


MsgType.DailySale = {
    id = 0,
    name = "",
    tag = "",
    title = "",
    slogan = "",
    atlasIcon = "",
    icon1 = "",
    icon2 = "",
    icon3 = "",
    icon4 = "",
    pic1 = "",
    pic2 = "",
    originalPrice = 0,
    itemList = {}, -- array of MsgType.OneRewardItem
    buyCount = 0,
    buyCountLimit = 0,
    payProduct = {},
    roleImgAtlas = "",
    roleImgIcon = "",
    pic3 = "",
    pic4 = "",
    pic5 = "",
    pic6 = ""
}
MsgType.DailySale.__index = MsgType.DailySale
setmetatable(MsgType.DailySale.payProduct, MsgType.PayProduct)

function MsgType.DailySale:New()
    local tb = {}
    setmetatable(tb, self)
    tb.itemList = {}
    tb.payProduct = MsgType.PayProduct:New()
    return tb
end

function MsgType.DailySale:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:Encode()
    end
    return tb
end
function MsgType.DailySale:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.c = self.name
    end
    if nil ~= self.tag and string.len(self.tag) > 0 then
        tb.d = self.tag
    end
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.e = self.title
    end
    if nil ~= self.slogan and string.len(self.slogan) > 0 then
        tb.f = self.slogan
    end
    if nil ~= self.atlasIcon and string.len(self.atlasIcon) > 0 then
        tb.g = self.atlasIcon
    end
    if nil ~= self.icon1 and string.len(self.icon1) > 0 then
        tb.h = self.icon1
    end
    if nil ~= self.icon2 and string.len(self.icon2) > 0 then
        tb.i = self.icon2
    end
    if nil ~= self.icon3 and string.len(self.icon3) > 0 then
        tb.j = self.icon3
    end
    if nil ~= self.icon4 and string.len(self.icon4) > 0 then
        tb.k = self.icon4
    end
    if nil ~= self.pic1 and string.len(self.pic1) > 0 then
        tb.l = self.pic1
    end
    if nil ~= self.pic2 and string.len(self.pic2) > 0 then
        tb.m = self.pic2
    end
    if nil ~= self.originalPrice and 0 ~= self.originalPrice then
        tb.n = self.originalPrice
    end
    tb.o = self:_itemListEncode()
    if nil ~= self.buyCount and 0 ~= self.buyCount then
        tb.p = self.buyCount
    end
    if nil ~= self.buyCountLimit and 0 ~= self.buyCountLimit then
        tb.q = self.buyCountLimit
    end
    tb.r = self.payProduct:Encode()
    if nil ~= self.roleImgAtlas and string.len(self.roleImgAtlas) > 0 then
        tb.s = self.roleImgAtlas
    end
    if nil ~= self.roleImgIcon and string.len(self.roleImgIcon) > 0 then
        tb.t = self.roleImgIcon
    end
    if nil ~= self.pic3 and string.len(self.pic3) > 0 then
        tb.u = self.pic3
    end
    if nil ~= self.pic4 and string.len(self.pic4) > 0 then
        tb.v = self.pic4
    end
    if nil ~= self.pic5 and string.len(self.pic5) > 0 then
        tb.w = self.pic5
    end
    if nil ~= self.pic6 and string.len(self.pic6) > 0 then
        tb.x = self.pic6
    end
    return tb
end

function MsgType.DailySale:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.name = tostring(data.c)
    end
    if nil ~= data.d then
        self.tag = tostring(data.d)
    end
    if nil ~= data.e then
        self.title = tostring(data.e)
    end
    if nil ~= data.f then
        self.slogan = tostring(data.f)
    end
    if nil ~= data.g then
        self.atlasIcon = tostring(data.g)
    end
    if nil ~= data.h then
        self.icon1 = tostring(data.h)
    end
    if nil ~= data.i then
        self.icon2 = tostring(data.i)
    end
    if nil ~= data.j then
        self.icon3 = tostring(data.j)
    end
    if nil ~= data.k then
        self.icon4 = tostring(data.k)
    end
    if nil ~= data.l then
        self.pic1 = tostring(data.l)
    end
    if nil ~= data.m then
        self.pic2 = tostring(data.m)
    end
    if nil ~= data.n then
        self.originalPrice = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        for i=1, #data.o do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.o[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.p then
        self.buyCount = tonumber(data.p) or 0
    end
    if nil ~= data.q then
        self.buyCountLimit = tonumber(data.q) or 0
    end
    if nil ~= data.r then
        self.payProduct:Decode(data.r)
    end
    if nil ~= data.s then
        self.roleImgAtlas = tostring(data.s)
    end
    if nil ~= data.t then
        self.roleImgIcon = tostring(data.t)
    end
    if nil ~= data.u then
        self.pic3 = tostring(data.u)
    end
    if nil ~= data.v then
        self.pic4 = tostring(data.v)
    end
    if nil ~= data.w then
        self.pic5 = tostring(data.w)
    end
    if nil ~= data.x then
        self.pic6 = tostring(data.x)
    end
    return self
end

function MsgType.DailySale:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.DailySale:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.DailySaleList = {
    remainTime = 0,
    saleList = {} -- array of MsgType.DailySale
}
MsgType.DailySaleList.__index = MsgType.DailySaleList

function MsgType.DailySaleList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.saleList = {}
    return tb
end

function MsgType.DailySaleList:_saleListEncode()
    local tb = {}
    for i=1, #self.saleList do
        tb[i] = self.saleList[i]:Encode()
    end
    return tb
end
function MsgType.DailySaleList:Encode()
    local tb = {}
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.b = self.remainTime
    end
    tb.c = self:_saleListEncode()
    return tb
end

function MsgType.DailySaleList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.remainTime = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpSaleListObj = MsgType.DailySale:New()
            tmpSaleListObj:Decode(data.c[i])
            self.saleList[i] = tmpSaleListObj
        end
    end
    return self
end

function MsgType.DailySaleList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.DailySaleList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Pay_DailySale = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_DailySale.__index = MsgType.Request_Pay_DailySale

function MsgType.Request_Pay_DailySale:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_DailySale:GetCmd()
    return MsgTypeCmd.Request_Pay_DailySale_Cmd
end
function MsgType.Request_Pay_DailySale:GetUrl()
    return "Request_Pay_DailySale"
end
function MsgType.Request_Pay_DailySale:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_DailySale:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_DailySale:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_DailySale = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    dailySaleList = {}
}
MsgType.Response_Pay_DailySale.__index = MsgType.Response_Pay_DailySale
setmetatable(MsgType.Response_Pay_DailySale.dailySaleList, MsgType.DailySaleList)

function MsgType.Response_Pay_DailySale:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.dailySaleList = MsgType.DailySaleList:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_DailySale:GetCmd()
    return MsgTypeCmd.Response_Pay_DailySale_Cmd
end
function MsgType.Response_Pay_DailySale:GetUrl()
    return "Response_Pay_DailySale"
end
function MsgType.Response_Pay_DailySale:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.dailySaleList:Decode(data.f)
    end
    return self
end


MsgType.DirectPurchase = {
    uid = "",
    id = 0,
    quickOn = 0,
    mallOn = 0,
    remainTime = 0,
    name = "",
    tag = "",
    title = "",
    slogan = "",
    atlasIcon = "",
    icon1 = "",
    icon2 = "",
    icon3 = "",
    icon4 = "",
    icon4Atlas = "",
    pic1 = "",
    pic2 = "",
    value = 0,
    priority = 0,
    pushType = {}, -- array of number
    pushParam = {}, -- array of number
    itemList = {}, -- array of MsgType.OneRewardItem
    buyCount = 0,
    buyCountLimit = 0,
    payProduct = {},
    roleImgAtlas = "",
    roleImgIcon = "",
    packMallTab = 0,
    pic3 = "",
    pic4 = "",
    pic5 = "",
    pic6 = ""
}
MsgType.DirectPurchase.__index = MsgType.DirectPurchase
setmetatable(MsgType.DirectPurchase.payProduct, MsgType.PayProduct)

function MsgType.DirectPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.pushType = {}
    tb.pushParam = {}
    tb.itemList = {}
    tb.payProduct = MsgType.PayProduct:New()
    return tb
end

function MsgType.DirectPurchase:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:Encode()
    end
    return tb
end
function MsgType.DirectPurchase:Encode()
    local tb = {}
    if nil ~= self.uid and string.len(self.uid) > 0 then
        tb.b = self.uid
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.c = self.id
    end
    if nil ~= self.quickOn and 0 ~= self.quickOn then
        tb.d = self.quickOn
    end
    if nil ~= self.mallOn and 0 ~= self.mallOn then
        tb.e = self.mallOn
    end
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.f = self.remainTime
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.g = self.name
    end
    if nil ~= self.tag and string.len(self.tag) > 0 then
        tb.h = self.tag
    end
    if nil ~= self.title and string.len(self.title) > 0 then
        tb.i = self.title
    end
    if nil ~= self.slogan and string.len(self.slogan) > 0 then
        tb.j = self.slogan
    end
    if nil ~= self.atlasIcon and string.len(self.atlasIcon) > 0 then
        tb.k = self.atlasIcon
    end
    if nil ~= self.icon1 and string.len(self.icon1) > 0 then
        tb.l = self.icon1
    end
    if nil ~= self.icon2 and string.len(self.icon2) > 0 then
        tb.m = self.icon2
    end
    if nil ~= self.icon3 and string.len(self.icon3) > 0 then
        tb.n = self.icon3
    end
    if nil ~= self.icon4 and string.len(self.icon4) > 0 then
        tb.o = self.icon4
    end
    if nil ~= self.icon4Atlas and string.len(self.icon4Atlas) > 0 then
        tb.p = self.icon4Atlas
    end
    if nil ~= self.pic1 and string.len(self.pic1) > 0 then
        tb.q = self.pic1
    end
    if nil ~= self.pic2 and string.len(self.pic2) > 0 then
        tb.r = self.pic2
    end
    if nil ~= self.value and 0 ~= self.value then
        tb.s = self.value
    end
    if nil ~= self.priority and 0 ~= self.priority then
        tb.t = self.priority
    end
    if nil ~= self.pushType and #self.pushType > 0 then
        for i=1, #self.pushType do
            tb.e[i] = tonumber(self.pushType[i])
        end
    end
    if nil ~= self.pushParam and #self.pushParam > 0 then
        for i=1, #self.pushParam do
            tb.e[i] = tonumber(self.pushParam[i])
        end
    end
    tb.w = self:_itemListEncode()
    if nil ~= self.buyCount and 0 ~= self.buyCount then
        tb.x = self.buyCount
    end
    if nil ~= self.buyCountLimit and 0 ~= self.buyCountLimit then
        tb.y = self.buyCountLimit
    end
    tb.z = self.payProduct:Encode()
    if nil ~= self.roleImgAtlas and string.len(self.roleImgAtlas) > 0 then
        tb.a1 = self.roleImgAtlas
    end
    if nil ~= self.roleImgIcon and string.len(self.roleImgIcon) > 0 then
        tb.a2 = self.roleImgIcon
    end
    if nil ~= self.packMallTab and 0 ~= self.packMallTab then
        tb.a3 = self.packMallTab
    end
    if nil ~= self.pic3 and string.len(self.pic3) > 0 then
        tb.a4 = self.pic3
    end
    if nil ~= self.pic4 and string.len(self.pic4) > 0 then
        tb.a5 = self.pic4
    end
    if nil ~= self.pic5 and string.len(self.pic5) > 0 then
        tb.a6 = self.pic5
    end
    if nil ~= self.pic6 and string.len(self.pic6) > 0 then
        tb.a7 = self.pic6
    end
    return tb
end

function MsgType.DirectPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.uid = tostring(data.b)
    end
    if nil ~= data.c then
        self.id = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.quickOn = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.mallOn = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.remainTime = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.name = tostring(data.g)
    end
    if nil ~= data.h then
        self.tag = tostring(data.h)
    end
    if nil ~= data.i then
        self.title = tostring(data.i)
    end
    if nil ~= data.j then
        self.slogan = tostring(data.j)
    end
    if nil ~= data.k then
        self.atlasIcon = tostring(data.k)
    end
    if nil ~= data.l then
        self.icon1 = tostring(data.l)
    end
    if nil ~= data.m then
        self.icon2 = tostring(data.m)
    end
    if nil ~= data.n then
        self.icon3 = tostring(data.n)
    end
    if nil ~= data.o then
        self.icon4 = tostring(data.o)
    end
    if nil ~= data.p then
        self.icon4Atlas = tostring(data.p)
    end
    if nil ~= data.q then
        self.pic1 = tostring(data.q)
    end
    if nil ~= data.r then
        self.pic2 = tostring(data.r)
    end
    if nil ~= data.s then
        self.value = tonumber(data.s) or 0
    end
    if nil ~= data.t then
        self.priority = tonumber(data.t) or 0
    end
    if nil ~= data.u and #data.u > 0 then
        for i=1, #data.u do
            self.pushType[i] = tonumber(data.u[i])
        end
    end
    if nil ~= data.v and #data.v > 0 then
        for i=1, #data.v do
            self.pushParam[i] = tonumber(data.v[i])
        end
    end
    if nil ~= data.w then
        for i=1, #data.w do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.w[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.x then
        self.buyCount = tonumber(data.x) or 0
    end
    if nil ~= data.y then
        self.buyCountLimit = tonumber(data.y) or 0
    end
    if nil ~= data.z then
        self.payProduct:Decode(data.z)
    end
    if nil ~= data.a1 then
        self.roleImgAtlas = tostring(data.a1)
    end
    if nil ~= data.a2 then
        self.roleImgIcon = tostring(data.a2)
    end
    if nil ~= data.a3 then
        self.packMallTab = tonumber(data.a3) or 0
    end
    if nil ~= data.a4 then
        self.pic3 = tostring(data.a4)
    end
    if nil ~= data.a5 then
        self.pic4 = tostring(data.a5)
    end
    if nil ~= data.a6 then
        self.pic5 = tostring(data.a6)
    end
    if nil ~= data.a7 then
        self.pic6 = tostring(data.a7)
    end
    return self
end

function MsgType.DirectPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.DirectPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.DirectPurchaseList = {
    purchaseList = {} -- array of MsgType.DirectPurchase
}
MsgType.DirectPurchaseList.__index = MsgType.DirectPurchaseList

function MsgType.DirectPurchaseList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.purchaseList = {}
    return tb
end

function MsgType.DirectPurchaseList:_purchaseListEncode()
    local tb = {}
    for i=1, #self.purchaseList do
        tb[i] = self.purchaseList[i]:Encode()
    end
    return tb
end
function MsgType.DirectPurchaseList:Encode()
    local tb = {}
    tb.b = self:_purchaseListEncode()
    return tb
end

function MsgType.DirectPurchaseList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpPurchaseListObj = MsgType.DirectPurchase:New()
            tmpPurchaseListObj:Decode(data.b[i])
            self.purchaseList[i] = tmpPurchaseListObj
        end
    end
    return self
end

function MsgType.DirectPurchaseList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.DirectPurchaseList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Pay_DirectPurchase = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_DirectPurchase.__index = MsgType.Request_Pay_DirectPurchase

function MsgType.Request_Pay_DirectPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_DirectPurchase:GetCmd()
    return MsgTypeCmd.Request_Pay_DirectPurchase_Cmd
end
function MsgType.Request_Pay_DirectPurchase:GetUrl()
    return "Request_Pay_DirectPurchase"
end
function MsgType.Request_Pay_DirectPurchase:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_DirectPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_DirectPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_DirectPurchase = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    directPurchaseList = {}
}
MsgType.Response_Pay_DirectPurchase.__index = MsgType.Response_Pay_DirectPurchase
setmetatable(MsgType.Response_Pay_DirectPurchase.directPurchaseList, MsgType.DirectPurchaseList)

function MsgType.Response_Pay_DirectPurchase:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.directPurchaseList = MsgType.DirectPurchaseList:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_DirectPurchase:GetCmd()
    return MsgTypeCmd.Response_Pay_DirectPurchase_Cmd
end
function MsgType.Response_Pay_DirectPurchase:GetUrl()
    return "Response_Pay_DirectPurchase"
end
function MsgType.Response_Pay_DirectPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.directPurchaseList:Decode(data.f)
    end
    return self
end


MsgType.OperatingActivityPurchase = {
    id = 0,
    txt = "",
    pic1 = "",
    pic2 = "",
    rewardItem = {},
    payProduct = {},
    pic3 = "",
    pic4 = "",
    pic5 = "",
    pic6 = ""
}
MsgType.OperatingActivityPurchase.__index = MsgType.OperatingActivityPurchase
setmetatable(MsgType.OperatingActivityPurchase.rewardItem, MsgType.OneRewardItem)
setmetatable(MsgType.OperatingActivityPurchase.payProduct, MsgType.PayProduct)

function MsgType.OperatingActivityPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.rewardItem = MsgType.OneRewardItem:New()
    tb.payProduct = MsgType.PayProduct:New()
    return tb
end

function MsgType.OperatingActivityPurchase:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.txt and string.len(self.txt) > 0 then
        tb.c = self.txt
    end
    if nil ~= self.pic1 and string.len(self.pic1) > 0 then
        tb.d = self.pic1
    end
    if nil ~= self.pic2 and string.len(self.pic2) > 0 then
        tb.e = self.pic2
    end
    tb.f = self.rewardItem:Encode()
    tb.g = self.payProduct:Encode()
    if nil ~= self.pic3 and string.len(self.pic3) > 0 then
        tb.h = self.pic3
    end
    if nil ~= self.pic4 and string.len(self.pic4) > 0 then
        tb.i = self.pic4
    end
    if nil ~= self.pic5 and string.len(self.pic5) > 0 then
        tb.j = self.pic5
    end
    if nil ~= self.pic6 and string.len(self.pic6) > 0 then
        tb.k = self.pic6
    end
    return tb
end

function MsgType.OperatingActivityPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.txt = tostring(data.c)
    end
    if nil ~= data.d then
        self.pic1 = tostring(data.d)
    end
    if nil ~= data.e then
        self.pic2 = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    if nil ~= data.g then
        self.payProduct:Decode(data.g)
    end
    if nil ~= data.h then
        self.pic3 = tostring(data.h)
    end
    if nil ~= data.i then
        self.pic4 = tostring(data.i)
    end
    if nil ~= data.j then
        self.pic5 = tostring(data.j)
    end
    if nil ~= data.k then
        self.pic6 = tostring(data.k)
    end
    return self
end

function MsgType.OperatingActivityPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OperatingActivityPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Pay_OperatingActivityPurchase = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_OperatingActivityPurchase.__index = MsgType.Request_Pay_OperatingActivityPurchase

function MsgType.Request_Pay_OperatingActivityPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_OperatingActivityPurchase:GetCmd()
    return MsgTypeCmd.Request_Pay_OperatingActivityPurchase_Cmd
end
function MsgType.Request_Pay_OperatingActivityPurchase:GetUrl()
    return "Request_Pay_OperatingActivityPurchase"
end
function MsgType.Request_Pay_OperatingActivityPurchase:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_OperatingActivityPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_OperatingActivityPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OperatingActivityPurchasePurchaseList = {
    purchaseList = {} -- array of MsgType.OperatingActivityPurchase
}
MsgType.OperatingActivityPurchasePurchaseList.__index = MsgType.OperatingActivityPurchasePurchaseList

function MsgType.OperatingActivityPurchasePurchaseList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.purchaseList = {}
    return tb
end

function MsgType.OperatingActivityPurchasePurchaseList:_purchaseListEncode()
    local tb = {}
    for i=1, #self.purchaseList do
        tb[i] = self.purchaseList[i]:Encode()
    end
    return tb
end
function MsgType.OperatingActivityPurchasePurchaseList:Encode()
    local tb = {}
    tb.b = self:_purchaseListEncode()
    return tb
end

function MsgType.OperatingActivityPurchasePurchaseList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpPurchaseListObj = MsgType.OperatingActivityPurchase:New()
            tmpPurchaseListObj:Decode(data.b[i])
            self.purchaseList[i] = tmpPurchaseListObj
        end
    end
    return self
end

function MsgType.OperatingActivityPurchasePurchaseList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OperatingActivityPurchasePurchaseList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_OperatingActivityPurchase = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    operatingActivityPurchasePurchaseList = {}
}
MsgType.Response_Pay_OperatingActivityPurchase.__index = MsgType.Response_Pay_OperatingActivityPurchase
setmetatable(MsgType.Response_Pay_OperatingActivityPurchase.operatingActivityPurchasePurchaseList, MsgType.OperatingActivityPurchasePurchaseList)

function MsgType.Response_Pay_OperatingActivityPurchase:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.operatingActivityPurchasePurchaseList = MsgType.OperatingActivityPurchasePurchaseList:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_OperatingActivityPurchase:GetCmd()
    return MsgTypeCmd.Response_Pay_OperatingActivityPurchase_Cmd
end
function MsgType.Response_Pay_OperatingActivityPurchase:GetUrl()
    return "Response_Pay_OperatingActivityPurchase"
end
function MsgType.Response_Pay_OperatingActivityPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.operatingActivityPurchasePurchaseList:Decode(data.f)
    end
    return self
end


MsgType.PointActivityPurchase = {
    uid = "",
    id = 0,
    name = "",
    priority = 0,
    pic1Atlas = "",
    pic1 = "",
    pic2 = "",
    value = 0,
    itemList = {}, -- array of MsgType.OneRewardItem
    buyCount = 0,
    buyCountLimit = 0,
    payProduct = {}
}
MsgType.PointActivityPurchase.__index = MsgType.PointActivityPurchase
setmetatable(MsgType.PointActivityPurchase.payProduct, MsgType.PayProduct)

function MsgType.PointActivityPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.itemList = {}
    tb.payProduct = MsgType.PayProduct:New()
    return tb
end

function MsgType.PointActivityPurchase:_itemListEncode()
    local tb = {}
    for i=1, #self.itemList do
        tb[i] = self.itemList[i]:Encode()
    end
    return tb
end
function MsgType.PointActivityPurchase:Encode()
    local tb = {}
    if nil ~= self.uid and string.len(self.uid) > 0 then
        tb.b = self.uid
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.c = self.id
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.d = self.name
    end
    if nil ~= self.priority and 0 ~= self.priority then
        tb.e = self.priority
    end
    if nil ~= self.pic1Atlas and string.len(self.pic1Atlas) > 0 then
        tb.f = self.pic1Atlas
    end
    if nil ~= self.pic1 and string.len(self.pic1) > 0 then
        tb.g = self.pic1
    end
    if nil ~= self.pic2 and string.len(self.pic2) > 0 then
        tb.h = self.pic2
    end
    if nil ~= self.value and 0 ~= self.value then
        tb.i = self.value
    end
    tb.j = self:_itemListEncode()
    if nil ~= self.buyCount and 0 ~= self.buyCount then
        tb.k = self.buyCount
    end
    if nil ~= self.buyCountLimit and 0 ~= self.buyCountLimit then
        tb.l = self.buyCountLimit
    end
    tb.m = self.payProduct:Encode()
    return tb
end

function MsgType.PointActivityPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.uid = tostring(data.b)
    end
    if nil ~= data.c then
        self.id = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.name = tostring(data.d)
    end
    if nil ~= data.e then
        self.priority = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.pic1Atlas = tostring(data.f)
    end
    if nil ~= data.g then
        self.pic1 = tostring(data.g)
    end
    if nil ~= data.h then
        self.pic2 = tostring(data.h)
    end
    if nil ~= data.i then
        self.value = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpItemListObj = MsgType.OneRewardItem:New()
            tmpItemListObj:Decode(data.j[i])
            self.itemList[i] = tmpItemListObj
        end
    end
    if nil ~= data.k then
        self.buyCount = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.buyCountLimit = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.payProduct:Decode(data.m)
    end
    return self
end

function MsgType.PointActivityPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.PointActivityPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.PointActivityPurchasePurchaseList = {
    purchaseList = {} -- array of MsgType.PointActivityPurchase
}
MsgType.PointActivityPurchasePurchaseList.__index = MsgType.PointActivityPurchasePurchaseList

function MsgType.PointActivityPurchasePurchaseList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.purchaseList = {}
    return tb
end

function MsgType.PointActivityPurchasePurchaseList:_purchaseListEncode()
    local tb = {}
    for i=1, #self.purchaseList do
        tb[i] = self.purchaseList[i]:Encode()
    end
    return tb
end
function MsgType.PointActivityPurchasePurchaseList:Encode()
    local tb = {}
    tb.b = self:_purchaseListEncode()
    return tb
end

function MsgType.PointActivityPurchasePurchaseList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        for i=1, #data.b do
            local tmpPurchaseListObj = MsgType.PointActivityPurchase:New()
            tmpPurchaseListObj:Decode(data.b[i])
            self.purchaseList[i] = tmpPurchaseListObj
        end
    end
    return self
end

function MsgType.PointActivityPurchasePurchaseList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.PointActivityPurchasePurchaseList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Pay_PointActivityPurchase = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_PointActivityPurchase.__index = MsgType.Request_Pay_PointActivityPurchase

function MsgType.Request_Pay_PointActivityPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_PointActivityPurchase:GetCmd()
    return MsgTypeCmd.Request_Pay_PointActivityPurchase_Cmd
end
function MsgType.Request_Pay_PointActivityPurchase:GetUrl()
    return "Request_Pay_PointActivityPurchase"
end
function MsgType.Request_Pay_PointActivityPurchase:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_PointActivityPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_PointActivityPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_PointActivityPurchase = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityFlag = 0,
    purchaseRemainTime = 0,
    pointActivityPurchaseList = {}
}
MsgType.Response_Pay_PointActivityPurchase.__index = MsgType.Response_Pay_PointActivityPurchase
setmetatable(MsgType.Response_Pay_PointActivityPurchase.pointActivityPurchaseList, MsgType.PointActivityPurchasePurchaseList)

function MsgType.Response_Pay_PointActivityPurchase:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.pointActivityPurchaseList = MsgType.PointActivityPurchasePurchaseList:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_PointActivityPurchase:GetCmd()
    return MsgTypeCmd.Response_Pay_PointActivityPurchase_Cmd
end
function MsgType.Response_Pay_PointActivityPurchase:GetUrl()
    return "Response_Pay_PointActivityPurchase"
end
function MsgType.Response_Pay_PointActivityPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.purchaseRemainTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.pointActivityPurchaseList:Decode(data.h)
    end
    return self
end


MsgType.EOperatingActivityInfoType = {
    EquipPropertyType = 1,
    EquipPropertySubType = 2,
    EquipDrawingId = 3
}

MsgType.EOperatingActivityRewardState = {
    None = 0,
    CanReward = 1,
    Rewarded = 2,
    VipRewarded = 3
}

MsgType.EOperatingActivityExchangeState = {
    None = 0,
    Exchanged = 1
}

MsgType.OneOperatingActivityInfo = {
    rowId = 0,
    index = 0,
    id = 0,
    type = 0, --enum EOperatingActivityInfoType
    remainTime = 0
}
MsgType.OneOperatingActivityInfo.__index = MsgType.OneOperatingActivityInfo

function MsgType.OneOperatingActivityInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneOperatingActivityInfo:Encode()
    local tb = {}
    if nil ~= self.rowId and 0 ~= self.rowId then
        tb.b = self.rowId
    end
    if nil ~= self.index and 0 ~= self.index then
        tb.c = self.index
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.d = self.id
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.e = self.type
    end
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.f = self.remainTime
    end
    return tb
end

function MsgType.OneOperatingActivityInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.rowId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.index = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.id = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.type = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.remainTime = tonumber(data.f) or 0
    end
    return self
end

function MsgType.OneOperatingActivityInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneOperatingActivityInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneOperatingActivityRewardData = {
    id = 0,
    item = {},
    state = 0, --enum EOperatingActivityRewardState
    vipFlag = 0
}
MsgType.OneOperatingActivityRewardData.__index = MsgType.OneOperatingActivityRewardData
setmetatable(MsgType.OneOperatingActivityRewardData.item, MsgType.OneRewardItem)

function MsgType.OneOperatingActivityRewardData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.item = MsgType.OneRewardItem:New()
    return tb
end

function MsgType.OneOperatingActivityRewardData:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    tb.c = self.item:Encode()
    if nil ~= self.state and 0 ~= self.state then
        tb.d = self.state
    end
    if nil ~= self.vipFlag and 0 ~= self.vipFlag then
        tb.e = self.vipFlag
    end
    return tb
end

function MsgType.OneOperatingActivityRewardData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.item:Decode(data.c)
    end
    if nil ~= data.d then
        self.state = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.vipFlag = tonumber(data.e) or 0
    end
    return self
end

function MsgType.OneOperatingActivityRewardData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneOperatingActivityRewardData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneOperatingActivityRewardInfo = {
    groupId = 0,
    rewardList = {}, -- array of MsgType.OneOperatingActivityRewardData
    needPoint = 0,
    userNeedPoint = 0
}
MsgType.OneOperatingActivityRewardInfo.__index = MsgType.OneOperatingActivityRewardInfo

function MsgType.OneOperatingActivityRewardInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.rewardList = {}
    return tb
end

function MsgType.OneOperatingActivityRewardInfo:_rewardListEncode()
    local tb = {}
    for i=1, #self.rewardList do
        tb[i] = self.rewardList[i]:Encode()
    end
    return tb
end
function MsgType.OneOperatingActivityRewardInfo:Encode()
    local tb = {}
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.b = self.groupId
    end
    tb.c = self:_rewardListEncode()
    if nil ~= self.needPoint and 0 ~= self.needPoint then
        tb.d = self.needPoint
    end
    if nil ~= self.userNeedPoint and 0 ~= self.userNeedPoint then
        tb.e = self.userNeedPoint
    end
    return tb
end

function MsgType.OneOperatingActivityRewardInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.groupId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpRewardListObj = MsgType.OneOperatingActivityRewardData:New()
            tmpRewardListObj:Decode(data.c[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.d then
        self.needPoint = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.userNeedPoint = tonumber(data.e) or 0
    end
    return self
end

function MsgType.OneOperatingActivityRewardInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneOperatingActivityRewardInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OneOperatingActivityExchangeInfo = {
    index = 0,
    itemId = 0,
    itemType = 0, --enum EItemType
    cost = 0,
    state = 0 --enum EOperatingActivityExchangeState
}
MsgType.OneOperatingActivityExchangeInfo.__index = MsgType.OneOperatingActivityExchangeInfo

function MsgType.OneOperatingActivityExchangeInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneOperatingActivityExchangeInfo:Encode()
    local tb = {}
    if nil ~= self.index and 0 ~= self.index then
        tb.b = self.index
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    if nil ~= self.itemType and 0 ~= self.itemType then
        tb.d = self.itemType
    end
    if nil ~= self.cost and 0 ~= self.cost then
        tb.e = self.cost
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.f = self.state
    end
    return tb
end

function MsgType.OneOperatingActivityExchangeInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.index = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.itemType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.cost = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.state = tonumber(data.f) or 0
    end
    return self
end

function MsgType.OneOperatingActivityExchangeInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneOperatingActivityExchangeInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_OperatingActivity_Check = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity_Check.__index = MsgType.Request_OperatingActivity_Check

function MsgType.Request_OperatingActivity_Check:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_Check:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_Check_Cmd
end
function MsgType.Request_OperatingActivity_Check:GetUrl()
    return "Request_OperatingActivity_Check"
end
function MsgType.Request_OperatingActivity_Check:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity_Check:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_Check:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_Check = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    list = {} -- array of MsgType.OneOperatingActivityInfo
}
MsgType.Response_OperatingActivity_Check.__index = MsgType.Response_OperatingActivity_Check

function MsgType.Response_OperatingActivity_Check:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.list = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_Check:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_Check_Cmd
end
function MsgType.Response_OperatingActivity_Check:GetUrl()
    return "Response_OperatingActivity_Check"
end
function MsgType.Response_OperatingActivity_Check:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpListObj = MsgType.OneOperatingActivityInfo:New()
            tmpListObj:Decode(data.f[i])
            self.list[i] = tmpListObj
        end
    end
    return self
end


MsgType.Request_OperatingActivity_CheckReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity_CheckReward.__index = MsgType.Request_OperatingActivity_CheckReward

function MsgType.Request_OperatingActivity_CheckReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_CheckReward:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_CheckReward_Cmd
end
function MsgType.Request_OperatingActivity_CheckReward:GetUrl()
    return "Request_OperatingActivity_CheckReward"
end
function MsgType.Request_OperatingActivity_CheckReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity_CheckReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_CheckReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_CheckReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardList = {}, -- array of MsgType.OneOperatingActivityRewardInfo
    activityPoint = 0
}
MsgType.Response_OperatingActivity_CheckReward.__index = MsgType.Response_OperatingActivity_CheckReward

function MsgType.Response_OperatingActivity_CheckReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_CheckReward:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_CheckReward_Cmd
end
function MsgType.Response_OperatingActivity_CheckReward:GetUrl()
    return "Response_OperatingActivity_CheckReward"
end
function MsgType.Response_OperatingActivity_CheckReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardListObj = MsgType.OneOperatingActivityRewardInfo:New()
            tmpRewardListObj:Decode(data.f[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.g then
        self.activityPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_OperatingActivity_CheckExchange = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity_CheckExchange.__index = MsgType.Request_OperatingActivity_CheckExchange

function MsgType.Request_OperatingActivity_CheckExchange:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_CheckExchange:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_CheckExchange_Cmd
end
function MsgType.Request_OperatingActivity_CheckExchange:GetUrl()
    return "Request_OperatingActivity_CheckExchange"
end
function MsgType.Request_OperatingActivity_CheckExchange:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity_CheckExchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_CheckExchange:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_CheckExchange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exchangeList = {}, -- array of MsgType.OneOperatingActivityExchangeInfo
    exRefreshRemainTime = 0,
    operatingActivityCoin = 0,
    coinCheckFlag = 0
}
MsgType.Response_OperatingActivity_CheckExchange.__index = MsgType.Response_OperatingActivity_CheckExchange

function MsgType.Response_OperatingActivity_CheckExchange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchangeList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_CheckExchange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_CheckExchange_Cmd
end
function MsgType.Response_OperatingActivity_CheckExchange:GetUrl()
    return "Response_OperatingActivity_CheckExchange"
end
function MsgType.Response_OperatingActivity_CheckExchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpExchangeListObj = MsgType.OneOperatingActivityExchangeInfo:New()
            tmpExchangeListObj:Decode(data.f[i])
            self.exchangeList[i] = tmpExchangeListObj
        end
    end
    if nil ~= data.g then
        self.exRefreshRemainTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.operatingActivityCoin = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.coinCheckFlag = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_OperatingActivity_Reward = {
    msgSeq = 0,
    groupId = 0,
    id = 0
}
MsgType.Request_OperatingActivity_Reward.__index = MsgType.Request_OperatingActivity_Reward

function MsgType.Request_OperatingActivity_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_Reward:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_Reward_Cmd
end
function MsgType.Request_OperatingActivity_Reward:GetUrl()
    return "Request_OperatingActivity_Reward"
end
function MsgType.Request_OperatingActivity_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.c = self.groupId
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.d = self.id
    end
    return tb
end

function MsgType.Request_OperatingActivity_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {},
    reward = {}
}
MsgType.Response_OperatingActivity_Reward.__index = MsgType.Response_OperatingActivity_Reward
setmetatable(MsgType.Response_OperatingActivity_Reward.rewardItem, MsgType.OneOperatingActivityRewardInfo)
setmetatable(MsgType.Response_OperatingActivity_Reward.reward, MsgType.OneRewardItem)

function MsgType.Response_OperatingActivity_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneOperatingActivityRewardInfo:New()
    tb.reward = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_Reward:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_Reward_Cmd
end
function MsgType.Response_OperatingActivity_Reward:GetUrl()
    return "Response_OperatingActivity_Reward"
end
function MsgType.Response_OperatingActivity_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    if nil ~= data.g then
        self.reward:Decode(data.g)
    end
    return self
end


MsgType.Response_OperatingActivity_RewardChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {}
}
MsgType.Response_OperatingActivity_RewardChange.__index = MsgType.Response_OperatingActivity_RewardChange
setmetatable(MsgType.Response_OperatingActivity_RewardChange.rewardItem, MsgType.OneOperatingActivityRewardInfo)

function MsgType.Response_OperatingActivity_RewardChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneOperatingActivityRewardInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_RewardChange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_RewardChange_Cmd
end
function MsgType.Response_OperatingActivity_RewardChange:GetUrl()
    return "Response_OperatingActivity_RewardChange"
end
function MsgType.Response_OperatingActivity_RewardChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    return self
end


MsgType.Request_OperatingActivity_Exchange = {
    msgSeq = 0,
    index = 0
}
MsgType.Request_OperatingActivity_Exchange.__index = MsgType.Request_OperatingActivity_Exchange

function MsgType.Request_OperatingActivity_Exchange:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_Exchange:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_Exchange_Cmd
end
function MsgType.Request_OperatingActivity_Exchange:GetUrl()
    return "Request_OperatingActivity_Exchange"
end
function MsgType.Request_OperatingActivity_Exchange:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.index and 0 ~= self.index then
        tb.c = self.index
    end
    return tb
end

function MsgType.Request_OperatingActivity_Exchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_Exchange:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_Exchange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exchangeItem = {},
    exRefreshRemainTime = 0,
    operatingActivityCoin = 0
}
MsgType.Response_OperatingActivity_Exchange.__index = MsgType.Response_OperatingActivity_Exchange
setmetatable(MsgType.Response_OperatingActivity_Exchange.exchangeItem, MsgType.OneOperatingActivityExchangeInfo)

function MsgType.Response_OperatingActivity_Exchange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchangeItem = MsgType.OneOperatingActivityExchangeInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_Exchange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_Exchange_Cmd
end
function MsgType.Response_OperatingActivity_Exchange:GetUrl()
    return "Response_OperatingActivity_Exchange"
end
function MsgType.Response_OperatingActivity_Exchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exchangeItem:Decode(data.f)
    end
    if nil ~= data.g then
        self.exRefreshRemainTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.operatingActivityCoin = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_OperatingActivity_UpdateInfo = {
    msgSeq = 0,
    rowId = 0,
    index = 0
}
MsgType.Request_OperatingActivity_UpdateInfo.__index = MsgType.Request_OperatingActivity_UpdateInfo

function MsgType.Request_OperatingActivity_UpdateInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_UpdateInfo:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_UpdateInfo_Cmd
end
function MsgType.Request_OperatingActivity_UpdateInfo:GetUrl()
    return "Request_OperatingActivity_UpdateInfo"
end
function MsgType.Request_OperatingActivity_UpdateInfo:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rowId and 0 ~= self.rowId then
        tb.c = self.rowId
    end
    if nil ~= self.index and 0 ~= self.index then
        tb.d = self.index
    end
    return tb
end

function MsgType.Request_OperatingActivity_UpdateInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_UpdateInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_UpdateInfo = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    data = {}
}
MsgType.Response_OperatingActivity_UpdateInfo.__index = MsgType.Response_OperatingActivity_UpdateInfo
setmetatable(MsgType.Response_OperatingActivity_UpdateInfo.data, MsgType.OneOperatingActivityInfo)

function MsgType.Response_OperatingActivity_UpdateInfo:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.data = MsgType.OneOperatingActivityInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_UpdateInfo:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_UpdateInfo_Cmd
end
function MsgType.Response_OperatingActivity_UpdateInfo:GetUrl()
    return "Response_OperatingActivity_UpdateInfo"
end
function MsgType.Response_OperatingActivity_UpdateInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.data:Decode(data.f)
    end
    return self
end


MsgType.Request_OperatingActivity_UpdateExchange = {
    msgSeq = 0,
    coinFlag = 0,
    autoFlag = 0
}
MsgType.Request_OperatingActivity_UpdateExchange.__index = MsgType.Request_OperatingActivity_UpdateExchange

function MsgType.Request_OperatingActivity_UpdateExchange:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_UpdateExchange:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_UpdateExchange_Cmd
end
function MsgType.Request_OperatingActivity_UpdateExchange:GetUrl()
    return "Request_OperatingActivity_UpdateExchange"
end
function MsgType.Request_OperatingActivity_UpdateExchange:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.coinFlag and 0 ~= self.coinFlag then
        tb.c = self.coinFlag
    end
    if nil ~= self.autoFlag and 0 ~= self.autoFlag then
        tb.d = self.autoFlag
    end
    return tb
end

function MsgType.Request_OperatingActivity_UpdateExchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_UpdateExchange:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_UpdateExchange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exchangeList = {}, -- array of MsgType.OneOperatingActivityExchangeInfo
    exRefreshRemainTime = 0,
    coinCheckFlag = 0
}
MsgType.Response_OperatingActivity_UpdateExchange.__index = MsgType.Response_OperatingActivity_UpdateExchange

function MsgType.Response_OperatingActivity_UpdateExchange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchangeList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_UpdateExchange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_UpdateExchange_Cmd
end
function MsgType.Response_OperatingActivity_UpdateExchange:GetUrl()
    return "Response_OperatingActivity_UpdateExchange"
end
function MsgType.Response_OperatingActivity_UpdateExchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpExchangeListObj = MsgType.OneOperatingActivityExchangeInfo:New()
            tmpExchangeListObj:Decode(data.f[i])
            self.exchangeList[i] = tmpExchangeListObj
        end
    end
    if nil ~= data.g then
        self.exRefreshRemainTime = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.coinCheckFlag = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_OperatingActivity_DailyCoin = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity_DailyCoin.__index = MsgType.Request_OperatingActivity_DailyCoin

function MsgType.Request_OperatingActivity_DailyCoin:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_DailyCoin:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_DailyCoin_Cmd
end
function MsgType.Request_OperatingActivity_DailyCoin:GetUrl()
    return "Request_OperatingActivity_DailyCoin"
end
function MsgType.Request_OperatingActivity_DailyCoin:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity_DailyCoin:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_DailyCoin:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_DailyCoin = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    operatingActivityCoin = 0,
    coinCheckFlag = 0
}
MsgType.Response_OperatingActivity_DailyCoin.__index = MsgType.Response_OperatingActivity_DailyCoin

function MsgType.Response_OperatingActivity_DailyCoin:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_DailyCoin:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_DailyCoin_Cmd
end
function MsgType.Response_OperatingActivity_DailyCoin:GetUrl()
    return "Response_OperatingActivity_DailyCoin"
end
function MsgType.Response_OperatingActivity_DailyCoin:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.operatingActivityCoin = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.coinCheckFlag = tonumber(data.g) or 0
    end
    return self
end


MsgType.Response_OperatingActivity_EquipMakeInfo = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    slotId = 0,
    equipDrawingId = 0,
    makingState = 0, --enum EMakingState
    activityFlag = 0
}
MsgType.Response_OperatingActivity_EquipMakeInfo.__index = MsgType.Response_OperatingActivity_EquipMakeInfo

function MsgType.Response_OperatingActivity_EquipMakeInfo:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_EquipMakeInfo:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_EquipMakeInfo_Cmd
end
function MsgType.Response_OperatingActivity_EquipMakeInfo:GetUrl()
    return "Response_OperatingActivity_EquipMakeInfo"
end
function MsgType.Response_OperatingActivity_EquipMakeInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.slotId = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.equipDrawingId = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.makingState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.activityFlag = tonumber(data.i) or 0
    end
    return self
end


MsgType.Response_OperatingActivity_ActivityPointChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityPoint = 0,
    userActivityPoint = 0
}
MsgType.Response_OperatingActivity_ActivityPointChange.__index = MsgType.Response_OperatingActivity_ActivityPointChange

function MsgType.Response_OperatingActivity_ActivityPointChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_ActivityPointChange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_ActivityPointChange_Cmd
end
function MsgType.Response_OperatingActivity_ActivityPointChange:GetUrl()
    return "Response_OperatingActivity_ActivityPointChange"
end
function MsgType.Response_OperatingActivity_ActivityPointChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userActivityPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Response_OperatingActivity_CoinChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    operatingActivityCoin = 0
}
MsgType.Response_OperatingActivity_CoinChange.__index = MsgType.Response_OperatingActivity_CoinChange

function MsgType.Response_OperatingActivity_CoinChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_CoinChange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_CoinChange_Cmd
end
function MsgType.Response_OperatingActivity_CoinChange:GetUrl()
    return "Response_OperatingActivity_CoinChange"
end
function MsgType.Response_OperatingActivity_CoinChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.operatingActivityCoin = tonumber(data.f) or 0
    end
    return self
end


MsgType.EOperatingActivityStringType = {
    Name = 1,
    Desc = 2,
    PurchaseTitle = 3,
    Icon = 4,
    Panel = 5
}

MsgType.OneOperatingActivityStringData = {
    type = 0, --enum EOperatingActivityStringType
    CN = "",
    EN = "",
    TW = ""
}
MsgType.OneOperatingActivityStringData.__index = MsgType.OneOperatingActivityStringData

function MsgType.OneOperatingActivityStringData:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneOperatingActivityStringData:Encode()
    local tb = {}
    if nil ~= self.type and 0 ~= self.type then
        tb.b = self.type
    end
    if nil ~= self.CN and string.len(self.CN) > 0 then
        tb.c = self.CN
    end
    if nil ~= self.EN and string.len(self.EN) > 0 then
        tb.d = self.EN
    end
    if nil ~= self.TW and string.len(self.TW) > 0 then
        tb.e = self.TW
    end
    return tb
end

function MsgType.OneOperatingActivityStringData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.type = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.CN = tostring(data.c)
    end
    if nil ~= data.d then
        self.EN = tostring(data.d)
    end
    if nil ~= data.e then
        self.TW = tostring(data.e)
    end
    return self
end

function MsgType.OneOperatingActivityStringData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneOperatingActivityStringData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_OperatingActivity_DataCheck = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity_DataCheck.__index = MsgType.Request_OperatingActivity_DataCheck

function MsgType.Request_OperatingActivity_DataCheck:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_DataCheck:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_DataCheck_Cmd
end
function MsgType.Request_OperatingActivity_DataCheck:GetUrl()
    return "Request_OperatingActivity_DataCheck"
end
function MsgType.Request_OperatingActivity_DataCheck:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity_DataCheck:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_DataCheck:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_DataCheck = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityPoint = 0,
    userActivityPoint = 0,
    operatingActivityCoin = 0,
    flag = 0,
    endTime = 0,
    stringList = {}, -- array of MsgType.OneOperatingActivityStringData
    version = 0
}
MsgType.Response_OperatingActivity_DataCheck.__index = MsgType.Response_OperatingActivity_DataCheck

function MsgType.Response_OperatingActivity_DataCheck:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.stringList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_DataCheck:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_DataCheck_Cmd
end
function MsgType.Response_OperatingActivity_DataCheck:GetUrl()
    return "Response_OperatingActivity_DataCheck"
end
function MsgType.Response_OperatingActivity_DataCheck:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userActivityPoint = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.operatingActivityCoin = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.flag = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.endTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpStringListObj = MsgType.OneOperatingActivityStringData:New()
            tmpStringListObj:Decode(data.k[i])
            self.stringList[i] = tmpStringListObj
        end
    end
    if nil ~= data.l then
        self.version = tonumber(data.l) or 0
    end
    return self
end


MsgType.OneOperatingActivityUnionRankInfo = {
    rank = 0,
    userId = "",
    name = "",
    gender = 0,
    userDress = {},
    point = 0
}
MsgType.OneOperatingActivityUnionRankInfo.__index = MsgType.OneOperatingActivityUnionRankInfo
setmetatable(MsgType.OneOperatingActivityUnionRankInfo.userDress, MsgType.RoleDress)

function MsgType.OneOperatingActivityUnionRankInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.userDress = MsgType.RoleDress:New()
    return tb
end

function MsgType.OneOperatingActivityUnionRankInfo:Encode()
    local tb = {}
    if nil ~= self.rank and 0 ~= self.rank then
        tb.b = self.rank
    end
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.c = self.userId
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.d = self.name
    end
    if nil ~= self.gender and 0 ~= self.gender then
        tb.e = self.gender
    end
    tb.f = self.userDress:Encode()
    if nil ~= self.point and 0 ~= self.point then
        tb.g = self.point
    end
    return tb
end

function MsgType.OneOperatingActivityUnionRankInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.rank = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.userId = tostring(data.c)
    end
    if nil ~= data.d then
        self.name = tostring(data.d)
    end
    if nil ~= data.e then
        self.gender = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.userDress:Decode(data.f)
    end
    if nil ~= data.g then
        self.point = tonumber(data.g) or 0
    end
    return self
end

function MsgType.OneOperatingActivityUnionRankInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneOperatingActivityUnionRankInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_OperatingActivity_UnionRankList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity_UnionRankList.__index = MsgType.Request_OperatingActivity_UnionRankList

function MsgType.Request_OperatingActivity_UnionRankList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity_UnionRankList:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity_UnionRankList_Cmd
end
function MsgType.Request_OperatingActivity_UnionRankList:GetUrl()
    return "Request_OperatingActivity_UnionRankList"
end
function MsgType.Request_OperatingActivity_UnionRankList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity_UnionRankList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity_UnionRankList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity_UnionRankList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rankList = {}, -- array of MsgType.OneOperatingActivityUnionRankInfo
    userRank = {}
}
MsgType.Response_OperatingActivity_UnionRankList.__index = MsgType.Response_OperatingActivity_UnionRankList
setmetatable(MsgType.Response_OperatingActivity_UnionRankList.userRank, MsgType.OneOperatingActivityUnionRankInfo)

function MsgType.Response_OperatingActivity_UnionRankList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rankList = {}
    tb.userRank = MsgType.OneOperatingActivityUnionRankInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity_UnionRankList:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity_UnionRankList_Cmd
end
function MsgType.Response_OperatingActivity_UnionRankList:GetUrl()
    return "Response_OperatingActivity_UnionRankList"
end
function MsgType.Response_OperatingActivity_UnionRankList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRankListObj = MsgType.OneOperatingActivityUnionRankInfo:New()
            tmpRankListObj:Decode(data.f[i])
            self.rankList[i] = tmpRankListObj
        end
    end
    if nil ~= data.g then
        self.userRank:Decode(data.g)
    end
    return self
end


MsgType.Request_OperatingActivity2_DataCheck = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity2_DataCheck.__index = MsgType.Request_OperatingActivity2_DataCheck

function MsgType.Request_OperatingActivity2_DataCheck:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_DataCheck:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_DataCheck_Cmd
end
function MsgType.Request_OperatingActivity2_DataCheck:GetUrl()
    return "Request_OperatingActivity2_DataCheck"
end
function MsgType.Request_OperatingActivity2_DataCheck:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity2_DataCheck:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_DataCheck:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_DataCheck = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityPoint = 0,
    userActivityPoint = 0,
    flag = 0,
    checkFlag = 0,
    endTime = 0,
    stringList = {}, -- array of MsgType.OneOperatingActivityStringData
    version = 0,
    bossId = 0,
    process = 0
}
MsgType.Response_OperatingActivity2_DataCheck.__index = MsgType.Response_OperatingActivity2_DataCheck

function MsgType.Response_OperatingActivity2_DataCheck:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.stringList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_DataCheck:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_DataCheck_Cmd
end
function MsgType.Response_OperatingActivity2_DataCheck:GetUrl()
    return "Response_OperatingActivity2_DataCheck"
end
function MsgType.Response_OperatingActivity2_DataCheck:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userActivityPoint = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.flag = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.checkFlag = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.endTime = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        for i=1, #data.k do
            local tmpStringListObj = MsgType.OneOperatingActivityStringData:New()
            tmpStringListObj:Decode(data.k[i])
            self.stringList[i] = tmpStringListObj
        end
    end
    if nil ~= data.l then
        self.version = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.bossId = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.process = tonumber(data.n) or 0
    end
    return self
end


MsgType.Request_OperatingActivity2_CheckReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity2_CheckReward.__index = MsgType.Request_OperatingActivity2_CheckReward

function MsgType.Request_OperatingActivity2_CheckReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_CheckReward:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_CheckReward_Cmd
end
function MsgType.Request_OperatingActivity2_CheckReward:GetUrl()
    return "Request_OperatingActivity2_CheckReward"
end
function MsgType.Request_OperatingActivity2_CheckReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity2_CheckReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_CheckReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_CheckReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardList = {}, -- array of MsgType.OneOperatingActivityRewardInfo
    activityPoint = 0
}
MsgType.Response_OperatingActivity2_CheckReward.__index = MsgType.Response_OperatingActivity2_CheckReward

function MsgType.Response_OperatingActivity2_CheckReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_CheckReward:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_CheckReward_Cmd
end
function MsgType.Response_OperatingActivity2_CheckReward:GetUrl()
    return "Response_OperatingActivity2_CheckReward"
end
function MsgType.Response_OperatingActivity2_CheckReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardListObj = MsgType.OneOperatingActivityRewardInfo:New()
            tmpRewardListObj:Decode(data.f[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.g then
        self.activityPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_OperatingActivity2_Reward = {
    msgSeq = 0,
    groupId = 0,
    id = 0
}
MsgType.Request_OperatingActivity2_Reward.__index = MsgType.Request_OperatingActivity2_Reward

function MsgType.Request_OperatingActivity2_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_Reward:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_Reward_Cmd
end
function MsgType.Request_OperatingActivity2_Reward:GetUrl()
    return "Request_OperatingActivity2_Reward"
end
function MsgType.Request_OperatingActivity2_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.c = self.groupId
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.d = self.id
    end
    return tb
end

function MsgType.Request_OperatingActivity2_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {},
    reward = {}
}
MsgType.Response_OperatingActivity2_Reward.__index = MsgType.Response_OperatingActivity2_Reward
setmetatable(MsgType.Response_OperatingActivity2_Reward.rewardItem, MsgType.OneOperatingActivityRewardInfo)
setmetatable(MsgType.Response_OperatingActivity2_Reward.reward, MsgType.OneRewardItem)

function MsgType.Response_OperatingActivity2_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneOperatingActivityRewardInfo:New()
    tb.reward = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_Reward:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_Reward_Cmd
end
function MsgType.Response_OperatingActivity2_Reward:GetUrl()
    return "Response_OperatingActivity2_Reward"
end
function MsgType.Response_OperatingActivity2_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    if nil ~= data.g then
        self.reward:Decode(data.g)
    end
    return self
end


MsgType.Response_OperatingActivity2_ActivityPointChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityPoint = 0,
    userActivityPoint = 0
}
MsgType.Response_OperatingActivity2_ActivityPointChange.__index = MsgType.Response_OperatingActivity2_ActivityPointChange

function MsgType.Response_OperatingActivity2_ActivityPointChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_ActivityPointChange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_ActivityPointChange_Cmd
end
function MsgType.Response_OperatingActivity2_ActivityPointChange:GetUrl()
    return "Response_OperatingActivity2_ActivityPointChange"
end
function MsgType.Response_OperatingActivity2_ActivityPointChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userActivityPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Response_OperatingActivity2_RewardChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {}
}
MsgType.Response_OperatingActivity2_RewardChange.__index = MsgType.Response_OperatingActivity2_RewardChange
setmetatable(MsgType.Response_OperatingActivity2_RewardChange.rewardItem, MsgType.OneOperatingActivityRewardInfo)

function MsgType.Response_OperatingActivity2_RewardChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneOperatingActivityRewardInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_RewardChange:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_RewardChange_Cmd
end
function MsgType.Response_OperatingActivity2_RewardChange:GetUrl()
    return "Response_OperatingActivity2_RewardChange"
end
function MsgType.Response_OperatingActivity2_RewardChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    return self
end


MsgType.Request_OperatingActivity2_DailyReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity2_DailyReward.__index = MsgType.Request_OperatingActivity2_DailyReward

function MsgType.Request_OperatingActivity2_DailyReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_DailyReward:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_DailyReward_Cmd
end
function MsgType.Request_OperatingActivity2_DailyReward:GetUrl()
    return "Request_OperatingActivity2_DailyReward"
end
function MsgType.Request_OperatingActivity2_DailyReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity2_DailyReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_DailyReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_DailyReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    item = {},
    checkFlag = 0
}
MsgType.Response_OperatingActivity2_DailyReward.__index = MsgType.Response_OperatingActivity2_DailyReward
setmetatable(MsgType.Response_OperatingActivity2_DailyReward.item, MsgType.OneRewardItem)

function MsgType.Response_OperatingActivity2_DailyReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.item = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_DailyReward:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_DailyReward_Cmd
end
function MsgType.Response_OperatingActivity2_DailyReward:GetUrl()
    return "Response_OperatingActivity2_DailyReward"
end
function MsgType.Response_OperatingActivity2_DailyReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.item:Decode(data.f)
    end
    if nil ~= data.g then
        self.checkFlag = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_OperatingActivity2_UnionRankList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_OperatingActivity2_UnionRankList.__index = MsgType.Request_OperatingActivity2_UnionRankList

function MsgType.Request_OperatingActivity2_UnionRankList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_UnionRankList:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_UnionRankList_Cmd
end
function MsgType.Request_OperatingActivity2_UnionRankList:GetUrl()
    return "Request_OperatingActivity2_UnionRankList"
end
function MsgType.Request_OperatingActivity2_UnionRankList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_OperatingActivity2_UnionRankList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_UnionRankList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_UnionRankList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rankList = {}, -- array of MsgType.OneOperatingActivityUnionRankInfo
    userRank = {}
}
MsgType.Response_OperatingActivity2_UnionRankList.__index = MsgType.Response_OperatingActivity2_UnionRankList
setmetatable(MsgType.Response_OperatingActivity2_UnionRankList.userRank, MsgType.OneOperatingActivityUnionRankInfo)

function MsgType.Response_OperatingActivity2_UnionRankList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rankList = {}
    tb.userRank = MsgType.OneOperatingActivityUnionRankInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_UnionRankList:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_UnionRankList_Cmd
end
function MsgType.Response_OperatingActivity2_UnionRankList:GetUrl()
    return "Response_OperatingActivity2_UnionRankList"
end
function MsgType.Response_OperatingActivity2_UnionRankList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRankListObj = MsgType.OneOperatingActivityUnionRankInfo:New()
            tmpRankListObj:Decode(data.f[i])
            self.rankList[i] = tmpRankListObj
        end
    end
    if nil ~= data.g then
        self.userRank:Decode(data.g)
    end
    return self
end


MsgType.Request_OperatingActivity2_ExploreStart = {
    msgSeq = 0,
    exploreSlotId = 0,
    exploreId = 0,
    exploreType = 0,
    useItemId = 0,
    heroInfoUIds = ""
}
MsgType.Request_OperatingActivity2_ExploreStart.__index = MsgType.Request_OperatingActivity2_ExploreStart

function MsgType.Request_OperatingActivity2_ExploreStart:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_ExploreStart:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_ExploreStart_Cmd
end
function MsgType.Request_OperatingActivity2_ExploreStart:GetUrl()
    return "Request_OperatingActivity2_ExploreStart"
end
function MsgType.Request_OperatingActivity2_ExploreStart:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exploreSlotId and 0 ~= self.exploreSlotId then
        tb.c = self.exploreSlotId
    end
    if nil ~= self.exploreId and 0 ~= self.exploreId then
        tb.d = self.exploreId
    end
    if nil ~= self.exploreType and 0 ~= self.exploreType then
        tb.e = self.exploreType
    end
    if nil ~= self.useItemId and 0 ~= self.useItemId then
        tb.f = self.useItemId
    end
    if nil ~= self.heroInfoUIds and string.len(self.heroInfoUIds) > 0 then
        tb.g = self.heroInfoUIds
    end
    return tb
end

function MsgType.Request_OperatingActivity2_ExploreStart:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_ExploreStart:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_ExploreStart = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {},
    heroInfo = {} -- array of MsgType.HeroInfo
}
MsgType.Response_OperatingActivity2_ExploreStart.__index = MsgType.Response_OperatingActivity2_ExploreStart
setmetatable(MsgType.Response_OperatingActivity2_ExploreStart.exploreSlot, MsgType.ExploreSlot)

function MsgType.Response_OperatingActivity2_ExploreStart:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    tb.heroInfo = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_ExploreStart:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_ExploreStart_Cmd
end
function MsgType.Response_OperatingActivity2_ExploreStart:GetUrl()
    return "Response_OperatingActivity2_ExploreStart"
end
function MsgType.Response_OperatingActivity2_ExploreStart:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpHeroInfoObj = MsgType.HeroInfo:New()
            tmpHeroInfoObj:Decode(data.g[i])
            self.heroInfo[i] = tmpHeroInfoObj
        end
    end
    return self
end


MsgType.Request_OperatingActivity2_ExploreEnd = {
    msgSeq = 0,
    exploreSlotId = 0
}
MsgType.Request_OperatingActivity2_ExploreEnd.__index = MsgType.Request_OperatingActivity2_ExploreEnd

function MsgType.Request_OperatingActivity2_ExploreEnd:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_ExploreEnd:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_ExploreEnd_Cmd
end
function MsgType.Request_OperatingActivity2_ExploreEnd:GetUrl()
    return "Request_OperatingActivity2_ExploreEnd"
end
function MsgType.Request_OperatingActivity2_ExploreEnd:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exploreSlotId and 0 ~= self.exploreSlotId then
        tb.c = self.exploreSlotId
    end
    return tb
end

function MsgType.Request_OperatingActivity2_ExploreEnd:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_ExploreEnd:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_ExploreEnd = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {},
    exploreId = 0,
    resultState = 0,
    rewardList = {}, -- array of MsgType.OneRewardItem
    brokeEquipList = {}, -- array of MsgType.HeroBrokenEquip
    getMoney = 0,
    heroInfo = {}, -- array of MsgType.HeroInfo
    combatReport = {}
}
MsgType.Response_OperatingActivity2_ExploreEnd.__index = MsgType.Response_OperatingActivity2_ExploreEnd
setmetatable(MsgType.Response_OperatingActivity2_ExploreEnd.exploreSlot, MsgType.ExploreSlot)
setmetatable(MsgType.Response_OperatingActivity2_ExploreEnd.combatReport, MsgType.CombatReport)

function MsgType.Response_OperatingActivity2_ExploreEnd:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    tb.rewardList = {}
    tb.brokeEquipList = {}
    tb.heroInfo = {}
    tb.combatReport = MsgType.CombatReport:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_ExploreEnd:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_ExploreEnd_Cmd
end
function MsgType.Response_OperatingActivity2_ExploreEnd:GetUrl()
    return "Response_OperatingActivity2_ExploreEnd"
end
function MsgType.Response_OperatingActivity2_ExploreEnd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    if nil ~= data.g then
        self.exploreId = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.resultState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpBrokeEquipListObj = MsgType.HeroBrokenEquip:New()
            tmpBrokeEquipListObj:Decode(data.j[i])
            self.brokeEquipList[i] = tmpBrokeEquipListObj
        end
    end
    if nil ~= data.k then
        self.getMoney = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        for i=1, #data.l do
            local tmpHeroInfoObj = MsgType.HeroInfo:New()
            tmpHeroInfoObj:Decode(data.l[i])
            self.heroInfo[i] = tmpHeroInfoObj
        end
    end
    if nil ~= data.m then
        self.combatReport:Decode(data.m)
    end
    return self
end


MsgType.Request_OperatingActivity2_ExploreImmediately = {
    msgSeq = 0,
    slotId = 0
}
MsgType.Request_OperatingActivity2_ExploreImmediately.__index = MsgType.Request_OperatingActivity2_ExploreImmediately

function MsgType.Request_OperatingActivity2_ExploreImmediately:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_OperatingActivity2_ExploreImmediately:GetCmd()
    return MsgTypeCmd.Request_OperatingActivity2_ExploreImmediately_Cmd
end
function MsgType.Request_OperatingActivity2_ExploreImmediately:GetUrl()
    return "Request_OperatingActivity2_ExploreImmediately"
end
function MsgType.Request_OperatingActivity2_ExploreImmediately:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.c = self.slotId
    end
    return tb
end

function MsgType.Request_OperatingActivity2_ExploreImmediately:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_OperatingActivity2_ExploreImmediately:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_OperatingActivity2_ExploreImmediately = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {}
}
MsgType.Response_OperatingActivity2_ExploreImmediately.__index = MsgType.Response_OperatingActivity2_ExploreImmediately
setmetatable(MsgType.Response_OperatingActivity2_ExploreImmediately.exploreSlot, MsgType.ExploreSlot)

function MsgType.Response_OperatingActivity2_ExploreImmediately:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_OperatingActivity2_ExploreImmediately:GetCmd()
    return MsgTypeCmd.Response_OperatingActivity2_ExploreImmediately_Cmd
end
function MsgType.Response_OperatingActivity2_ExploreImmediately:GetUrl()
    return "Response_OperatingActivity2_ExploreImmediately"
end
function MsgType.Response_OperatingActivity2_ExploreImmediately:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    return self
end


MsgType.EAdType = {
    Prize = 1,
    PrizeChange = 2,
    DailyBox = 3
}

MsgType.Request_AD_Start = {
    msgSeq = 0,
    adType = 0 --enum EAdType
}
MsgType.Request_AD_Start.__index = MsgType.Request_AD_Start

function MsgType.Request_AD_Start:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_AD_Start:GetCmd()
    return MsgTypeCmd.Request_AD_Start_Cmd
end
function MsgType.Request_AD_Start:GetUrl()
    return "Request_AD_Start"
end
function MsgType.Request_AD_Start:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.adType and 0 ~= self.adType then
        tb.c = self.adType
    end
    return tb
end

function MsgType.Request_AD_Start:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_AD_Start:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_AD_Start = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    adType = 0, --enum EAdType
    adId = ""
}
MsgType.Response_AD_Start.__index = MsgType.Response_AD_Start

function MsgType.Response_AD_Start:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_AD_Start:GetCmd()
    return MsgTypeCmd.Response_AD_Start_Cmd
end
function MsgType.Response_AD_Start:GetUrl()
    return "Response_AD_Start"
end
function MsgType.Response_AD_Start:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.adType = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.adId = tostring(data.g)
    end
    return self
end


MsgType.Request_AD_End = {
    msgSeq = 0,
    adType = 0, --enum EAdType
    adId = "",
    option1 = "",
    option2 = "",
    option3 = "",
    option4 = "",
    option5 = ""
}
MsgType.Request_AD_End.__index = MsgType.Request_AD_End

function MsgType.Request_AD_End:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_AD_End:GetCmd()
    return MsgTypeCmd.Request_AD_End_Cmd
end
function MsgType.Request_AD_End:GetUrl()
    return "Request_AD_End"
end
function MsgType.Request_AD_End:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.adType and 0 ~= self.adType then
        tb.c = self.adType
    end
    if nil ~= self.adId and string.len(self.adId) > 0 then
        tb.d = self.adId
    end
    if nil ~= self.option1 and string.len(self.option1) > 0 then
        tb.e = self.option1
    end
    if nil ~= self.option2 and string.len(self.option2) > 0 then
        tb.f = self.option2
    end
    if nil ~= self.option3 and string.len(self.option3) > 0 then
        tb.g = self.option3
    end
    if nil ~= self.option4 and string.len(self.option4) > 0 then
        tb.h = self.option4
    end
    if nil ~= self.option5 and string.len(self.option5) > 0 then
        tb.i = self.option5
    end
    return tb
end

function MsgType.Request_AD_End:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_AD_End:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_AD_End = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    adType = 0 --enum EAdType
}
MsgType.Response_AD_End.__index = MsgType.Response_AD_End

function MsgType.Response_AD_End:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_AD_End:GetCmd()
    return MsgTypeCmd.Response_AD_End_Cmd
end
function MsgType.Response_AD_End:GetUrl()
    return "Response_AD_End"
end
function MsgType.Response_AD_End:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.adType = tonumber(data.f) or 0
    end
    return self
end


MsgType.OneAdInfo = {
    adType = 0, --enum EAdType
    adCount = 0,
    adTotalCount = 0,
    adDayRemain = 0,
    vipCount = 0,
    vipTotalCount = 0,
    vipDayRemain = 0
}
MsgType.OneAdInfo.__index = MsgType.OneAdInfo

function MsgType.OneAdInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneAdInfo:Encode()
    local tb = {}
    if nil ~= self.adType and 0 ~= self.adType then
        tb.b = self.adType
    end
    if nil ~= self.adCount and 0 ~= self.adCount then
        tb.c = self.adCount
    end
    if nil ~= self.adTotalCount and 0 ~= self.adTotalCount then
        tb.d = self.adTotalCount
    end
    if nil ~= self.adDayRemain and 0 ~= self.adDayRemain then
        tb.e = self.adDayRemain
    end
    if nil ~= self.vipCount and 0 ~= self.vipCount then
        tb.f = self.vipCount
    end
    if nil ~= self.vipTotalCount and 0 ~= self.vipTotalCount then
        tb.g = self.vipTotalCount
    end
    if nil ~= self.vipDayRemain and 0 ~= self.vipDayRemain then
        tb.h = self.vipDayRemain
    end
    return tb
end

function MsgType.OneAdInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.adType = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.adCount = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.adTotalCount = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.adDayRemain = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.vipCount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.vipTotalCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.vipDayRemain = tonumber(data.h) or 0
    end
    return self
end

function MsgType.OneAdInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneAdInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_AD_UserData = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_AD_UserData.__index = MsgType.Request_AD_UserData

function MsgType.Request_AD_UserData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_AD_UserData:GetCmd()
    return MsgTypeCmd.Request_AD_UserData_Cmd
end
function MsgType.Request_AD_UserData:GetUrl()
    return "Request_AD_UserData"
end
function MsgType.Request_AD_UserData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_AD_UserData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_AD_UserData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_AD_UserData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    adLevel = 0,
    adList = {} -- array of MsgType.OneAdInfo
}
MsgType.Response_AD_UserData.__index = MsgType.Response_AD_UserData

function MsgType.Response_AD_UserData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.adList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_AD_UserData:GetCmd()
    return MsgTypeCmd.Response_AD_UserData_Cmd
end
function MsgType.Response_AD_UserData:GetUrl()
    return "Response_AD_UserData"
end
function MsgType.Response_AD_UserData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.adLevel = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpAdListObj = MsgType.OneAdInfo:New()
            tmpAdListObj:Decode(data.g[i])
            self.adList[i] = tmpAdListObj
        end
    end
    return self
end


MsgType.EOnlineRewardState = {
    WaitTime = 0,
    CanReward = 1,
    NextDay = 2
}

MsgType.EOnlineRewardType = {
    Beginner = 1,
    Activity1 = 2
}

MsgType.OneOnlineRewardInfo = {
    rewardIndex = 0,
    rewardId = 0,
    rewardType = 0,
    rewardItemId = 0,
    rewardCount = 0,
    rewardState = 0, --enum EOnlineRewardState
    remainTime = 0,
    nameCn = "",
    nameEn = "",
    nameTw = "",
    type = 0, --enum EOnlineRewardType
    startTime = 0,
    endTime = 0,
    endRemainTime = 0
}
MsgType.OneOnlineRewardInfo.__index = MsgType.OneOnlineRewardInfo

function MsgType.OneOnlineRewardInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneOnlineRewardInfo:Encode()
    local tb = {}
    if nil ~= self.rewardIndex and 0 ~= self.rewardIndex then
        tb.b = self.rewardIndex
    end
    if nil ~= self.rewardId and 0 ~= self.rewardId then
        tb.c = self.rewardId
    end
    if nil ~= self.rewardType and 0 ~= self.rewardType then
        tb.d = self.rewardType
    end
    if nil ~= self.rewardItemId and 0 ~= self.rewardItemId then
        tb.e = self.rewardItemId
    end
    if nil ~= self.rewardCount and 0 ~= self.rewardCount then
        tb.f = self.rewardCount
    end
    if nil ~= self.rewardState and 0 ~= self.rewardState then
        tb.g = self.rewardState
    end
    if nil ~= self.remainTime and 0 ~= self.remainTime then
        tb.h = self.remainTime
    end
    if nil ~= self.nameCn and string.len(self.nameCn) > 0 then
        tb.i = self.nameCn
    end
    if nil ~= self.nameEn and string.len(self.nameEn) > 0 then
        tb.j = self.nameEn
    end
    if nil ~= self.nameTw and string.len(self.nameTw) > 0 then
        tb.k = self.nameTw
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.l = self.type
    end
    if nil ~= self.startTime and 0 ~= self.startTime then
        tb.m = self.startTime
    end
    if nil ~= self.endTime and 0 ~= self.endTime then
        tb.n = self.endTime
    end
    if nil ~= self.endRemainTime and 0 ~= self.endRemainTime then
        tb.o = self.endRemainTime
    end
    return tb
end

function MsgType.OneOnlineRewardInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.rewardIndex = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.rewardId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.rewardType = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.rewardItemId = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.rewardCount = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.rewardState = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.remainTime = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.nameCn = tostring(data.i)
    end
    if nil ~= data.j then
        self.nameEn = tostring(data.j)
    end
    if nil ~= data.k then
        self.nameTw = tostring(data.k)
    end
    if nil ~= data.l then
        self.type = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.startTime = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.endTime = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.endRemainTime = tonumber(data.o) or 0
    end
    return self
end

function MsgType.OneOnlineRewardInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneOnlineRewardInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_OnlineRewardList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_OnlineRewardList.__index = MsgType.Request_User_OnlineRewardList

function MsgType.Request_User_OnlineRewardList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_OnlineRewardList:GetCmd()
    return MsgTypeCmd.Request_User_OnlineRewardList_Cmd
end
function MsgType.Request_User_OnlineRewardList:GetUrl()
    return "Request_User_OnlineRewardList"
end
function MsgType.Request_User_OnlineRewardList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_OnlineRewardList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_OnlineRewardList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_OnlineRewardList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    onlineRewardList = {} -- array of MsgType.OneOnlineRewardInfo
}
MsgType.Response_User_OnlineRewardList.__index = MsgType.Response_User_OnlineRewardList

function MsgType.Response_User_OnlineRewardList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.onlineRewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_OnlineRewardList:GetCmd()
    return MsgTypeCmd.Response_User_OnlineRewardList_Cmd
end
function MsgType.Response_User_OnlineRewardList:GetUrl()
    return "Response_User_OnlineRewardList"
end
function MsgType.Response_User_OnlineRewardList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpOnlineRewardListObj = MsgType.OneOnlineRewardInfo:New()
            tmpOnlineRewardListObj:Decode(data.f[i])
            self.onlineRewardList[i] = tmpOnlineRewardListObj
        end
    end
    return self
end


MsgType.Request_User_OnlineRewardListReward = {
    msgSeq = 0,
    rewardIndex = 0
}
MsgType.Request_User_OnlineRewardListReward.__index = MsgType.Request_User_OnlineRewardListReward

function MsgType.Request_User_OnlineRewardListReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_OnlineRewardListReward:GetCmd()
    return MsgTypeCmd.Request_User_OnlineRewardListReward_Cmd
end
function MsgType.Request_User_OnlineRewardListReward:GetUrl()
    return "Request_User_OnlineRewardListReward"
end
function MsgType.Request_User_OnlineRewardListReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rewardIndex and 0 ~= self.rewardIndex then
        tb.c = self.rewardIndex
    end
    return tb
end

function MsgType.Request_User_OnlineRewardListReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_OnlineRewardListReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_OnlineRewardListReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    onlineRewardList = {}, -- array of MsgType.OneOnlineRewardInfo
    rewardItem = {}
}
MsgType.Response_User_OnlineRewardListReward.__index = MsgType.Response_User_OnlineRewardListReward
setmetatable(MsgType.Response_User_OnlineRewardListReward.rewardItem, MsgType.OneRewardItem)

function MsgType.Response_User_OnlineRewardListReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.onlineRewardList = {}
    tb.rewardItem = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_OnlineRewardListReward:GetCmd()
    return MsgTypeCmd.Response_User_OnlineRewardListReward_Cmd
end
function MsgType.Response_User_OnlineRewardListReward:GetUrl()
    return "Response_User_OnlineRewardListReward"
end
function MsgType.Response_User_OnlineRewardListReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpOnlineRewardListObj = MsgType.OneOnlineRewardInfo:New()
            tmpOnlineRewardListObj:Decode(data.f[i])
            self.onlineRewardList[i] = tmpOnlineRewardListObj
        end
    end
    if nil ~= data.g then
        self.rewardItem:Decode(data.g)
    end
    return self
end


MsgType.ERankListType = {
    PlayerWorth = 1,
    PlayerProsperity = 2,
    UnionWorth = 3,
    HeroFight = 4
}

MsgType.OneRankInfo = {
    rank = 0,
    userId = "",
    name = "",
    unionName = "",
    number = 0,
    userDress = {},
    gender = 0, --enum EGender
    heroUid = "",
    heroEquipList = {}, -- array of number
    heroId = 0
}
MsgType.OneRankInfo.__index = MsgType.OneRankInfo
setmetatable(MsgType.OneRankInfo.userDress, MsgType.RoleDress)

function MsgType.OneRankInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.userDress = MsgType.RoleDress:New()
    tb.heroEquipList = {}
    return tb
end

function MsgType.OneRankInfo:Encode()
    local tb = {}
    if nil ~= self.rank and 0 ~= self.rank then
        tb.b = self.rank
    end
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.c = self.userId
    end
    if nil ~= self.name and string.len(self.name) > 0 then
        tb.d = self.name
    end
    if nil ~= self.unionName and string.len(self.unionName) > 0 then
        tb.e = self.unionName
    end
    if nil ~= self.number and 0 ~= self.number then
        tb.f = self.number
    end
    tb.g = self.userDress:Encode()
    if nil ~= self.gender and 0 ~= self.gender then
        tb.h = self.gender
    end
    if nil ~= self.heroUid and string.len(self.heroUid) > 0 then
        tb.i = self.heroUid
    end
    if nil ~= self.heroEquipList and #self.heroEquipList > 0 then
        for i=1, #self.heroEquipList do
            tb.e[i] = tonumber(self.heroEquipList[i])
        end
    end
    if nil ~= self.heroId and 0 ~= self.heroId then
        tb.k = self.heroId
    end
    return tb
end

function MsgType.OneRankInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.rank = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.userId = tostring(data.c)
    end
    if nil ~= data.d then
        self.name = tostring(data.d)
    end
    if nil ~= data.e then
        self.unionName = tostring(data.e)
    end
    if nil ~= data.f then
        self.number = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userDress:Decode(data.g)
    end
    if nil ~= data.h then
        self.gender = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.heroUid = tostring(data.i)
    end
    if nil ~= data.j and #data.j > 0 then
        for i=1, #data.j do
            self.heroEquipList[i] = tonumber(data.j[i])
        end
    end
    if nil ~= data.k then
        self.heroId = tonumber(data.k) or 0
    end
    return self
end

function MsgType.OneRankInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneRankInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_User_SearchHeroInfo = {
    msgSeq = 0,
    userId = "",
    heroUid = ""
}
MsgType.Request_User_SearchHeroInfo.__index = MsgType.Request_User_SearchHeroInfo

function MsgType.Request_User_SearchHeroInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_SearchHeroInfo:GetCmd()
    return MsgTypeCmd.Request_User_SearchHeroInfo_Cmd
end
function MsgType.Request_User_SearchHeroInfo:GetUrl()
    return "Request_User_SearchHeroInfo"
end
function MsgType.Request_User_SearchHeroInfo:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.userId and string.len(self.userId) > 0 then
        tb.c = self.userId
    end
    if nil ~= self.heroUid and string.len(self.heroUid) > 0 then
        tb.d = self.heroUid
    end
    return tb
end

function MsgType.Request_User_SearchHeroInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_SearchHeroInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_SearchHeroInfo = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userId = "",
    name = "",
    heroInfo = {}
}
MsgType.Response_User_SearchHeroInfo.__index = MsgType.Response_User_SearchHeroInfo
setmetatable(MsgType.Response_User_SearchHeroInfo.heroInfo, MsgType.HeroInfo)

function MsgType.Response_User_SearchHeroInfo:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroInfo = MsgType.HeroInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_SearchHeroInfo:GetCmd()
    return MsgTypeCmd.Response_User_SearchHeroInfo_Cmd
end
function MsgType.Response_User_SearchHeroInfo:GetUrl()
    return "Response_User_SearchHeroInfo"
end
function MsgType.Response_User_SearchHeroInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userId = tostring(data.f)
    end
    if nil ~= data.g then
        self.name = tostring(data.g)
    end
    if nil ~= data.h then
        self.heroInfo:Decode(data.h)
    end
    return self
end


MsgType.Request_User_RankList = {
    msgSeq = 0,
    rankListType = 0 --enum ERankListType
}
MsgType.Request_User_RankList.__index = MsgType.Request_User_RankList

function MsgType.Request_User_RankList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_RankList:GetCmd()
    return MsgTypeCmd.Request_User_RankList_Cmd
end
function MsgType.Request_User_RankList:GetUrl()
    return "Request_User_RankList"
end
function MsgType.Request_User_RankList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.rankListType and 0 ~= self.rankListType then
        tb.c = self.rankListType
    end
    return tb
end

function MsgType.Request_User_RankList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_RankList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_RankList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rankList = {}, -- array of MsgType.OneRankInfo
    userRank = {},
    rankId = 0,
    rankListType = 0 --enum ERankListType
}
MsgType.Response_User_RankList.__index = MsgType.Response_User_RankList
setmetatable(MsgType.Response_User_RankList.userRank, MsgType.OneRankInfo)

function MsgType.Response_User_RankList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rankList = {}
    tb.userRank = MsgType.OneRankInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_RankList:GetCmd()
    return MsgTypeCmd.Response_User_RankList_Cmd
end
function MsgType.Response_User_RankList:GetUrl()
    return "Response_User_RankList"
end
function MsgType.Response_User_RankList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRankListObj = MsgType.OneRankInfo:New()
            tmpRankListObj:Decode(data.f[i])
            self.rankList[i] = tmpRankListObj
        end
    end
    if nil ~= data.g then
        self.userRank:Decode(data.g)
    end
    if nil ~= data.h then
        self.rankId = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.rankListType = tonumber(data.i) or 0
    end
    return self
end


MsgType.Response_User_ProsperityLevelUp = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    level = 0
}
MsgType.Response_User_ProsperityLevelUp.__index = MsgType.Response_User_ProsperityLevelUp

function MsgType.Response_User_ProsperityLevelUp:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_ProsperityLevelUp:GetCmd()
    return MsgTypeCmd.Response_User_ProsperityLevelUp_Cmd
end
function MsgType.Response_User_ProsperityLevelUp:GetUrl()
    return "Response_User_ProsperityLevelUp"
end
function MsgType.Response_User_ProsperityLevelUp:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.level = tonumber(data.f) or 0
    end
    return self
end


MsgType.EShopperLevelRewardState = {
    None = 0,
    Idle = 1,
    CanReward = 2,
    Rewarded = 3
}

MsgType.OneShopperLevelRewardInfo = {
    id = 0,
    state = 0 --enum EShopperLevelRewardState
}
MsgType.OneShopperLevelRewardInfo.__index = MsgType.OneShopperLevelRewardInfo

function MsgType.OneShopperLevelRewardInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneShopperLevelRewardInfo:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.c = self.state
    end
    return tb
end

function MsgType.OneShopperLevelRewardInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.state = tonumber(data.c) or 0
    end
    return self
end

function MsgType.OneShopperLevelRewardInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneShopperLevelRewardInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Pay_ShopperLevelPurchase = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Pay_ShopperLevelPurchase.__index = MsgType.Request_Pay_ShopperLevelPurchase

function MsgType.Request_Pay_ShopperLevelPurchase:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Pay_ShopperLevelPurchase:GetCmd()
    return MsgTypeCmd.Request_Pay_ShopperLevelPurchase_Cmd
end
function MsgType.Request_Pay_ShopperLevelPurchase:GetUrl()
    return "Request_Pay_ShopperLevelPurchase"
end
function MsgType.Request_Pay_ShopperLevelPurchase:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Pay_ShopperLevelPurchase:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Pay_ShopperLevelPurchase:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Pay_ShopperLevelPurchase = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    flag = "",
    googleOrderInfo = "",
    iosOrderInfo = "",
    payActivityId = 0,
    rewardList = {} -- array of MsgType.OneShopperLevelRewardInfo
}
MsgType.Response_Pay_ShopperLevelPurchase.__index = MsgType.Response_Pay_ShopperLevelPurchase

function MsgType.Response_Pay_ShopperLevelPurchase:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Pay_ShopperLevelPurchase:GetCmd()
    return MsgTypeCmd.Response_Pay_ShopperLevelPurchase_Cmd
end
function MsgType.Response_Pay_ShopperLevelPurchase:GetUrl()
    return "Response_Pay_ShopperLevelPurchase"
end
function MsgType.Response_Pay_ShopperLevelPurchase:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.flag = tostring(data.f)
    end
    if nil ~= data.g then
        self.googleOrderInfo = tostring(data.g)
    end
    if nil ~= data.h then
        self.iosOrderInfo = tostring(data.h)
    end
    if nil ~= data.i then
        self.payActivityId = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpRewardListObj = MsgType.OneShopperLevelRewardInfo:New()
            tmpRewardListObj:Decode(data.j[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    return self
end


MsgType.Request_User_ShopperLevelPurchaseReward = {
    msgSeq = 0,
    id = 0
}
MsgType.Request_User_ShopperLevelPurchaseReward.__index = MsgType.Request_User_ShopperLevelPurchaseReward

function MsgType.Request_User_ShopperLevelPurchaseReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_ShopperLevelPurchaseReward:GetCmd()
    return MsgTypeCmd.Request_User_ShopperLevelPurchaseReward_Cmd
end
function MsgType.Request_User_ShopperLevelPurchaseReward:GetUrl()
    return "Request_User_ShopperLevelPurchaseReward"
end
function MsgType.Request_User_ShopperLevelPurchaseReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.id and 0 ~= self.id then
        tb.c = self.id
    end
    return tb
end

function MsgType.Request_User_ShopperLevelPurchaseReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_ShopperLevelPurchaseReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_ShopperLevelPurchaseReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardList = {}, -- array of MsgType.OneShopperLevelRewardInfo
    rewardItemList = {} -- array of MsgType.OneRewardItem
}
MsgType.Response_User_ShopperLevelPurchaseReward.__index = MsgType.Response_User_ShopperLevelPurchaseReward

function MsgType.Response_User_ShopperLevelPurchaseReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    tb.rewardItemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_ShopperLevelPurchaseReward:GetCmd()
    return MsgTypeCmd.Response_User_ShopperLevelPurchaseReward_Cmd
end
function MsgType.Response_User_ShopperLevelPurchaseReward:GetUrl()
    return "Response_User_ShopperLevelPurchaseReward"
end
function MsgType.Response_User_ShopperLevelPurchaseReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRewardListObj = MsgType.OneShopperLevelRewardInfo:New()
            tmpRewardListObj:Decode(data.f[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardItemListObj = MsgType.OneRewardItem:New()
            tmpRewardItemListObj:Decode(data.g[i])
            self.rewardItemList[i] = tmpRewardItemListObj
        end
    end
    return self
end


MsgType.EUserDailyBoxState = {
    None = 1,
    Free = 2,
    Ad = 3,
    Vip = 4
}

MsgType.EUserDailyBoxRewardType = {
    Free = 2,
    Ad = 3,
    Vip = 4
}

MsgType.Request_User_DailyBoxInfo = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_User_DailyBoxInfo.__index = MsgType.Request_User_DailyBoxInfo

function MsgType.Request_User_DailyBoxInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_DailyBoxInfo:GetCmd()
    return MsgTypeCmd.Request_User_DailyBoxInfo_Cmd
end
function MsgType.Request_User_DailyBoxInfo:GetUrl()
    return "Request_User_DailyBoxInfo"
end
function MsgType.Request_User_DailyBoxInfo:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_User_DailyBoxInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_DailyBoxInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_DailyBoxInfo = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    dailyBoxState = 0, --enum EUserDailyBoxState
    vipBoxState = 0 --enum EUserDailyBoxState
}
MsgType.Response_User_DailyBoxInfo.__index = MsgType.Response_User_DailyBoxInfo

function MsgType.Response_User_DailyBoxInfo:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_DailyBoxInfo:GetCmd()
    return MsgTypeCmd.Response_User_DailyBoxInfo_Cmd
end
function MsgType.Response_User_DailyBoxInfo:GetUrl()
    return "Response_User_DailyBoxInfo"
end
function MsgType.Response_User_DailyBoxInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.dailyBoxState = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.vipBoxState = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_User_DailyBoxReward = {
    msgSeq = 0,
    type = 0 --enum EUserDailyBoxRewardType
}
MsgType.Request_User_DailyBoxReward.__index = MsgType.Request_User_DailyBoxReward

function MsgType.Request_User_DailyBoxReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_User_DailyBoxReward:GetCmd()
    return MsgTypeCmd.Request_User_DailyBoxReward_Cmd
end
function MsgType.Request_User_DailyBoxReward:GetUrl()
    return "Request_User_DailyBoxReward"
end
function MsgType.Request_User_DailyBoxReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    return tb
end

function MsgType.Request_User_DailyBoxReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_User_DailyBoxReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_User_DailyBoxReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {}
}
MsgType.Response_User_DailyBoxReward.__index = MsgType.Response_User_DailyBoxReward
setmetatable(MsgType.Response_User_DailyBoxReward.rewardItem, MsgType.OneRewardItem)

function MsgType.Response_User_DailyBoxReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_User_DailyBoxReward:GetCmd()
    return MsgTypeCmd.Response_User_DailyBoxReward_Cmd
end
function MsgType.Response_User_DailyBoxReward:GetUrl()
    return "Response_User_DailyBoxReward"
end
function MsgType.Response_User_DailyBoxReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    return self
end


MsgType.ETowerExploreRewardState = {
    Idle = 1,
    CanReward = 2,
    Rewarded = 3
}

MsgType.OneTowerInfo = {
    id = 0,
    rank = 0,
    index = 0,
    rewardState = 0, --enum ETowerExploreRewardState
    vipRewardState = 0 --enum ETowerExploreRewardState
}
MsgType.OneTowerInfo.__index = MsgType.OneTowerInfo

function MsgType.OneTowerInfo:New()
    local tb = {}
    setmetatable(tb, self)
    return tb
end

function MsgType.OneTowerInfo:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.rank and 0 ~= self.rank then
        tb.c = self.rank
    end
    if nil ~= self.index and 0 ~= self.index then
        tb.d = self.index
    end
    if nil ~= self.rewardState and 0 ~= self.rewardState then
        tb.e = self.rewardState
    end
    if nil ~= self.vipRewardState and 0 ~= self.vipRewardState then
        tb.f = self.vipRewardState
    end
    return tb
end

function MsgType.OneTowerInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.rank = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.index = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.rewardState = tonumber(data.e) or 0
    end
    if nil ~= data.f then
        self.vipRewardState = tonumber(data.f) or 0
    end
    return self
end

function MsgType.OneTowerInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneTowerInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Tower_Info = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Tower_Info.__index = MsgType.Request_Tower_Info

function MsgType.Request_Tower_Info:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Tower_Info:GetCmd()
    return MsgTypeCmd.Request_Tower_Info_Cmd
end
function MsgType.Request_Tower_Info:GetUrl()
    return "Request_Tower_Info"
end
function MsgType.Request_Tower_Info:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Tower_Info:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Tower_Info:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Tower_Info = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userStartFlag = 0,
    userRank = 0,
    userIndex = 0,
    towerList = {}, -- array of MsgType.OneTowerInfo
    remainTime = 0
}
MsgType.Response_Tower_Info.__index = MsgType.Response_Tower_Info

function MsgType.Response_Tower_Info:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.towerList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Tower_Info:GetCmd()
    return MsgTypeCmd.Response_Tower_Info_Cmd
end
function MsgType.Response_Tower_Info:GetUrl()
    return "Response_Tower_Info"
end
function MsgType.Response_Tower_Info:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userStartFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userRank = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.userIndex = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpTowerListObj = MsgType.OneTowerInfo:New()
            tmpTowerListObj:Decode(data.i[i])
            self.towerList[i] = tmpTowerListObj
        end
    end
    if nil ~= data.j then
        self.remainTime = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_Tower_ExploreStart = {
    msgSeq = 0,
    exploreSlotId = 0,
    exploreId = 0,
    exploreType = 0,
    useItemId = 0,
    heroInfoUIds = ""
}
MsgType.Request_Tower_ExploreStart.__index = MsgType.Request_Tower_ExploreStart

function MsgType.Request_Tower_ExploreStart:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Tower_ExploreStart:GetCmd()
    return MsgTypeCmd.Request_Tower_ExploreStart_Cmd
end
function MsgType.Request_Tower_ExploreStart:GetUrl()
    return "Request_Tower_ExploreStart"
end
function MsgType.Request_Tower_ExploreStart:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exploreSlotId and 0 ~= self.exploreSlotId then
        tb.c = self.exploreSlotId
    end
    if nil ~= self.exploreId and 0 ~= self.exploreId then
        tb.d = self.exploreId
    end
    if nil ~= self.exploreType and 0 ~= self.exploreType then
        tb.e = self.exploreType
    end
    if nil ~= self.useItemId and 0 ~= self.useItemId then
        tb.f = self.useItemId
    end
    if nil ~= self.heroInfoUIds and string.len(self.heroInfoUIds) > 0 then
        tb.g = self.heroInfoUIds
    end
    return tb
end

function MsgType.Request_Tower_ExploreStart:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Tower_ExploreStart:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Tower_ExploreStart = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {},
    heroInfo = {} -- array of MsgType.HeroInfo
}
MsgType.Response_Tower_ExploreStart.__index = MsgType.Response_Tower_ExploreStart
setmetatable(MsgType.Response_Tower_ExploreStart.exploreSlot, MsgType.ExploreSlot)

function MsgType.Response_Tower_ExploreStart:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    tb.heroInfo = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Tower_ExploreStart:GetCmd()
    return MsgTypeCmd.Response_Tower_ExploreStart_Cmd
end
function MsgType.Response_Tower_ExploreStart:GetUrl()
    return "Response_Tower_ExploreStart"
end
function MsgType.Response_Tower_ExploreStart:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpHeroInfoObj = MsgType.HeroInfo:New()
            tmpHeroInfoObj:Decode(data.g[i])
            self.heroInfo[i] = tmpHeroInfoObj
        end
    end
    return self
end


MsgType.Request_Tower_ExploreEnd = {
    msgSeq = 0,
    exploreSlotId = 0
}
MsgType.Request_Tower_ExploreEnd.__index = MsgType.Request_Tower_ExploreEnd

function MsgType.Request_Tower_ExploreEnd:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Tower_ExploreEnd:GetCmd()
    return MsgTypeCmd.Request_Tower_ExploreEnd_Cmd
end
function MsgType.Request_Tower_ExploreEnd:GetUrl()
    return "Request_Tower_ExploreEnd"
end
function MsgType.Request_Tower_ExploreEnd:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.exploreSlotId and 0 ~= self.exploreSlotId then
        tb.c = self.exploreSlotId
    end
    return tb
end

function MsgType.Request_Tower_ExploreEnd:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Tower_ExploreEnd:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Tower_ExploreEnd = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {},
    exploreId = 0,
    resultState = 0,
    rewardList = {}, -- array of MsgType.OneRewardItem
    brokeEquipList = {}, -- array of MsgType.HeroBrokenEquip
    getMoney = 0,
    heroInfo = {}, -- array of MsgType.HeroInfo
    combatReport = {}
}
MsgType.Response_Tower_ExploreEnd.__index = MsgType.Response_Tower_ExploreEnd
setmetatable(MsgType.Response_Tower_ExploreEnd.exploreSlot, MsgType.ExploreSlot)
setmetatable(MsgType.Response_Tower_ExploreEnd.combatReport, MsgType.CombatReport)

function MsgType.Response_Tower_ExploreEnd:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    tb.rewardList = {}
    tb.brokeEquipList = {}
    tb.heroInfo = {}
    tb.combatReport = MsgType.CombatReport:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Tower_ExploreEnd:GetCmd()
    return MsgTypeCmd.Response_Tower_ExploreEnd_Cmd
end
function MsgType.Response_Tower_ExploreEnd:GetUrl()
    return "Response_Tower_ExploreEnd"
end
function MsgType.Response_Tower_ExploreEnd:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    if nil ~= data.g then
        self.exploreId = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.resultState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.i[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.j then
        for i=1, #data.j do
            local tmpBrokeEquipListObj = MsgType.HeroBrokenEquip:New()
            tmpBrokeEquipListObj:Decode(data.j[i])
            self.brokeEquipList[i] = tmpBrokeEquipListObj
        end
    end
    if nil ~= data.k then
        self.getMoney = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        for i=1, #data.l do
            local tmpHeroInfoObj = MsgType.HeroInfo:New()
            tmpHeroInfoObj:Decode(data.l[i])
            self.heroInfo[i] = tmpHeroInfoObj
        end
    end
    if nil ~= data.m then
        self.combatReport:Decode(data.m)
    end
    return self
end


MsgType.Request_Tower_ExploreImmediately = {
    msgSeq = 0,
    slotId = 0
}
MsgType.Request_Tower_ExploreImmediately.__index = MsgType.Request_Tower_ExploreImmediately

function MsgType.Request_Tower_ExploreImmediately:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Tower_ExploreImmediately:GetCmd()
    return MsgTypeCmd.Request_Tower_ExploreImmediately_Cmd
end
function MsgType.Request_Tower_ExploreImmediately:GetUrl()
    return "Request_Tower_ExploreImmediately"
end
function MsgType.Request_Tower_ExploreImmediately:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.slotId and 0 ~= self.slotId then
        tb.c = self.slotId
    end
    return tb
end

function MsgType.Request_Tower_ExploreImmediately:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Tower_ExploreImmediately:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Tower_ExploreImmediately = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exploreSlot = {}
}
MsgType.Response_Tower_ExploreImmediately.__index = MsgType.Response_Tower_ExploreImmediately
setmetatable(MsgType.Response_Tower_ExploreImmediately.exploreSlot, MsgType.ExploreSlot)

function MsgType.Response_Tower_ExploreImmediately:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exploreSlot = MsgType.ExploreSlot:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Tower_ExploreImmediately:GetCmd()
    return MsgTypeCmd.Response_Tower_ExploreImmediately_Cmd
end
function MsgType.Response_Tower_ExploreImmediately:GetUrl()
    return "Response_Tower_ExploreImmediately"
end
function MsgType.Response_Tower_ExploreImmediately:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exploreSlot:Decode(data.f)
    end
    return self
end


MsgType.Request_Tower_Reward = {
    msgSeq = 0,
    id = 0,
    vipFlag = 0
}
MsgType.Request_Tower_Reward.__index = MsgType.Request_Tower_Reward

function MsgType.Request_Tower_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Tower_Reward:GetCmd()
    return MsgTypeCmd.Request_Tower_Reward_Cmd
end
function MsgType.Request_Tower_Reward:GetUrl()
    return "Request_Tower_Reward"
end
function MsgType.Request_Tower_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.id and 0 ~= self.id then
        tb.c = self.id
    end
    if nil ~= self.vipFlag and 0 ~= self.vipFlag then
        tb.d = self.vipFlag
    end
    return tb
end

function MsgType.Request_Tower_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Tower_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Tower_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    towerList = {}, -- array of MsgType.OneTowerInfo
    reward = {}
}
MsgType.Response_Tower_Reward.__index = MsgType.Response_Tower_Reward
setmetatable(MsgType.Response_Tower_Reward.reward, MsgType.OneRewardItem)

function MsgType.Response_Tower_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.towerList = {}
    tb.reward = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Tower_Reward:GetCmd()
    return MsgTypeCmd.Response_Tower_Reward_Cmd
end
function MsgType.Response_Tower_Reward:GetUrl()
    return "Response_Tower_Reward"
end
function MsgType.Response_Tower_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTowerListObj = MsgType.OneTowerInfo:New()
            tmpTowerListObj:Decode(data.f[i])
            self.towerList[i] = tmpTowerListObj
        end
    end
    if nil ~= data.g then
        self.reward:Decode(data.g)
    end
    return self
end


MsgType.EPointActivityTaskType = {
    LoginReward = 1,
    PiggyBank = 2,
    MakeEquip = 3,
    SellEquip = 4,
    SellChat = 5,
    DoubleSellEquip = 6,
    DisCountSellEquip = 7,
    MakeEquipType1 = 8,
    MakeEquipType2 = 9,
    MakeEquipType3 = 10,
    MakeEquipType4 = 11,
    MakeEquipType5 = 12,
    MakeEquipType6 = 13,
    MakeEquipType7 = 14,
    MakeEquipType8 = 15,
    MakeEquipType9 = 16,
    MakeEquipType10 = 17,
    MakeEquipType11 = 18,
    MakeEquipType12 = 19,
    MakeEquipType13 = 20,
    MakeEquipType14 = 21,
    MakeEquipType15 = 22,
    MakeEquipType16 = 23,
    MakeEquipType17 = 24,
    MakeEquipType18 = 25,
    MakeEquipType19 = 26,
    MakeEquipType20 = 27,
    CostBagResource1 = 28,
    CostBagResource2 = 29,
    CostBagResource3 = 30,
    CostBagResource4 = 31,
    UnionTaskPoint = 32,
    OpenBox = 33,
    ExploreItem = 34,
    ExploreInstance = 35,
    ExploreBoss = 36,
    DailyTaskPoint = 37,
    HighQualityEquip = 38,
    MakeSpecialEquip1 = 39,
    MakeSpecialEquip2 = 40,
    MakeSpecialEquip3 = 41,
    HeroListRefresh = 42,
    Prize = 43,
    PayOrder = 44,
    PayBalance = 45,
    GoldStore = 46
}

MsgType.EPointActivityTaskState = {
    Idle = 1,
    CanReward = 2,
    Rewarded = 3
}

MsgType.OnePointActivityTaskInfo = {
    id = 0,
    type = 0,
    param = 0,
    rewardList = {}, -- array of MsgType.OneRewardItem
    process = 0,
    state = 0 --enum EPointActivityTaskState
}
MsgType.OnePointActivityTaskInfo.__index = MsgType.OnePointActivityTaskInfo

function MsgType.OnePointActivityTaskInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.rewardList = {}
    return tb
end

function MsgType.OnePointActivityTaskInfo:_rewardListEncode()
    local tb = {}
    for i=1, #self.rewardList do
        tb[i] = self.rewardList[i]:Encode()
    end
    return tb
end
function MsgType.OnePointActivityTaskInfo:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.c = self.type
    end
    if nil ~= self.param and 0 ~= self.param then
        tb.d = self.param
    end
    tb.e = self:_rewardListEncode()
    if nil ~= self.process and 0 ~= self.process then
        tb.f = self.process
    end
    if nil ~= self.state and 0 ~= self.state then
        tb.g = self.state
    end
    return tb
end

function MsgType.OnePointActivityTaskInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.type = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.param = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        for i=1, #data.e do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.e[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.f then
        self.process = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.state = tonumber(data.g) or 0
    end
    return self
end

function MsgType.OnePointActivityTaskInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OnePointActivityTaskInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.OnePointActivityExchangeInfo = {
    id = 0,
    itemId = 0,
    needPoint = 0,
    reward = {},
    count = 0,
    process = 0
}
MsgType.OnePointActivityExchangeInfo.__index = MsgType.OnePointActivityExchangeInfo
setmetatable(MsgType.OnePointActivityExchangeInfo.reward, MsgType.OneRewardItem)

function MsgType.OnePointActivityExchangeInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.reward = MsgType.OneRewardItem:New()
    return tb
end

function MsgType.OnePointActivityExchangeInfo:Encode()
    local tb = {}
    if nil ~= self.id and 0 ~= self.id then
        tb.b = self.id
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    if nil ~= self.needPoint and 0 ~= self.needPoint then
        tb.d = self.needPoint
    end
    tb.e = self.reward:Encode()
    if nil ~= self.count and 0 ~= self.count then
        tb.f = self.count
    end
    if nil ~= self.process and 0 ~= self.process then
        tb.g = self.process
    end
    return tb
end

function MsgType.OnePointActivityExchangeInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.id = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        self.itemId = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.needPoint = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.reward:Decode(data.e)
    end
    if nil ~= data.f then
        self.count = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.process = tonumber(data.g) or 0
    end
    return self
end

function MsgType.OnePointActivityExchangeInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OnePointActivityExchangeInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_PointActivity_CheckData = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_PointActivity_CheckData.__index = MsgType.Request_PointActivity_CheckData

function MsgType.Request_PointActivity_CheckData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity_CheckData:GetCmd()
    return MsgTypeCmd.Request_PointActivity_CheckData_Cmd
end
function MsgType.Request_PointActivity_CheckData:GetUrl()
    return "Request_PointActivity_CheckData"
end
function MsgType.Request_PointActivity_CheckData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_PointActivity_CheckData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity_CheckData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity_CheckData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityFlag = 0,
    stringList = {}, -- array of MsgType.OneOperatingActivityStringData
    taskList = {}, -- array of MsgType.OnePointActivityTaskInfo
    remainTime = 0
}
MsgType.Response_PointActivity_CheckData.__index = MsgType.Response_PointActivity_CheckData

function MsgType.Response_PointActivity_CheckData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.stringList = {}
    tb.taskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity_CheckData:GetCmd()
    return MsgTypeCmd.Response_PointActivity_CheckData_Cmd
end
function MsgType.Response_PointActivity_CheckData:GetUrl()
    return "Response_PointActivity_CheckData"
end
function MsgType.Response_PointActivity_CheckData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpStringListObj = MsgType.OneOperatingActivityStringData:New()
            tmpStringListObj:Decode(data.g[i])
            self.stringList[i] = tmpStringListObj
        end
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpTaskListObj = MsgType.OnePointActivityTaskInfo:New()
            tmpTaskListObj:Decode(data.h[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.i then
        self.remainTime = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_PointActivity_CheckExchange = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_PointActivity_CheckExchange.__index = MsgType.Request_PointActivity_CheckExchange

function MsgType.Request_PointActivity_CheckExchange:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity_CheckExchange:GetCmd()
    return MsgTypeCmd.Request_PointActivity_CheckExchange_Cmd
end
function MsgType.Request_PointActivity_CheckExchange:GetUrl()
    return "Request_PointActivity_CheckExchange"
end
function MsgType.Request_PointActivity_CheckExchange:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_PointActivity_CheckExchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity_CheckExchange:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity_CheckExchange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userPoint = 0,
    userPoint2 = 0,
    exchangeList = {}, -- array of MsgType.OnePointActivityExchangeInfo
    exchangeFlag = 0,
    exchangeRemainTime = 0
}
MsgType.Response_PointActivity_CheckExchange.__index = MsgType.Response_PointActivity_CheckExchange

function MsgType.Response_PointActivity_CheckExchange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchangeList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity_CheckExchange:GetCmd()
    return MsgTypeCmd.Response_PointActivity_CheckExchange_Cmd
end
function MsgType.Response_PointActivity_CheckExchange:GetUrl()
    return "Response_PointActivity_CheckExchange"
end
function MsgType.Response_PointActivity_CheckExchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userPoint2 = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpExchangeListObj = MsgType.OnePointActivityExchangeInfo:New()
            tmpExchangeListObj:Decode(data.h[i])
            self.exchangeList[i] = tmpExchangeListObj
        end
    end
    if nil ~= data.i then
        self.exchangeFlag = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.exchangeRemainTime = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_PointActivity_CheckExchange2 = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_PointActivity_CheckExchange2.__index = MsgType.Request_PointActivity_CheckExchange2

function MsgType.Request_PointActivity_CheckExchange2:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity_CheckExchange2:GetCmd()
    return MsgTypeCmd.Request_PointActivity_CheckExchange2_Cmd
end
function MsgType.Request_PointActivity_CheckExchange2:GetUrl()
    return "Request_PointActivity_CheckExchange2"
end
function MsgType.Request_PointActivity_CheckExchange2:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_PointActivity_CheckExchange2:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity_CheckExchange2:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity_CheckExchange2 = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userPoint = 0,
    userPoint2 = 0,
    exchangeList2 = {}, -- array of MsgType.OnePointActivityExchangeInfo
    exchangeFlag2 = 0,
    exchangeRemainTime2 = 0
}
MsgType.Response_PointActivity_CheckExchange2.__index = MsgType.Response_PointActivity_CheckExchange2

function MsgType.Response_PointActivity_CheckExchange2:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchangeList2 = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity_CheckExchange2:GetCmd()
    return MsgTypeCmd.Response_PointActivity_CheckExchange2_Cmd
end
function MsgType.Response_PointActivity_CheckExchange2:GetUrl()
    return "Response_PointActivity_CheckExchange2"
end
function MsgType.Response_PointActivity_CheckExchange2:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userPoint2 = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpExchangeList2Obj = MsgType.OnePointActivityExchangeInfo:New()
            tmpExchangeList2Obj:Decode(data.h[i])
            self.exchangeList2[i] = tmpExchangeList2Obj
        end
    end
    if nil ~= data.i then
        self.exchangeFlag2 = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.exchangeRemainTime2 = tonumber(data.j) or 0
    end
    return self
end


MsgType.Request_PointActivity_Reward = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_PointActivity_Reward.__index = MsgType.Request_PointActivity_Reward

function MsgType.Request_PointActivity_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity_Reward:GetCmd()
    return MsgTypeCmd.Request_PointActivity_Reward_Cmd
end
function MsgType.Request_PointActivity_Reward:GetUrl()
    return "Request_PointActivity_Reward"
end
function MsgType.Request_PointActivity_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_PointActivity_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    task = {},
    rewardList = {}, -- array of MsgType.OneRewardItem
    userPoint = 0,
    userPoint2 = 0
}
MsgType.Response_PointActivity_Reward.__index = MsgType.Response_PointActivity_Reward
setmetatable(MsgType.Response_PointActivity_Reward.task, MsgType.OnePointActivityTaskInfo)

function MsgType.Response_PointActivity_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.task = MsgType.OnePointActivityTaskInfo:New()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity_Reward:GetCmd()
    return MsgTypeCmd.Response_PointActivity_Reward_Cmd
end
function MsgType.Response_PointActivity_Reward:GetUrl()
    return "Response_PointActivity_Reward"
end
function MsgType.Response_PointActivity_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.task:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.g[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.h then
        self.userPoint = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.userPoint2 = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_PointActivity_Exchange = {
    msgSeq = 0,
    id = 0,
    itemId = 0
}
MsgType.Request_PointActivity_Exchange.__index = MsgType.Request_PointActivity_Exchange

function MsgType.Request_PointActivity_Exchange:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity_Exchange:GetCmd()
    return MsgTypeCmd.Request_PointActivity_Exchange_Cmd
end
function MsgType.Request_PointActivity_Exchange:GetUrl()
    return "Request_PointActivity_Exchange"
end
function MsgType.Request_PointActivity_Exchange:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.id and 0 ~= self.id then
        tb.c = self.id
    end
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.d = self.itemId
    end
    return tb
end

function MsgType.Request_PointActivity_Exchange:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity_Exchange:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity_Exchange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    exchange = {},
    reward = {},
    userPoint = 0,
    userPoint2 = 0
}
MsgType.Response_PointActivity_Exchange.__index = MsgType.Response_PointActivity_Exchange
setmetatable(MsgType.Response_PointActivity_Exchange.exchange, MsgType.OnePointActivityExchangeInfo)
setmetatable(MsgType.Response_PointActivity_Exchange.reward, MsgType.OneRewardItem)

function MsgType.Response_PointActivity_Exchange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.exchange = MsgType.OnePointActivityExchangeInfo:New()
    tb.reward = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity_Exchange:GetCmd()
    return MsgTypeCmd.Response_PointActivity_Exchange_Cmd
end
function MsgType.Response_PointActivity_Exchange:GetUrl()
    return "Response_PointActivity_Exchange"
end
function MsgType.Response_PointActivity_Exchange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.exchange:Decode(data.f)
    end
    if nil ~= data.g then
        self.reward:Decode(data.g)
    end
    if nil ~= data.h then
        self.userPoint = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.userPoint2 = tonumber(data.i) or 0
    end
    return self
end


MsgType.Response_PointActivity_TaskChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {} -- array of MsgType.OnePointActivityTaskInfo
}
MsgType.Response_PointActivity_TaskChange.__index = MsgType.Response_PointActivity_TaskChange

function MsgType.Response_PointActivity_TaskChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity_TaskChange:GetCmd()
    return MsgTypeCmd.Response_PointActivity_TaskChange_Cmd
end
function MsgType.Response_PointActivity_TaskChange:GetUrl()
    return "Response_PointActivity_TaskChange"
end
function MsgType.Response_PointActivity_TaskChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OnePointActivityTaskInfo:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    return self
end


MsgType.Request_PointActivity2_CheckData = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_PointActivity2_CheckData.__index = MsgType.Request_PointActivity2_CheckData

function MsgType.Request_PointActivity2_CheckData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity2_CheckData:GetCmd()
    return MsgTypeCmd.Request_PointActivity2_CheckData_Cmd
end
function MsgType.Request_PointActivity2_CheckData:GetUrl()
    return "Request_PointActivity2_CheckData"
end
function MsgType.Request_PointActivity2_CheckData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_PointActivity2_CheckData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity2_CheckData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity2_CheckData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityFlag = 0,
    version = 0,
    stringList = {}, -- array of MsgType.OneOperatingActivityStringData
    taskList = {}, -- array of MsgType.OnePointActivityTaskInfo
    remainTime = 0
}
MsgType.Response_PointActivity2_CheckData.__index = MsgType.Response_PointActivity2_CheckData

function MsgType.Response_PointActivity2_CheckData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.stringList = {}
    tb.taskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_CheckData:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_CheckData_Cmd
end
function MsgType.Response_PointActivity2_CheckData:GetUrl()
    return "Response_PointActivity2_CheckData"
end
function MsgType.Response_PointActivity2_CheckData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.version = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpStringListObj = MsgType.OneOperatingActivityStringData:New()
            tmpStringListObj:Decode(data.h[i])
            self.stringList[i] = tmpStringListObj
        end
    end
    if nil ~= data.i then
        for i=1, #data.i do
            local tmpTaskListObj = MsgType.OnePointActivityTaskInfo:New()
            tmpTaskListObj:Decode(data.i[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    if nil ~= data.j then
        self.remainTime = tonumber(data.j) or 0
    end
    return self
end


MsgType.Response_PointActivity2_TaskChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    taskList = {} -- array of MsgType.OnePointActivityTaskInfo
}
MsgType.Response_PointActivity2_TaskChange.__index = MsgType.Response_PointActivity2_TaskChange

function MsgType.Response_PointActivity2_TaskChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.taskList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_TaskChange:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_TaskChange_Cmd
end
function MsgType.Response_PointActivity2_TaskChange:GetUrl()
    return "Response_PointActivity2_TaskChange"
end
function MsgType.Response_PointActivity2_TaskChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpTaskListObj = MsgType.OnePointActivityTaskInfo:New()
            tmpTaskListObj:Decode(data.f[i])
            self.taskList[i] = tmpTaskListObj
        end
    end
    return self
end


MsgType.Request_PointActivity2_TaskReward = {
    msgSeq = 0,
    taskId = 0
}
MsgType.Request_PointActivity2_TaskReward.__index = MsgType.Request_PointActivity2_TaskReward

function MsgType.Request_PointActivity2_TaskReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity2_TaskReward:GetCmd()
    return MsgTypeCmd.Request_PointActivity2_TaskReward_Cmd
end
function MsgType.Request_PointActivity2_TaskReward:GetUrl()
    return "Request_PointActivity2_TaskReward"
end
function MsgType.Request_PointActivity2_TaskReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.taskId and 0 ~= self.taskId then
        tb.c = self.taskId
    end
    return tb
end

function MsgType.Request_PointActivity2_TaskReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity2_TaskReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity2_TaskReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    task = {},
    rewardList = {}, -- array of MsgType.OneRewardItem
    activityPoint = 0,
    userActivityPoint = 0
}
MsgType.Response_PointActivity2_TaskReward.__index = MsgType.Response_PointActivity2_TaskReward
setmetatable(MsgType.Response_PointActivity2_TaskReward.task, MsgType.OnePointActivityTaskInfo)

function MsgType.Response_PointActivity2_TaskReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.task = MsgType.OnePointActivityTaskInfo:New()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_TaskReward:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_TaskReward_Cmd
end
function MsgType.Response_PointActivity2_TaskReward:GetUrl()
    return "Response_PointActivity2_TaskReward"
end
function MsgType.Response_PointActivity2_TaskReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.task:Decode(data.f)
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardListObj = MsgType.OneRewardItem:New()
            tmpRewardListObj:Decode(data.g[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.h then
        self.activityPoint = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.userActivityPoint = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_PointActivity2_CheckReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_PointActivity2_CheckReward.__index = MsgType.Request_PointActivity2_CheckReward

function MsgType.Request_PointActivity2_CheckReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity2_CheckReward:GetCmd()
    return MsgTypeCmd.Request_PointActivity2_CheckReward_Cmd
end
function MsgType.Request_PointActivity2_CheckReward:GetUrl()
    return "Request_PointActivity2_CheckReward"
end
function MsgType.Request_PointActivity2_CheckReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_PointActivity2_CheckReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity2_CheckReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity2_CheckReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityFlag = 0,
    rewardList = {}, -- array of MsgType.OneOperatingActivityRewardInfo
    activityPoint = 0,
    userActivityPoint = 0
}
MsgType.Response_PointActivity2_CheckReward.__index = MsgType.Response_PointActivity2_CheckReward

function MsgType.Response_PointActivity2_CheckReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_CheckReward:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_CheckReward_Cmd
end
function MsgType.Response_PointActivity2_CheckReward:GetUrl()
    return "Response_PointActivity2_CheckReward"
end
function MsgType.Response_PointActivity2_CheckReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardListObj = MsgType.OneOperatingActivityRewardInfo:New()
            tmpRewardListObj:Decode(data.g[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.h then
        self.activityPoint = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.userActivityPoint = tonumber(data.i) or 0
    end
    return self
end


MsgType.Request_PointActivity2_Reward = {
    msgSeq = 0,
    groupId = 0,
    id = 0
}
MsgType.Request_PointActivity2_Reward.__index = MsgType.Request_PointActivity2_Reward

function MsgType.Request_PointActivity2_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity2_Reward:GetCmd()
    return MsgTypeCmd.Request_PointActivity2_Reward_Cmd
end
function MsgType.Request_PointActivity2_Reward:GetUrl()
    return "Request_PointActivity2_Reward"
end
function MsgType.Request_PointActivity2_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.c = self.groupId
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.d = self.id
    end
    return tb
end

function MsgType.Request_PointActivity2_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity2_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity2_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {},
    reward = {}
}
MsgType.Response_PointActivity2_Reward.__index = MsgType.Response_PointActivity2_Reward
setmetatable(MsgType.Response_PointActivity2_Reward.rewardItem, MsgType.OneOperatingActivityRewardInfo)
setmetatable(MsgType.Response_PointActivity2_Reward.reward, MsgType.OneRewardItem)

function MsgType.Response_PointActivity2_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneOperatingActivityRewardInfo:New()
    tb.reward = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_Reward:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_Reward_Cmd
end
function MsgType.Response_PointActivity2_Reward:GetUrl()
    return "Response_PointActivity2_Reward"
end
function MsgType.Response_PointActivity2_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    if nil ~= data.g then
        self.reward:Decode(data.g)
    end
    return self
end


MsgType.Response_PointActivity2_RewardChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {}
}
MsgType.Response_PointActivity2_RewardChange.__index = MsgType.Response_PointActivity2_RewardChange
setmetatable(MsgType.Response_PointActivity2_RewardChange.rewardItem, MsgType.OneOperatingActivityRewardInfo)

function MsgType.Response_PointActivity2_RewardChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneOperatingActivityRewardInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_RewardChange:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_RewardChange_Cmd
end
function MsgType.Response_PointActivity2_RewardChange:GetUrl()
    return "Response_PointActivity2_RewardChange"
end
function MsgType.Response_PointActivity2_RewardChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    return self
end


MsgType.Response_PointActivity2_ActivityPointChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityPoint = 0,
    userActivityPoint = 0
}
MsgType.Response_PointActivity2_ActivityPointChange.__index = MsgType.Response_PointActivity2_ActivityPointChange

function MsgType.Response_PointActivity2_ActivityPointChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_ActivityPointChange:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_ActivityPointChange_Cmd
end
function MsgType.Response_PointActivity2_ActivityPointChange:GetUrl()
    return "Response_PointActivity2_ActivityPointChange"
end
function MsgType.Response_PointActivity2_ActivityPointChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.userActivityPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_PointActivity2_UnionRankList = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_PointActivity2_UnionRankList.__index = MsgType.Request_PointActivity2_UnionRankList

function MsgType.Request_PointActivity2_UnionRankList:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_PointActivity2_UnionRankList:GetCmd()
    return MsgTypeCmd.Request_PointActivity2_UnionRankList_Cmd
end
function MsgType.Request_PointActivity2_UnionRankList:GetUrl()
    return "Request_PointActivity2_UnionRankList"
end
function MsgType.Request_PointActivity2_UnionRankList:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_PointActivity2_UnionRankList:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_PointActivity2_UnionRankList:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_PointActivity2_UnionRankList = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rankList = {}, -- array of MsgType.OneOperatingActivityUnionRankInfo
    userRank = {}
}
MsgType.Response_PointActivity2_UnionRankList.__index = MsgType.Response_PointActivity2_UnionRankList
setmetatable(MsgType.Response_PointActivity2_UnionRankList.userRank, MsgType.OneOperatingActivityUnionRankInfo)

function MsgType.Response_PointActivity2_UnionRankList:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rankList = {}
    tb.userRank = MsgType.OneOperatingActivityUnionRankInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_PointActivity2_UnionRankList:GetCmd()
    return MsgTypeCmd.Response_PointActivity2_UnionRankList_Cmd
end
function MsgType.Response_PointActivity2_UnionRankList:GetUrl()
    return "Response_PointActivity2_UnionRankList"
end
function MsgType.Response_PointActivity2_UnionRankList:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        for i=1, #data.f do
            local tmpRankListObj = MsgType.OneOperatingActivityUnionRankInfo:New()
            tmpRankListObj:Decode(data.f[i])
            self.rankList[i] = tmpRankListObj
        end
    end
    if nil ~= data.g then
        self.userRank:Decode(data.g)
    end
    return self
end


MsgType.Request_Dragon_CheckData = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Dragon_CheckData.__index = MsgType.Request_Dragon_CheckData

function MsgType.Request_Dragon_CheckData:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Dragon_CheckData:GetCmd()
    return MsgTypeCmd.Request_Dragon_CheckData_Cmd
end
function MsgType.Request_Dragon_CheckData:GetUrl()
    return "Request_Dragon_CheckData"
end
function MsgType.Request_Dragon_CheckData:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Dragon_CheckData:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Dragon_CheckData:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Dragon_CheckData = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityFlag = 0,
    version = 0,
    stringList = {}, -- array of MsgType.OneOperatingActivityStringData
    remainTime = 0,
    currentIndex = 0,
    totalCount = 0,
    stageState = 0,
    stageRemainTime = 0,
    fightPoint = 0,
    equipPoint = 0,
    unionFightPoint = 0,
    heroList = {}, -- array of number
    itemList = {}, -- array of number
    equipCount = 0,
    userPoint = 0,
    unionPoint = 0
}
MsgType.Response_Dragon_CheckData.__index = MsgType.Response_Dragon_CheckData

function MsgType.Response_Dragon_CheckData:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.stringList = {}
    tb.heroList = {}
    tb.itemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_CheckData:GetCmd()
    return MsgTypeCmd.Response_Dragon_CheckData_Cmd
end
function MsgType.Response_Dragon_CheckData:GetUrl()
    return "Response_Dragon_CheckData"
end
function MsgType.Response_Dragon_CheckData:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.version = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        for i=1, #data.h do
            local tmpStringListObj = MsgType.OneOperatingActivityStringData:New()
            tmpStringListObj:Decode(data.h[i])
            self.stringList[i] = tmpStringListObj
        end
    end
    if nil ~= data.i then
        self.remainTime = tonumber(data.i) or 0
    end
    if nil ~= data.j then
        self.currentIndex = tonumber(data.j) or 0
    end
    if nil ~= data.k then
        self.totalCount = tonumber(data.k) or 0
    end
    if nil ~= data.l then
        self.stageState = tonumber(data.l) or 0
    end
    if nil ~= data.m then
        self.stageRemainTime = tonumber(data.m) or 0
    end
    if nil ~= data.n then
        self.fightPoint = tonumber(data.n) or 0
    end
    if nil ~= data.o then
        self.equipPoint = tonumber(data.o) or 0
    end
    if nil ~= data.p then
        self.unionFightPoint = tonumber(data.p) or 0
    end
    if nil ~= data.q and #data.q > 0 then
        for i=1, #data.q do
            self.heroList[i] = tonumber(data.q[i])
        end
    end
    if nil ~= data.r and #data.r > 0 then
        for i=1, #data.r do
            self.itemList[i] = tonumber(data.r[i])
        end
    end
    if nil ~= data.s then
        self.equipCount = tonumber(data.s) or 0
    end
    if nil ~= data.t then
        self.userPoint = tonumber(data.t) or 0
    end
    if nil ~= data.u then
        self.unionPoint = tonumber(data.u) or 0
    end
    return self
end


MsgType.OneDragonRewardInfo = {
    groupId = 0,
    rewardList = {}, -- array of MsgType.OneOperatingActivityRewardData
    needPoint = 0,
    userNeedPoint = 0
}
MsgType.OneDragonRewardInfo.__index = MsgType.OneDragonRewardInfo

function MsgType.OneDragonRewardInfo:New()
    local tb = {}
    setmetatable(tb, self)
    tb.rewardList = {}
    return tb
end

function MsgType.OneDragonRewardInfo:_rewardListEncode()
    local tb = {}
    for i=1, #self.rewardList do
        tb[i] = self.rewardList[i]:Encode()
    end
    return tb
end
function MsgType.OneDragonRewardInfo:Encode()
    local tb = {}
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.b = self.groupId
    end
    tb.c = self:_rewardListEncode()
    if nil ~= self.needPoint and 0 ~= self.needPoint then
        tb.d = self.needPoint
    end
    if nil ~= self.userNeedPoint and 0 ~= self.userNeedPoint then
        tb.e = self.userNeedPoint
    end
    return tb
end

function MsgType.OneDragonRewardInfo:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data.b then
        self.groupId = tonumber(data.b) or 0
    end
    if nil ~= data.c then
        for i=1, #data.c do
            local tmpRewardListObj = MsgType.OneOperatingActivityRewardData:New()
            tmpRewardListObj:Decode(data.c[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.d then
        self.needPoint = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.userNeedPoint = tonumber(data.e) or 0
    end
    return self
end

function MsgType.OneDragonRewardInfo:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.OneDragonRewardInfo:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Request_Dragon_CheckReward = {
    msgSeq = 0,
    none = 0
}
MsgType.Request_Dragon_CheckReward.__index = MsgType.Request_Dragon_CheckReward

function MsgType.Request_Dragon_CheckReward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Dragon_CheckReward:GetCmd()
    return MsgTypeCmd.Request_Dragon_CheckReward_Cmd
end
function MsgType.Request_Dragon_CheckReward:GetUrl()
    return "Request_Dragon_CheckReward"
end
function MsgType.Request_Dragon_CheckReward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.none and 0 ~= self.none then
        tb.c = self.none
    end
    return tb
end

function MsgType.Request_Dragon_CheckReward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Dragon_CheckReward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Dragon_CheckReward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    activityFlag = 0,
    rewardList = {}, -- array of MsgType.OneDragonRewardInfo
    activityPoint = 0,
    userActivityPoint = 0
}
MsgType.Response_Dragon_CheckReward.__index = MsgType.Response_Dragon_CheckReward

function MsgType.Response_Dragon_CheckReward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_CheckReward:GetCmd()
    return MsgTypeCmd.Response_Dragon_CheckReward_Cmd
end
function MsgType.Response_Dragon_CheckReward:GetUrl()
    return "Response_Dragon_CheckReward"
end
function MsgType.Response_Dragon_CheckReward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.activityFlag = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        for i=1, #data.g do
            local tmpRewardListObj = MsgType.OneDragonRewardInfo:New()
            tmpRewardListObj:Decode(data.g[i])
            self.rewardList[i] = tmpRewardListObj
        end
    end
    if nil ~= data.h then
        self.activityPoint = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.userActivityPoint = tonumber(data.i) or 0
    end
    return self
end


MsgType.Response_Dragon_StageChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    currentIndex = 0,
    totalCount = 0,
    stageState = 0,
    stageRemainTime = 0
}
MsgType.Response_Dragon_StageChange.__index = MsgType.Response_Dragon_StageChange

function MsgType.Response_Dragon_StageChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_StageChange:GetCmd()
    return MsgTypeCmd.Response_Dragon_StageChange_Cmd
end
function MsgType.Response_Dragon_StageChange:GetUrl()
    return "Response_Dragon_StageChange"
end
function MsgType.Response_Dragon_StageChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.currentIndex = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.totalCount = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.stageState = tonumber(data.h) or 0
    end
    if nil ~= data.i then
        self.stageRemainTime = tonumber(data.i) or 0
    end
    return self
end


MsgType.Response_Dragon_PointChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    userPoint = 0,
    unionPoint = 0
}
MsgType.Response_Dragon_PointChange.__index = MsgType.Response_Dragon_PointChange

function MsgType.Response_Dragon_PointChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_PointChange:GetCmd()
    return MsgTypeCmd.Response_Dragon_PointChange_Cmd
end
function MsgType.Response_Dragon_PointChange:GetUrl()
    return "Response_Dragon_PointChange"
end
function MsgType.Response_Dragon_PointChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.userPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.unionPoint = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Dragon_Reward = {
    msgSeq = 0,
    groupId = 0,
    id = 0
}
MsgType.Request_Dragon_Reward.__index = MsgType.Request_Dragon_Reward

function MsgType.Request_Dragon_Reward:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Dragon_Reward:GetCmd()
    return MsgTypeCmd.Request_Dragon_Reward_Cmd
end
function MsgType.Request_Dragon_Reward:GetUrl()
    return "Request_Dragon_Reward"
end
function MsgType.Request_Dragon_Reward:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.groupId and 0 ~= self.groupId then
        tb.c = self.groupId
    end
    if nil ~= self.id and 0 ~= self.id then
        tb.d = self.id
    end
    return tb
end

function MsgType.Request_Dragon_Reward:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Dragon_Reward:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Dragon_Reward = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {},
    reward = {}
}
MsgType.Response_Dragon_Reward.__index = MsgType.Response_Dragon_Reward
setmetatable(MsgType.Response_Dragon_Reward.rewardItem, MsgType.OneDragonRewardInfo)
setmetatable(MsgType.Response_Dragon_Reward.reward, MsgType.OneRewardItem)

function MsgType.Response_Dragon_Reward:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneDragonRewardInfo:New()
    tb.reward = MsgType.OneRewardItem:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_Reward:GetCmd()
    return MsgTypeCmd.Response_Dragon_Reward_Cmd
end
function MsgType.Response_Dragon_Reward:GetUrl()
    return "Response_Dragon_Reward"
end
function MsgType.Response_Dragon_Reward:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    if nil ~= data.g then
        self.reward:Decode(data.g)
    end
    return self
end


MsgType.Response_Dragon_RewardChange = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    rewardItem = {}
}
MsgType.Response_Dragon_RewardChange.__index = MsgType.Response_Dragon_RewardChange
setmetatable(MsgType.Response_Dragon_RewardChange.rewardItem, MsgType.OneDragonRewardInfo)

function MsgType.Response_Dragon_RewardChange:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.rewardItem = MsgType.OneDragonRewardInfo:New()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_RewardChange:GetCmd()
    return MsgTypeCmd.Response_Dragon_RewardChange_Cmd
end
function MsgType.Response_Dragon_RewardChange:GetUrl()
    return "Response_Dragon_RewardChange"
end
function MsgType.Response_Dragon_RewardChange:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.rewardItem:Decode(data.f)
    end
    return self
end


MsgType.Request_Dragon_SetHero = {
    msgSeq = 0,
    heroUid = 0,
    type = 0
}
MsgType.Request_Dragon_SetHero.__index = MsgType.Request_Dragon_SetHero

function MsgType.Request_Dragon_SetHero:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Dragon_SetHero:GetCmd()
    return MsgTypeCmd.Request_Dragon_SetHero_Cmd
end
function MsgType.Request_Dragon_SetHero:GetUrl()
    return "Request_Dragon_SetHero"
end
function MsgType.Request_Dragon_SetHero:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.heroUid and 0 ~= self.heroUid then
        tb.c = self.heroUid
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.d = self.type
    end
    return tb
end

function MsgType.Request_Dragon_SetHero:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Dragon_SetHero:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Dragon_SetHero = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    heroList = {}, -- array of number
    fightPoint = 0,
    unionFightPoint = 0
}
MsgType.Response_Dragon_SetHero.__index = MsgType.Response_Dragon_SetHero

function MsgType.Response_Dragon_SetHero:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.heroList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_SetHero:GetCmd()
    return MsgTypeCmd.Response_Dragon_SetHero_Cmd
end
function MsgType.Response_Dragon_SetHero:GetUrl()
    return "Response_Dragon_SetHero"
end
function MsgType.Response_Dragon_SetHero:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.heroList[i] = tonumber(data.f[i])
        end
    end
    if nil ~= data.g then
        self.fightPoint = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionFightPoint = tonumber(data.h) or 0
    end
    return self
end


MsgType.Request_Dragon_SetEquip = {
    msgSeq = 0,
    equipUid = 0,
    type = 0
}
MsgType.Request_Dragon_SetEquip.__index = MsgType.Request_Dragon_SetEquip

function MsgType.Request_Dragon_SetEquip:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Dragon_SetEquip:GetCmd()
    return MsgTypeCmd.Request_Dragon_SetEquip_Cmd
end
function MsgType.Request_Dragon_SetEquip:GetUrl()
    return "Request_Dragon_SetEquip"
end
function MsgType.Request_Dragon_SetEquip:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.equipUid and 0 ~= self.equipUid then
        tb.c = self.equipUid
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.d = self.type
    end
    return tb
end

function MsgType.Request_Dragon_SetEquip:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Dragon_SetEquip:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Dragon_SetEquip = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    equipPoint = 0,
    equipCount = 0
}
MsgType.Response_Dragon_SetEquip.__index = MsgType.Response_Dragon_SetEquip

function MsgType.Response_Dragon_SetEquip:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_SetEquip:GetCmd()
    return MsgTypeCmd.Response_Dragon_SetEquip_Cmd
end
function MsgType.Response_Dragon_SetEquip:GetUrl()
    return "Response_Dragon_SetEquip"
end
function MsgType.Response_Dragon_SetEquip:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f then
        self.equipPoint = tonumber(data.f) or 0
    end
    if nil ~= data.g then
        self.equipCount = tonumber(data.g) or 0
    end
    return self
end


MsgType.Request_Dragon_SetItem = {
    msgSeq = 0,
    itemId = 0,
    type = 0
}
MsgType.Request_Dragon_SetItem.__index = MsgType.Request_Dragon_SetItem

function MsgType.Request_Dragon_SetItem:New()
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    return tb
end

function MsgType.Request_Dragon_SetItem:GetCmd()
    return MsgTypeCmd.Request_Dragon_SetItem_Cmd
end
function MsgType.Request_Dragon_SetItem:GetUrl()
    return "Request_Dragon_SetItem"
end
function MsgType.Request_Dragon_SetItem:Encode()
    local tb = {}
    tb._0 = self.msgSeq or 0
    if nil ~= self.itemId and 0 ~= self.itemId then
        tb.c = self.itemId
    end
    if nil ~= self.type and 0 ~= self.type then
        tb.d = self.type
    end
    return tb
end

function MsgType.Request_Dragon_SetItem:ToEncodeString()
    local tb = self:Encode()
    return JSON:encode(tb)
end

function MsgType.Request_Dragon_SetItem:Send()
    local encodeJsonParams=self:ToEncodeString()
    CS.NetworkManager.inst:Send(self:GetCmd(), encodeJsonParams)
end


MsgType.Response_Dragon_SetItem = {
    msgSeq = 0,
    errorCode = 0, --enum EErrorCode
    timestamp = 0,
    message = "",
    itemList = {}, -- array of number
    fightPoint = 0,
    unionFightPoint = 0
}
MsgType.Response_Dragon_SetItem.__index = MsgType.Response_Dragon_SetItem

function MsgType.Response_Dragon_SetItem:New(...)
    local tb = {}
    setmetatable(tb, self)
    tb.msgSeq = IncKeyMsgSeq()
    tb.itemList = {}
    local temp = { ... }
    local args = temp[1]
    if nil ~= args then
        tb:Decode(args)
    end
    return tb
end

function MsgType.Response_Dragon_SetItem:GetCmd()
    return MsgTypeCmd.Response_Dragon_SetItem_Cmd
end
function MsgType.Response_Dragon_SetItem:GetUrl()
    return "Response_Dragon_SetItem"
end
function MsgType.Response_Dragon_SetItem:Decode(data)
    if nil == data then return self end
    if type(data) == "string" then
        data = JSON:decode(data)
    end
    if nil ~= data._0 then
        self.msgSeq = data._0 or 0
    end
    if nil ~= data.c then
        self.errorCode = tonumber(data.c) or 0
    end
    if nil ~= data.d then
        self.timestamp = tonumber(data.d) or 0
    end
    if nil ~= data.e then
        self.message = tostring(data.e)
    end
    if nil ~= data.f and #data.f > 0 then
        for i=1, #data.f do
            self.itemList[i] = tonumber(data.f[i])
        end
    end
    if nil ~= data.g then
        self.fightPoint = tonumber(data.g) or 0
    end
    if nil ~= data.h then
        self.unionFightPoint = tonumber(data.h) or 0
    end
    return self
end